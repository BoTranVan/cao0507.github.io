<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>解决 VPN 无法打开谷歌学术的问题</title>
      <link href="/2018/12/17/%E8%A7%A3%E5%86%B3vpn%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E8%B0%B7%E6%AD%8C%E5%AD%A6%E6%9C%AF%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2018/12/17/%E8%A7%A3%E5%86%B3vpn%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E8%B0%B7%E6%AD%8C%E5%AD%A6%E6%9C%AF%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>之前搭好的 VPN 用的好好的，最近两天突然不能登录谷歌学术（Google Scholar），但是还能使用谷歌搜索等其他国外的网站。登录谷歌学术网站出现：<code>We&#39;re sorry...... but your computer or network may be sending automated queries. To protect our users, we can&#39;t process your request right now.</code></p><a id="more"></a><p><img src="https://github.com/cao0507/My-Pictures-Repository/blob/master/blog/google%20scholar%20error.png?raw=true" alt=""></p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>出现这个问题是因为我使用的是 Vultr 的 VPS 来搭建 shadowsocks 服务端，而且有很多人都在这些 VPS 服务商（Vultr，搬瓦工，DigitalOcean，Linode等等），然后有人使用这些公网的 IP 段来做爬虫，所以 Google 把这些公网 IP 给封了。但是一般封的都是 IPv4 的地址，IPv6 的地址一般没有被封，所以可以考虑使用 IPv6 来访问谷歌学术的网站。</p><hr><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ol><li><p>首先，找到最新的 Google IPv6 地址，可以在这里查看：<a href="https://raw.githubusercontent.com/lennylxx/ipv6-hosts/master/hosts" target="_blank" rel="noopener">IPv6-hosts</a></p><p>找到 Google 学术对应的 IPv6 地址后，修改服务器的 hosts 文件，<code>vim /etc/hosts</code>，在文件的最后加入如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">## Scholar 学术搜索</span><br><span class="line">2404:6800:4008:c06::be scholar.google.com</span><br><span class="line">2404:6800:4008:c06::be scholar.google.com.hk</span><br><span class="line">2404:6800:4008:c06::be scholar.google.com.tw</span><br><span class="line">2404:6800:4005:805::200e scholar.google.cn #www.google.cn</span><br></pre></td></tr></table></figure></li><li><p>然后，重启 shadowsocks 服务端程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/shadowsocks restart</span><br></pre></td></tr></table></figure><blockquote><p>注：不同的搭建方式可能重启的方式不太一样。我的搭建方式请参考：<a href="https://cao0507.github.io/2018/08/21/VPS%E6%90%AD%E5%BB%BAshadowsocks%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%B9%B6%E5%BC%80%E5%90%AFBBR%E5%8A%A0%E9%80%9F/">shadowsocks服务端搭建</a></p></blockquote><p>之后，就能够正常访问谷歌学术的网站了。</p><p><img src="https://github.com/cao0507/My-Pictures-Repository/blob/master/blog/google%20scholar.png?raw=true" alt=""></p></li></ol><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><p>有些时候，到这里可能还是不能正常访问谷歌学术。这个可能是因为 Vultr 上 5 美元的 VPS 默认使用的是 IPv4 的地址，而没有启用 IPv6 的地址，所以需要给你的 VPS 分配一个 IPv6 的地址。</p><p><strong>Server Information</strong> -&gt; <strong>Settings</strong> -&gt; <strong>IPv6</strong>：给你的 Server 分配（assign）一个 IPv6 地址，分配一个 IPv6 地址是不要钱的。这个过程会重启你的 VPS，重启之后，能看到有一个 IPv6 的地址，如下图：</p><p><img src="https://github.com/cao0507/My-Pictures-Repository/blob/master/blog/vps%20assign%20ipv6.png?raw=true" alt=""></p><blockquote><p>我一开始就是因为没有给我的 VPS 分配 IPv6 地址，所以修改了服务器的 hosts 文件也还是没有解决这个问题。你在解决问题的时候注意要先分配 IPv6 地址哦！</p></blockquote><hr>]]></content>
      
      <categories>
          
          <category> VPN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shadowsocks </tag>
            
            <tag> Bugs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hyperledger Caliper Disable TLS</title>
      <link href="/2018/12/15/fabric-disable-tls/"/>
      <url>/2018/12/15/fabric-disable-tls/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在使用 Hyperledger Caliper 时，想通过 wireshark 抓包来分析 fabric 运行流程中各阶段的数据信息，但是发现 fabric 节点间的通信使用了传输层安全（Transport Layer Security，TLS）协议，使得通信的报文的内容在抓包后无法分析。因此考虑在测试环境中暂时关闭 TLS，从而能够直接查看报文中承载的数据内容。</p><a id="more"></a><hr><h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><h4 id="1-在-docker-compose-的配置文件中修改环境变量"><a href="#1-在-docker-compose-的配置文件中修改环境变量" class="headerlink" title="1. 在 docker-compose 的配置文件中修改环境变量"></a>1. 在 docker-compose 的配置文件中修改环境变量</h4><p>本实验是在 Hyperledger Caliper 的测试环境中进行的，Caliper 测试工具在运行初始阶段会调用 docker-compose 启动 fabric 的网络，启动的 fabric 默认启用了 TLS，可以在其 docker-compose 的启动配置文件 docker-compose.yaml 中看到环境变量：</p><ul><li><code>FABRIC_CA_SERVER_TLS_ENABLED=true</code></li><li><code>ORDERER_GENERAL_TLS_ENABLED=true</code></li><li><code>CORE_PEER_TLS_ENABLED=true</code></li></ul><p>以上三个环境变量都设置为 true。如果要 disable TLS，则需在配置文件 docker-compose.yaml 中将这三个环境变量都注释掉，或者将它们设置为 false。即：</p><ul><li><code>FABRIC_CA_SERVER_TLS_ENABLED=false</code></li><li><code>ORDERER_GENERAL_TLS_ENABLED=false</code></li><li><code>CORE_PEER_TLS_ENABLED=false</code></li></ul><h4 id="2-修改-benchmark-中的-fabric-json-文件"><a href="#2-修改-benchmark-中的-fabric-json-文件" class="headerlink" title="2. 修改 benchmark 中的 fabric.json 文件"></a>2. 修改 benchmark 中的 fabric.json 文件</h4><p>在 benchmark 中的每个例子中，如 simple 的网络配置文件 fabric.json 中，client 与 peer 、orderer、ca 等节点都是通过 grpcs 或 https 来通信的，而这是在使用了 TLS 时的通信方式，因此需要将其改为 grpc 或 http 来通信。修改入下：</p><ul><li><code>orderer.url</code>：<code>grpcs://localhost:7050</code>  ==&gt;  <code>grpc://localhost:7050</code></li><li><code>ca.url</code>：<code>https://localhost:7054</code>  ==&gt;  <code>http://localhost:7054</code></li><li><code>peer1.requests</code>：<code>grpcs://localhost:7051</code>   ==&gt;  <code>grpc://localhost:7051</code></li><li><code>peer1.events</code>：<code>grpcs://localhost:7053</code>   ==&gt;   <code>grpc://localhost:7053</code></li></ul><p>其他的都是如此修改。</p><blockquote><p>如果用 vim 编辑器的话，可以快捷的使用全局替换功能，在 normal 模式下输入冒号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; :1,$  s/grpcs/grpc/g       #表示将第一行到最后一行间的所有grpcs替换成grpc</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h4 id="3-错误记录"><a href="#3-错误记录" class="headerlink" title="3. 错误记录"></a>3. 错误记录</h4><p>如果仅仅修改 docker-compose.yaml 文件中的环境变量，没有修改 fabric.json 中的通信方式的话，则在运行测试时会出现如下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"># create mychannel......</span><br><span class="line">E1215 12:26:25.877864366    9327 ssl_transport_security.cc:989] Handshake failed with fatal error SSL_ERROR_SSL: error:1408F10B:SSL routines:SSL3_GET_RECORD:wrong version number.</span><br><span class="line">E1215 12:26:25.879670836    9327 ssl_transport_security.cc:989] Handshake failed with fatal error SSL_ERROR_SSL: error:1408F10B:SSL routines:SSL3_GET_RECORD:wrong version number.</span><br><span class="line">error: [Orderer.js]: sendBroadcast - on error: &quot;Error: 14 UNAVAILABLE: Connect Failed\n    at createStatusError (/home/user1/caliper/node_modules/grpc/src/client.js:64:15)\n    at ClientDuplexStream._emitStatusIfDone (/home/user1/caliper/node_modules/grpc/src/client.js:270:19)\n    at ClientDuplexStream._readsDone (/home/user1/caliper/node_modules/grpc/src/client.js:236:8)\n    at readCallback (/home/user1/caliper/node_modules/grpc/src/client.js:296:12)&quot;</span><br><span class="line">not ok 1 Failed to create channels Error: SERVICE_UNAVAILABLE at ClientDuplexStream.&lt;anonymous&gt; (/home/user1/caliper/node_modules/fabric-client/lib/Orderer.js:136:21) at emitOne (events.js:116:13) at ClientDuplexStream.emit (events.js:211:7) at ClientDuplexStream._emitStatusIfDone (/home/user1/caliper/node_modules/grpc/src/client.js:271:12) at ClientDuplexStream._readsDone (/home/user1/caliper/node_modules/grpc/src/client.js:236:8) at readCallback (/home/user1/caliper/node_modules/grpc/src/client.js:296:12)</span><br><span class="line">  ---</span><br><span class="line">    operator: fail</span><br><span class="line">    at: channels.reduce.then.then.catch (/home/user1/caliper/src/fabric/create-channel.js:159:19)</span><br><span class="line">    stack: |-</span><br><span class="line">      Error: Failed to create channels Error: SERVICE_UNAVAILABLE</span><br><span class="line">          at ClientDuplexStream.&lt;anonymous&gt; (/home/user1/caliper/node_modules/fabric-client/lib/Orderer.js:136:21)</span><br><span class="line">          at emitOne (events.js:116:13)</span><br><span class="line">          at ClientDuplexStream.emit (events.js:211:7)</span><br><span class="line">          at ClientDuplexStream._emitStatusIfDone (/home/user1/caliper/node_modules/grpc/src/client.js:271:12)</span><br><span class="line">          at ClientDuplexStream._readsDone (/home/user1/caliper/node_modules/grpc/src/client.js:236:8)</span><br><span class="line">          at readCallback (/home/user1/caliper/node_modules/grpc/src/client.js:296:12)</span><br><span class="line">          at Test.assert [as _assert] (/home/user1/caliper/node_modules/tape/lib/test.js:224:54)</span><br><span class="line">          at Test.bound [as _assert] (/home/user1/caliper/node_modules/tape/lib/test.js:76:32)</span><br><span class="line">          at Test.fail (/home/user1/caliper/node_modules/tape/lib/test.js:317:10)</span><br><span class="line">          at Test.bound [as fail] (/home/user1/caliper/node_modules/tape/lib/test.js:76:32)</span><br><span class="line">          at channels.reduce.then.then.catch (/home/user1/caliper/src/fabric/create-channel.js:159:19)</span><br><span class="line">          at &lt;anonymous&gt;</span><br><span class="line">          at process._tickCallback (internal/process/next_tick.js:189:7)</span><br><span class="line">  ...</span><br><span class="line">fabric.init() failed, Error: Fabric: Create channel failed</span><br><span class="line">    at channels.reduce.then.then.catch (/home/user1/caliper/src/fabric/create-channel.js:160:31)</span><br><span class="line">    at &lt;anonymous&gt;</span><br><span class="line">    at process._tickCallback (internal/process/next_tick.js:189:7)</span><br><span class="line">[Transaction Info] - Submitted: 0 Succ: 0 Fail:0 Unfinished:0</span><br><span class="line">unexpected error, Error: Fabric: Create channel failed</span><br><span class="line">    at channels.reduce.then.then.catch (/home/user1/caliper/src/fabric/create-channel.js:160:31)</span><br><span class="line">    at &lt;anonymous&gt;</span><br><span class="line">    at process._tickCallback (internal/process/next_tick.js:189:7)</span><br></pre></td></tr></table></figure><p>这个问题需要注意。</p><hr><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>在 TLS 被开启或关闭两种情况下，能够发现关闭 TLS 后，系统的吞吐率略有提升，这是可想而知的，毕竟减少了一层传输层安全协议的封装。结果图如下：</p><ul><li><p><strong>Enable TLS</strong></p><p><img src="https://github.com/cao0507/My-Pictures-Repository/blob/master/Blockchain/caliper/enable_tls.png?raw=true" alt=""></p></li><li><p><strong>Disable TLS</strong></p><p><img src="https://github.com/cao0507/My-Pictures-Repository/blob/master/Blockchain/caliper/disable_tls.png?raw=true" alt=""></p></li></ul><p>不过以上的结果在实际中的意义并不大，因为在实际应用中肯定需要进行传输层安全协议的封装，不然这区块链的安全从和谈起。</p><p>如下图可以看到关闭 TLS 后，抓包后能够查看数据内容：</p><p><img src="https://github.com/cao0507/My-Pictures-Repository/blob/master/Blockchain/caliper/disable-tls%20%E6%8A%93%E5%8C%85%E7%BB%93%E6%9E%9C.png?raw=true" alt=""></p><p>太不安全了！所以以上内容均只能应用于测试。</p><hr>]]></content>
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hyperledger fabric </tag>
            
            <tag> Hyperledger caliper </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Docker 容器启动时端口映射失败</title>
      <link href="/2018/12/05/docker%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E6%97%B6%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84%E5%A4%B1%E8%B4%A5/"/>
      <url>/2018/12/05/docker%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E6%97%B6%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84%E5%A4%B1%E8%B4%A5/</url>
      <content type="html"><![CDATA[<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>在一台虚拟机上创建容器时因为端口映射的问题而导致容器启动失败，并提示 <code>docker: Error response from daemon: driver failed programming external connectivity on endpoint orderer.example.com (ae62c5d74521cc7ea21dc4d4c762cf09390839a1a21d8dcfdcb3784ecdc5e568): Bind for 0.0.0.0:7050 failed: port is already allocated.</code></p><a id="more"></a><hr><h4 id="1-错误发现过程"><a href="#1-错误发现过程" class="headerlink" title="1. 错误发现过程"></a>1. 错误发现过程</h4><ul><li><p>通过 docker-compose 启动一个容器是提示无法启动容器，错误原因是 <code>Bind for 0.0.0.0:7050 failed: port is already allocated&#39;</code> 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose -f docker-compose-orderer.yaml up -d</span><br><span class="line">Creating orderer.example.com ... error</span><br><span class="line"></span><br><span class="line">ERROR: for orderer.example.com  Cannot start service orderer.example.com: b&apos;driver failed programming external connectivity on endpoint orderer.example.com (b1253c6e3542219f989fb9f6508c738066aeeb2fcdebd1e13b9b85c63c2715dd): Bind for 0.0.0.0:7050 failed: port is already allocated&apos;</span><br><span class="line"></span><br><span class="line">ERROR: for orderer.example.com  Cannot start service orderer.example.com: b&apos;driver failed programming external connectivity on endpoint orderer.example.com (b1253c6e3542219f989fb9f6508c738066aeeb2fcdebd1e13b9b85c63c2715dd): Bind for 0.0.0.0:7050 failed: port is already allocated&apos;</span><br><span class="line">ERROR: Encountered errors while bringing up the project.</span><br></pre></td></tr></table></figure></li><li><p>接着直接使用 docker run 命令启动容器，还是提示一样的错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --name orderer.example.com -d -p 7050:7050 hyperledger/fabric-orderer:x86_64-1.1.0 </span><br><span class="line">07c97104c290f470588bf0cfe041f76771bfc8586b3ad0fe784a20f97c4e4a6f</span><br><span class="line">docker: Error response from daemon: driver failed programming external connectivity on endpoint orderer.example.com (ae62c5d74521cc7ea21dc4d4c762cf09390839a1a21d8dcfdcb3784ecdc5e568): Bind for 0.0.0.0:7050 failed: port is already allocated.</span><br></pre></td></tr></table></figure></li><li><p>查看主机的端口是否被占用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -ntlp</span><br><span class="line">(Not all processes could be identified, non-owned process info</span><br><span class="line"> will not be shown, you would have to be root to see it all.)</span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address        Foreign Address     State       PID/Program name</span><br><span class="line">tcp        0      0 0.0.0.0:22           0.0.0.0:*           LISTEN      -               </span><br><span class="line">tcp6       0      0 :::22                :::*                LISTEN      -               </span><br><span class="line">tcp6       0      0 :::2375              :::*                LISTEN      -</span><br></pre></td></tr></table></figure><p>发现并没有 7050 端口并没有在使用。</p></li><li><p>启动另一个容器，绑定主机的另一个端口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 8050:7050 hyperledger/fabric-orderer:x86_64-1.1.0 </span><br><span class="line">fba31d37ff4cc409740ce8cd045f4f4bc6a76f7c69c454a2d7e380327613acb0</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps</span><br><span class="line">CONTAINER ID        IMAGE                                     COMMAND             CREATED              STATUS              PORTS                    NAMES</span><br><span class="line">fba31d37ff4c        hyperledger/fabric-orderer:x86_64-1.1.0   &quot;orderer&quot;           8 seconds ago        Up 7 seconds        0.0.0.0:8050-&gt;7050/tcp   confident_wescoff</span><br></pre></td></tr></table></figure><p>可以启动。</p></li><li><p>查看 docker 服务状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl status docker</span><br><span class="line">● docker.service - Docker Application Container Engine</span><br><span class="line">   Loaded: loaded (/lib/systemd/system/docker.service; enabled; vendor preset: enabled)</span><br><span class="line">  Drop-In: /etc/systemd/system/docker.service.d</span><br><span class="line">           └─override.conf</span><br><span class="line">   Active: active (running) since Wed 2018-12-05 09:29:11 CST; 1h 14min ago</span><br><span class="line">     Docs: https://docs.docker.com</span><br><span class="line"> Main PID: 987 (dockerd)</span><br><span class="line">    Tasks: 35</span><br><span class="line">   Memory: 161.2M</span><br><span class="line">      CPU: 54.874s</span><br><span class="line">   CGroup: /system.slice/docker.service</span><br><span class="line">           ├─ 987 /usr/bin/dockerd</span><br><span class="line">           └─1089 docker-containerd --config /var/run/docker/containerd/containerd.toml</span><br></pre></td></tr></table></figure><p>服务显示是正常运行的。</p></li></ul><hr><h4 id="2-解决方法"><a href="#2-解决方法" class="headerlink" title="2.解决方法"></a>2.解决方法</h4><p>网上查看了一些方法，可以通过重启 docker 服务来解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl restart docker</span><br></pre></td></tr></table></figure><p>真的解决了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --name orderer.example.com -d -p 7050:7050 hyperledger/fabric-orderer:x86_64-1.1.0 </span><br><span class="line">2f289e5225344e4e07230a0985e9f51f2ef6584af263be28388bdb7f6c80af35</span><br><span class="line"></span><br><span class="line">$ docker ps </span><br><span class="line">CONTAINER ID        IMAGE                                     COMMAND             CREATED             STATUS              PORTS                    NAMES</span><br><span class="line">2f289e522534        hyperledger/fabric-orderer:x86_64-1.1.0   &quot;orderer&quot;           7 seconds ago       Up 6 seconds        0.0.0.0:7050-&gt;7050/tcp   orderer.example.com</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Bugs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode-141-142</title>
      <link href="/2018/10/21/leetcode-141-142/"/>
      <url>/2018/10/21/leetcode-141-142/</url>
      <content type="html"><![CDATA[<h3 id="141-Linked-List-Cycle"><a href="#141-Linked-List-Cycle" class="headerlink" title="141. Linked List Cycle"></a>141. <a href="https://leetcode.com/problems/linked-list-cycle/description/" target="_blank" rel="noopener">Linked List Cycle</a></h3><p>Given a linked list, determine if it has a cycle in it.</p><p>Follow up:<br>Can you solve it without using extra space?</p><a id="more"></a><hr><h4 id="题意理解"><a href="#题意理解" class="headerlink" title="题意理解"></a>题意理解</h4><p>给定一个链表，判断链表中是否有环。不要有额外的空间消耗。</p><hr><h4 id="解法思路"><a href="#解法思路" class="headerlink" title="解法思路"></a>解法思路</h4><p><strong>双指针法：</strong></p><p>最常用的方法，快慢指针，慢指针每次移动一步，快指针一次移动两步。如果链表中没有环，那么快指针将先到达链表结尾，并且指向 NULL；如果链表中有环，则快指针会在环中循环，直到慢指针进入环中，快指针将会追上慢指针，两者相等。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* fast = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(fast-&gt;next != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (slow == fast)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(N)。如果链表中无环，则在快指针到达链表结尾时经过 N/2 步左右，所以复杂度为 O(N)；如果链表中有环，则最坏情况下，当慢指针几乎绕环一圈时快指针才追上它，所以是 N 步左右，所以复杂度为 O(N)。综上，时间复杂度为 O(N)。</li><li>空间复杂度：O(1)。只使用了两个指针。</li></ul><hr><h3 id="142-Linked-List-Cycle-II"><a href="#142-Linked-List-Cycle-II" class="headerlink" title="142. Linked List Cycle II"></a>142. <a href="https://leetcode.com/problems/linked-list-cycle-ii/description/" target="_blank" rel="noopener">Linked List Cycle II</a></h3><p>Given a linked list, return the node where the cycle begins. If there is no cycle, return <code>null</code>.</p><p><strong>Note:</strong> Do not modify the linked list.</p><p><strong>Follow up</strong>:<br>Can you solve it without using extra space?</p><hr><h4 id="题意理解-1"><a href="#题意理解-1" class="headerlink" title="题意理解"></a>题意理解</h4><p>给定一个链表，如果链表中有环，返回环开始的节点；如果没有环，则返回 null。并且不能修改这个链表。</p><hr><h4 id="解法思路-1"><a href="#解法思路-1" class="headerlink" title="解法思路"></a>解法思路</h4><p>和上面那题一样，都是使用<strong>双指针法</strong>，但是要输出环开始的节点需要一些其他的计算。</p><p>假设经过 <strong>k</strong> 步，快慢指针相遇；假设<strong>环的长度</strong>是 <strong>r</strong>；所以有：<code>2k - k = nr</code>，即 <code>k = nr</code> （其中n表示快指针在环中循环的次数）。</p><p>假设<strong>链表表头</strong>到<strong>环的起点</strong>的距离为 s；假设<strong>环的起点</strong>到<strong>快慢指针相遇的节点</strong>的距离为 m；所以有：<code>s = k - m</code>。</p><p><code>s = nr - m = (n - 1) + (r - m)，n = 1,2,3,...</code></p><p>所以，可以再使用两个指针，慢指针从链表表头开始，每次移动一步；快指针从<strong>快慢指针相遇的节点</strong>开始，每次也移动一步，那么经过 s 步之后，快慢指针将会在<strong>环的起点</strong>相遇。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">NULL</span> &amp;&amp;fast-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (slow == fast)&#123;</span><br><span class="line">                slow = head;</span><br><span class="line">                fast = fast;</span><br><span class="line">                <span class="keyword">while</span> (slow != fast)&#123;</span><br><span class="line">                    slow = slow-&gt;next;</span><br><span class="line">                    fast = fast-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> slow;</span><br><span class="line">            &#125;           </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>复杂度和上一题一样，都为 O(N).</p></blockquote><hr>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>KVM 从虚拟机磁盘镜像创建虚拟机</title>
      <link href="/2018/10/19/%E4%BB%8E%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A3%81%E7%9B%98%E9%95%9C%E5%83%8F%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
      <url>/2018/10/19/%E4%BB%8E%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A3%81%E7%9B%98%E9%95%9C%E5%83%8F%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
      <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>作为教研室的网管，干了很多运维的工作，而一个高效的运维是必须少做重复性工作。教研室的网管做的最多的事就是在很多服务器上给很多同学分配很多虚拟机，由于同学们没法直接操作服务器，所以有时系统也是需要网管帮忙安装的，而安装系统的过程费时费力且没啥技术含量。所以最好的办法给各种系统保存一份模板镜像，如果同学需要一个虚拟机就给他复制一份，然后从镜像启动虚拟机，无需重复系统安装的过程，一人一个文件夹，方便管理。本文就将介绍如何在 KVM 环境下从磁盘镜像创建虚拟机。</p><a id="more"></a><hr><h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><p>这里假设保存的磁盘镜像格式为 qcow2 格式的，操作系统为 Linux ，并且后面的操作的磁盘名称为：ubuntu.qcow2。</p><h4 id="命令行实现："><a href="#命令行实现：" class="headerlink" title="命令行实现："></a>命令行实现：</h4><p>在命令行下，使用 virt-install 命令来安装虚拟机，这命令有很多选项，这里不详细介绍，可以通过 <code>man virt-install</code> 仔细查看。我们通常安装虚拟机都是通过系统 ISO 文件来安装系统，使用的命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">virt-install --virt-type kvm --name ubuntu --ram 4096 --vcpus=4 \</span><br><span class="line">    --cdrom=/home/kb310/test/ubuntu-16.04.4-desktop-amd64.iso \</span><br><span class="line">    --disk path=/home/kb310/test/ubuntu.qcow2,format=qcow2 \</span><br><span class="line">    --network network=br0,model=virtio \</span><br><span class="line">    --graphics vnc,listen=0.0.0.0, --noautoconsole \</span><br><span class="line">    --os-type=linux</span><br></pre></td></tr></table></figure><p>但是以上方法每次都是重新安装系统，太麻烦。</p><p><strong>下面介绍从虚拟机磁盘文件创建虚拟机的命令</strong>，但是这和 virt-instal 工具的版本有关系（可能和KVM的版本也有关系），不同版本的选项略微有差别，使用如下命令查看版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ virt-install --version</span><br><span class="line">1.3.2  或  0.600.4 （我只接触过这两个版本）</span><br><span class="line"></span><br><span class="line">$ kvm -version</span><br><span class="line">QEMU emulator version 2.5.0 (Debian 1:2.5+dfsg-5ubuntu10.30), Copyright (c) 2003-2008 Fabrice Bellard</span><br><span class="line">或</span><br><span class="line"># kvm -version</span><br><span class="line">QEMU emulator version 2.0.0 (Debian 2.0.0+dfsg-2ubuntu1.33), Copyright (c) 2003-2008 Fabrice Bellard</span><br></pre></td></tr></table></figure><p><strong>一种兼容前后版本的命令如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">virt-install --virt-type kvm --name ubuntu --ram 4096 --vcpus=4 \</span><br><span class="line">--import \</span><br><span class="line">--disk path=/home/kb310/test/ubuntu.qcow2,format=qcow2 \</span><br><span class="line">--network bridge=br0,model=virtio \</span><br><span class="line">--graphics vnc,listen=0.0.0.0 --noautoconsole \</span><br><span class="line">--os-type=linux</span><br></pre></td></tr></table></figure><p><strong>只适用于新版本的命令如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">virt-install --virt-type kvm --name docker-$1 --ram 4096 --vcpus=4 \</span><br><span class="line">--cdrom=/home/kb310/test/ubuntu.qcow2 \</span><br><span class="line">--disk path=/home/kb310/test/ubuntu.qcow2,format=qcow2 \</span><br><span class="line">--network bridge=br0,model=virtio \</span><br><span class="line">--graphics vnc,listen=0.0.0.0 --noautoconsole \</span><br><span class="line">--os-type=linux</span><br></pre></td></tr></table></figure><p>主要的区别就在于 –import 选项是兼容的，而使用 –cdrom 只适用于新版本。</p><hr><h4 id="图形界面实现："><a href="#图形界面实现：" class="headerlink" title="图形界面实现："></a>图形界面实现：</h4><p>对于图形界面就是通过 virt-manager 来实现，但是这种方法貌似只适用于较新版本KVM环境，步骤如下：</p><ol><li><p>打开 virtual machine mananger，-&gt; 点击右上角新建虚拟机</p><p><img src="https://github.com/cao0507/My-Pictures-Repository/blob/master/blog/kvm/virt-manager%201.png?raw=true" alt=""></p></li><li><p>选择 Import existing disk image，-&gt; Forward</p><p><img src="https://github.com/cao0507/My-Pictures-Repository/blob/master/blog/kvm/virt-manager%202.png?raw=true" alt=""></p></li><li><p>点击 Browse</p><p><img src="https://github.com/cao0507/My-Pictures-Repository/blob/master/blog/kvm/virt-manager%203.png?raw=true" alt=""></p></li><li><p>点击 Browse Local，找到虚拟机磁盘镜像文件，-&gt;Choose Volume</p><p><img src="https://github.com/cao0507/My-Pictures-Repository/blob/master/blog/kvm/virt-manager%204.png?raw=true" alt=""></p></li><li><p>点击 Forward</p><p><img src="https://github.com/cao0507/My-Pictures-Repository/blob/master/blog/kvm/virt-manager%205.png?raw=true" alt=""></p></li><li><p>配置合适的内存和 CPU 个数，-&gt; Forward</p><p><img src="https://github.com/cao0507/My-Pictures-Repository/blob/master/blog/kvm/virt-manager%206.png?raw=true" alt=""></p></li><li><p>给虚拟机命名（但注意这不是虚拟机里面的 hostname），-&gt; Finish</p><p><img src="https://github.com/cao0507/My-Pictures-Repository/blob/master/blog/kvm/virt-manager%207.png?raw=true" alt=""></p></li><li><p>最后就会进入虚拟机的系统启动过程</p></li></ol><hr><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>由于教研室有一些服务器的使用年限较长，有一些服务器的系统和软件版本较低，在使用 KVM 时碰到一些很烦人的问题，所以才写下这篇博客记录一下。如果在旧版本的环境下使用新环境才支持的命令选项，就可能会出现一些问题，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ virt-install --virt-type kvm --name docker-$1 --ram 4096 --vcpus=4 \</span><br><span class="line">--cdrom=/home/kb310/test/ubuntu.qcow2 \</span><br><span class="line">--disk path=/home/kb310/test/ubuntu.qcow2,format=qcow2 \</span><br><span class="line">--network bridge=br0,model=virtio \</span><br><span class="line">--graphics vnc,listen=0.0.0.0 --noautoconsole \</span><br><span class="line">--os-type=linux</span><br><span class="line"></span><br><span class="line">Starting install...</span><br><span class="line">ERROR    internal error: process exited while connecting to monitor: qemu-system-x86_64: -drive file=/home/kb310/test/ubuntu.qcow2,if=none,id=drive-ide0-0-0,format=qcow2: could not open disk image /home/kb310/test/ubuntu.qcow2: Could not open &apos;/home/kb310/test/ubuntu.qcow2&apos;: Permission denied</span><br><span class="line"></span><br><span class="line">Domain installation does not appear to have been successful.</span><br><span class="line">If it was, you can restart your domain by running:</span><br><span class="line">  virsh --connect qemu:///system start hgh</span><br><span class="line">otherwise, please restart your installation.</span><br></pre></td></tr></table></figure><p>上面出现的错误就是由于软件版本的不同导致的，所以最好使用兼容的命令选项。</p><hr>]]></content>
      
      <categories>
          
          <category> KVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KVM </tag>
            
            <tag> virt-install </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>110. Balanced Binary Tree</title>
      <link href="/2018/10/18/leetcode-110/"/>
      <url>/2018/10/18/leetcode-110/</url>
      <content type="html"><![CDATA[<h3 id="110-Balanced-Binary-Tree"><a href="#110-Balanced-Binary-Tree" class="headerlink" title="110. Balanced Binary Tree"></a>110. <a href="https://leetcode.com/problems/balanced-binary-tree/description/" target="_blank" rel="noopener">Balanced Binary Tree</a></h3><p>Given a binary tree, determine if it is height-balanced.</p><p>For this problem, a height-balanced binary tree is defined as:</p><blockquote><p>a binary tree in which the depth of the two subtrees of <em>every</em> node never differ by more than 1.</p></blockquote><a id="more"></a><p><strong>Example 1:</strong></p><p>Given the following tree <code>[3,9,20,null,null,15,7]</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>Return true.<br><strong>Example 2:</strong></p><p>Given the following tree <code>[1,2,2,3,3,null,null,4,4]</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      1</span><br><span class="line">     / \</span><br><span class="line">    2   2</span><br><span class="line">   / \</span><br><span class="line">  3   3</span><br><span class="line"> / \</span><br><span class="line">4   4</span><br></pre></td></tr></table></figure><p>Return false.</p><hr><h3 id="题意理解"><a href="#题意理解" class="headerlink" title="题意理解"></a>题意理解</h3><hr><p>给定一个二叉树（是任意二叉树，而不是二叉搜索树），判断其是否是高度平衡的。高度平衡二叉树的定义就是：</p><blockquote><p>对于二叉树的每一个节点，其左右子树的高度相差最大不超过 1 。</p></blockquote><p>根据上面的定义，简单地认为只需要根节点的左右子树的高度相差不超过 1 是错误的，必须保证每一个节点都满足该条件。</p><h3 id="解法思路"><a href="#解法思路" class="headerlink" title="解法思路"></a>解法思路</h3><hr><p><strong>初始思路：</strong></p><p>按照高度平衡二叉树的定义，可以想到通过遍历每一个节点，然后求每个节点的左右子树的高度，最后比较左右子树的高度差是否大于 1，当高度差大于时则返回 false，否则返回 true。实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + max(getHeight(root-&gt;left), getHeight(root-&gt;right));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> left = getHeight(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> right = getHeight(root-&gt;right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(left - right) &lt;= <span class="number">1</span> &amp;&amp; isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>复杂度分析：求个节点的高度调用 getHeight() 花费的时间复杂度是 O(N)，遍历所有节点又需要 O(N)，因此总的时间复杂度是 O(N^2)。</p></blockquote><p><strong>改进思路：</strong></p><p>对于上面的方法，是从根往下，在求每一个节点的高度时都会遍历其子节点，这些操作有很多时重复的。如果可以每个节点的高度都保存下来就好了。对于这个题目，节点的值是没有用的，因此可以用节点的值来存放其高度，这样就没有额外的空间消耗。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">storeHeight</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        storeHeight(root-&gt;left);</span><br><span class="line">        storeHeight(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left != <span class="literal">NULL</span> &amp;&amp; root-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">            root-&gt;val = <span class="number">1</span> + max(root-&gt;left-&gt;val, root-&gt;right-&gt;val);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">            root-&gt;val = <span class="number">1</span> + root-&gt;left-&gt;val;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">            root-&gt;val =<span class="number">1</span>+root-&gt;right-&gt;val;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            root-&gt;val = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> left = root-&gt;left == <span class="literal">NULL</span>? <span class="number">0</span> : root-&gt;left-&gt;val;</span><br><span class="line">        <span class="keyword">int</span> right = root-&gt;right == <span class="literal">NULL</span>? <span class="number">0</span> : root-&gt;right-&gt;val;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(left - right) &lt;= <span class="number">1</span> &amp;&amp; helper(root-&gt;left) &amp;&amp; helper(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        storeHeight(root);</span><br><span class="line">        <span class="keyword">return</span> helper(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>复杂度分析：算法首先求出二叉树各节点的高度，时间复杂度为 O(N)；然后再递归的计算每个节点左右子树的高度差是否小于等于 1，时间复杂度也为 O(N)。所以总的时间复杂度为 O(N) + O(N) = O(N)。</p></blockquote><p><strong>最终解法：</strong></p><p>在递归的计算二叉树中每个节点的高度时，如果两个子树的高度相差小于等于 1，则记录该节点真实的高度值，否则记录为 -1；并且在递归求某节点的高度时判断其左右孩子的高度值是否记录的是 -1，如果是，说明其左右子树中有非平衡树，则将该节点的高度值记为 -1。最后判断根节点的高度值是否为 -1，若为 -1，说明该二叉树不是高度平衡的；若不为 -1，说明该二叉树是高度平衡的。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfsHeight</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> left = dfsHeight(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> right = dfsHeight(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (right == <span class="number">-1</span>)    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(left - right) &gt; <span class="number">1</span>)  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + max(left, right);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dfsHeight(root) == <span class="number">-1</span>)  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>复杂度分析：只需要遍历一遍所有节点即可，时间复杂度为 O(N)。</p></blockquote><hr>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>107. Binary Tree Level Order Traversal II</title>
      <link href="/2018/10/17/leetcode-107/"/>
      <url>/2018/10/17/leetcode-107/</url>
      <content type="html"><![CDATA[<h3 id="107-Binary-Tree-Level-Order-Traversal-II"><a href="#107-Binary-Tree-Level-Order-Traversal-II" class="headerlink" title="107. Binary Tree Level Order Traversal II"></a>107. <a href="https://leetcode.com/problems/binary-tree-level-order-traversal-ii/description/" target="_blank" rel="noopener">Binary Tree Level Order Traversal II</a></h3><p>Given a binary tree, return the <em>bottom-up level order</em> traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root).</p><p>For example:<br>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>return its bottom-up level order traversal as:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [15,7],</span><br><span class="line">  [9,20],</span><br><span class="line">  [3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><hr><h3 id="题意理解"><a href="#题意理解" class="headerlink" title="题意理解"></a>题意理解</h3><p>给定一个二叉树，要求自底向上，自左向右的按层输出二叉树各节点的值。输出保存在一个二维数组中，也就是一个数组的数组，外层数组的元素是二叉树每一层节点的值的集合。</p><hr><h3 id="解法思路"><a href="#解法思路" class="headerlink" title="解法思路"></a>解法思路</h3><h5 id="解法一：DFS（Depth-First-Search）"><a href="#解法一：DFS（Depth-First-Search）" class="headerlink" title="解法一：DFS（Depth-First-Search）"></a>解法一：DFS（Depth-First-Search）</h5><p>可以知道的是，输出的二维数组中用一个数组来保存二叉树中的每一层的节点的值，且该内层数组在外层数组中的下标索引刚好与这些节点在树中的高度相反。所以可以利用 DFS 来遍历二叉树，根据节点在树中的高度，找到数组中保存该层元素的内层数组，将节点的值插入，最后只需将整个数组反转即可。对于二叉树的深度优先搜索，可以考虑用递归或者栈来实现。</p><p><strong>DFS with recursive：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrderBottom(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        levelRecursive(res, root, <span class="number">0</span>);</span><br><span class="line">        reverse(res.begin(), res.end());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">levelRecursive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;res, TreeNode* root, <span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span> (res.size() &lt; level+<span class="number">1</span>)&#123;  <span class="comment">//判断是否已经有内层数组来存放该层节点的值</span></span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">            res.push_back(vec);</span><br><span class="line">        &#125;</span><br><span class="line">        res[level].push_back(root-&gt;val);</span><br><span class="line">        levelRecursive(res, root-&gt;left, level+<span class="number">1</span>);</span><br><span class="line">        levelRecursive(res, root-&gt;right, level+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>DFS with stack：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrderBottom(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;TreeNode*, <span class="keyword">int</span>&gt;&gt; <span class="built_in">stack</span>;  <span class="comment">//用一个pair来存放节点和节点在书中的深度</span></span><br><span class="line">        <span class="built_in">stack</span>.push_back(&#123;root, <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">stack</span>.empty())&#123;</span><br><span class="line">            pair&lt;TreeNode*, <span class="keyword">int</span>&gt; p = <span class="built_in">stack</span>.back();</span><br><span class="line">            <span class="built_in">stack</span>.pop_back();</span><br><span class="line">            <span class="keyword">if</span> (res.size() &lt; p.second + <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">                res.push_back(vec);</span><br><span class="line">            &#125;</span><br><span class="line">            res[p.second].push_back(p.first-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (p.first-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">                <span class="built_in">stack</span>.push_back(&#123;p.first-&gt;right, p.second+<span class="number">1</span>&#125;);</span><br><span class="line">            <span class="keyword">if</span> (p.first-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">                <span class="built_in">stack</span>.push_back(&#123;p.first-&gt;left, p.second+<span class="number">1</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(res.begin(), res.end());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="解法二：BFS（Breadth-First-Search）"><a href="#解法二：BFS（Breadth-First-Search）" class="headerlink" title="解法二：BFS（Breadth-First-Search）"></a>解法二：BFS（Breadth-First-Search）</h5><p>使用队列来存放每一层的节点，在 while 循环中又有一个 for 循环来遍历每一层的元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrderBottom(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode* &gt; q;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; level;</span><br><span class="line">            <span class="keyword">int</span> len = q.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)&#123;</span><br><span class="line">                level.push_back(q.front()-&gt;val);</span><br><span class="line">                TreeNode* p = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">                    q.push(p-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">                    q.push(p-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(level);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        reverse(res.begin(), res.end());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度：</strong>以上解法的时间复杂度及空间复杂度都为 O(N)。</p><hr>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>远程访问 Docker Daemon</title>
      <link href="/2018/10/13/%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AEDocker/"/>
      <url>/2018/10/13/%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AEDocker/</url>
      <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>最近的项目中涉及到监控远程主机上的 Docker 容器的运行状况，即通过本地 docker 客户端访问远程主机的 docker 服务端，以此来监控远程主机上的 Docker 容器。但是 Docker Daemon 默认情况下是只允许本地访问的，不允许远程访问。本文将首先介绍 Docker Daemon 的连接方式，然后说明如何配置远程访问。</p><a id="more"></a><hr><h2 id="Docker-Daemon-的连接方式"><a href="#Docker-Daemon-的连接方式" class="headerlink" title="Docker Daemon 的连接方式"></a>Docker Daemon 的连接方式</h2><ol><li><p><strong>UNIX 域套接字</strong></p><p>默认就是这种方式, 会生成一个 <code>/var/run/docker.sock</code> 文件, <code>UNIX</code> 域套接字用于本地进程之间的通讯, 这种方式相比于网络套接字效率更高, 但局限性就是只能被本地的客户端访问。 </p></li><li><p><strong>tcp 端口监听</strong></p><p>服务端开启端口监听 <code>dockerd -H IP:PORT</code> , 客户端通过指定IP和端口访问服务端 <code>docker -H IP:PORT</code> 。通过这种方式, 任何人只要知道了你暴露的ip和端口就能随意访问你的docker服务了, 这是一件很危险的事, 因为docker的权限很高, 不法分子可以从这突破取得服务端宿主机的最高权限。 </p></li></ol><hr><h2 id="配置-Docker-远程访问"><a href="#配置-Docker-远程访问" class="headerlink" title="配置 Docker 远程访问"></a>配置 Docker 远程访问</h2><p>看到一些资料上面说可以通过修改 <code>/etc/default/docker</code> 文件来修改 Docker Daemon 的配置，也就是编辑docker的配置文件 <code>/etc/default/docker</code> 中的 <code>DOCKER_OPTS</code> 选项成同时监听本地 unix socket 和远程 http socket（2375）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DOCKER_OPTS=&quot;-H unix:///var/run/docker.sock -H tcp://0.0.0.0:2375&quot;</span><br></pre></td></tr></table></figure><p>但是通过这种方法修改完成重新启动 docker 守护进程之后，Docker Daemon 并没有在监听 2375 端口。然后发现其实在 <code>/etc/default/docker</code> 文件也有说到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># THIS FILE DOES NOT APPLY TO SYSTEMD</span><br><span class="line">#</span><br><span class="line">#   Please see the documentation for &quot;systemd drop-ins&quot;:</span><br><span class="line">#   https://docs.docker.com/engine/admin/systemd/</span><br></pre></td></tr></table></figure><p>因为 Ubuntu 16.04 使用 systemd 来管理 docker 进程，<code>/etc/default/docker</code> 文件已经不再起作用了，该文件只对更老的系统起作用。正确的配置方式如下：</p><hr><p>主要参考该链接：<a href="https://wiki.ssdt-ohio.org/display/rtd/Install+Docker+and+Docker+tools+on+Ubuntu#InstallDockerandDockertoolsonUbuntu-Changestodefaultoptions" target="_blank" rel="noopener">Adjustments to docker setting</a></p><h4 id="1-Changes-to-default-options"><a href="#1-Changes-to-default-options" class="headerlink" title="1. Changes to default options"></a>1. Changes to default options</h4><p>安装好 Docker 后可能有一些选项需要修改，就像我们这里想要配置 Docker Daemon 允许远程访问一样。有两种方法：</p><ul><li>修改 <code>/etc/default/docker</code> 和 <code>/lib/systemd/system/docker.service</code> 文件，但是这种方法对不同版本的 Docker 有不同的配置方法，不推荐。</li><li>创建 <code>/etc/docker/daemon.json</code> 来作为配置文件，Docker 推荐使用这种方法，这也是我们接下来介绍的。</li></ul><blockquote><p>注：这里使用的是 Ubuntu 16.04 LTS 系统，使用了 systemd 来管理 docker 进程。而更老版本的 Ubuntu 系统没有使用 systemd，所以只需要修改 <code>/etc/default/docker</code> 文件就够了。</p></blockquote><p>开始之前，先关闭 docker 进程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo service docker stop</span><br></pre></td></tr></table></figure><blockquote><p>注意：在上面的原文链接的方法中，还会修改 docker 的默认目录，也就是将 <code>/var/lib/docker</code> 修改成了 <code>/data/docker</code> ，修改之后我们原来的容器镜像都会找不到的，所以我们就不修改默认目录，还是使用原来的  <code>/var/lib/docker</code>。可以使用以下命令查看 docker 默认目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; $ docker info | grep &quot;Docker Root Dir&quot;</span><br><span class="line">&gt; Docker Root Dir: /var/lib/docker</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h4 id="2-Create-modify-files"><a href="#2-Create-modify-files" class="headerlink" title="2. Create/modify files"></a>2. Create/modify files</h4><p>创建 <code>/etc/docker/daemon.json</code> 文件（如果已经存在则修改），加入以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;hosts&quot; : [&quot;unix:///var/run/docker.sock&quot;, &quot;tcp://0.0.0.0:2375&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>&quot;unix:///var/run/docker.sock&quot;</code>：unix socket，本地客户端将通过这个来连接 Docker Daemon。</li><li><code>&quot;tcp://0.0.0.0:2375&quot;</code>：tcp socket，表示允许任何远程客户端通过 2375 端口连接 Docker Daemon。</li></ul><blockquote><p>注意：这里也和原文链接有点不同。</p></blockquote><h4 id="3-Servers-using-systemd"><a href="#3-Servers-using-systemd" class="headerlink" title="3. Servers using systemd:"></a>3. Servers using systemd:</h4><p>可以使用 <code>systemctl edit docker</code> 来调用文本编辑器修改指定的单元或单元实例，ubuntu 默认调用的是 nano 编辑器，不是很好用，如果不熟悉 nano 编辑器的操作可以使用 vim 编辑器。</p><p>主要也就是新建或修改 <code>/etc/systemd/system/docker.service.d/override.conf</code>，其内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">##Add this to the file for the docker daemon to use different ExecStart parameters (more things can be added here)</span><br><span class="line">[Service]</span><br><span class="line">ExecStart=</span><br><span class="line">ExecStart=/usr/bin/dockerd</span><br></pre></td></tr></table></figure><p>解释一下：</p><blockquote><p>默认情况下使用 systemd 时，docker.service 的设置为：<code>ExecStart=/usr/bin/dockerd -H fd://</code>，这将覆盖写到 <u>daemon.json</u> 中的任何 hosts 。通过在 <u>override.conf</u>  文件中将 ExecStart 仅仅定义为：<code>ExecStart=/usr/bin/dockerd</code>，这将会使用在 <u>daemon.json</u> 中设置的 hosts 。这个文件中的第一行<code>ExecStart=</code> 必须要有，因为它将用于清楚默认的 ExecStart 参数。如果是修改 docker.service 的文件而不是创建 <u>override.conf</u>，那么下次 systemd 重启时，docker.service 文件也会被重新创建。</p></blockquote><p>重新加载 daemon 并重启 docker 服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl daemon-reload</span><br><span class="line">$ sudo systemctl restart docker.service</span><br></pre></td></tr></table></figure><p>检查端口监听：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># netstat -ntlp |grep dockerd</span><br><span class="line">tcp6       0      0 :::2375             :::*         LISTEN      6259/dockerd</span><br></pre></td></tr></table></figure><blockquote><p>如果检查端口监听时出现下面的提示，则说明需要使用 root 权限。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; (Not all processes could be identified, non-owned process info</span><br><span class="line">&gt;  will not be shown, you would have to be root to see it all.)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>在远程主机上面通过 tcp socket 来访问本机的 Docker Daemon 服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker -H 192.168.1.130:2375 images</span><br><span class="line"></span><br><span class="line">$ docker -H 192.168.1.130:2375 ps</span><br></pre></td></tr></table></figure><blockquote><p>其中 192.168.1.130 是开放了远程访问的主机的 IP。</p><p>另外需要注意的是这种操作是不太安全的，仅用于测试使用。</p></blockquote><hr>]]></content>
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hyperledger caliper 安装记录</title>
      <link href="/2018/10/10/caliper%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/"/>
      <url>/2018/10/10/caliper%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/</url>
      <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Caliper 是一个区块链性能测试框架，可用于测试不同的区块链实现，由华为公司开发并贡献给 Hyperledger。本文介绍如何在 ubuntu 系统下安装 caliper 并完成简单测试，最后会说明安装过程中的错误解决。</p><a id="more"></a><h2 id="Pre-requisites"><a href="#Pre-requisites" class="headerlink" title="Pre-requisites"></a>Pre-requisites</h2><p>需要安装的基础环境如下：</p><ul><li>make，g++</li><li>NodeJS 8.X</li><li>node-gyp</li><li>Docker</li><li>Docker-compose</li></ul><h3 id="1-安装-make，g-编译工具"><a href="#1-安装-make，g-编译工具" class="headerlink" title="1. 安装 make，g++ 编译工具"></a>1. 安装 make，g++ 编译工具</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install make g++</span><br></pre></td></tr></table></figure><h3 id="2-安装node-js"><a href="#2-安装node-js" class="headerlink" title="2. 安装node.js"></a>2. 安装node.js</h3><p>ubuntu 支持 nodesouce 的二进制安装脚本，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -sL https://deb.nodesource.com/setup_8.x | sudo -E bash -</span><br><span class="line">sudo apt-get install -y nodejs</span><br></pre></td></tr></table></figure><p>安装完成后查看 node 与 npm 的版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ node -v</span><br><span class="line">v8.12.0</span><br><span class="line">$ npm -v</span><br><span class="line">6.4.1</span><br></pre></td></tr></table></figure><h3 id="3-安装-node-gyp"><a href="#3-安装-node-gyp" class="headerlink" title="3. 安装 node-gyp"></a>3. 安装 node-gyp</h3><p>npm 全局安装 node-gyp：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install -g node-gyp</span><br></pre></td></tr></table></figure><h3 id="4-安装-Docker"><a href="#4-安装-Docker" class="headerlink" title="4. 安装 Docker"></a>4. 安装 Docker</h3><ul><li><p>由于 apt 源使用HTTPS以确保软件下载过程中不被篡改。因此，我们首先需要添加使用HTTPS传输的软件包以及CA证书。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    software-properties-common</span><br></pre></td></tr></table></figure></li><li><p>为了确认所下载软件包的合法性，需要添加软件源的 GPG 秘钥</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure></li><li><p>然后，我们需要向 sources.list 中添加 Docker 软件源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo add-apt-repository \</span><br><span class="line">    &quot;deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu \</span><br><span class="line">    $(lsb_release -cs) \</span><br><span class="line">    stable&quot;</span><br></pre></td></tr></table></figure><blockquote><p>以上命令会添加稳定版本的Docker CE apt 镜像源。</p></blockquote></li><li><p>更新 apt 软件包缓存，并安装 docker-ce：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line"></span><br><span class="line">$ sudo apt-get install docker-ce</span><br></pre></td></tr></table></figure></li><li><p>查看 Docker 版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker -v</span><br><span class="line">Docker version 18.06.0-ce, build 0ffa825</span><br></pre></td></tr></table></figure></li><li><p>启动 Docker CE</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl enable docker</span><br><span class="line">$ sudo systemctl start docker</span><br></pre></td></tr></table></figure></li><li><p>建立 docker 用户组</p><p>默认情况下，<code>docker</code> 命令会使用 <a href="https://en.wikipedia.org/wiki/Unix_domain_socket" target="_blank" rel="noopener">Unix socket</a> 与 Docker 引擎通讯。而只有 <code>root</code> 用户和 <code>docker</code> 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 <code>root</code> 用户。因此，更好地做法是将需要使用 <code>docker</code> 的用户加入 <code>docker</code> 用户组。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo groupadd docker</span><br></pre></td></tr></table></figure><blockquote><p>其实一般按照上面的方法安装 Docker 后就已经创建好 docker 用户组了，可以使用 <code>$ cat /etc/group | grep docker</code> 命令来验证，所以就不需要再建立 docker 用户组了，再建立也会报错提示用户组已存在的。</p></blockquote></li><li><p>将当前用户加入 docker 用户组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo usermod -aG docker $USER</span><br></pre></td></tr></table></figure><blockquote><p>下次登录时即可方便的使用 docker 命令。</p></blockquote></li><li><p>测试 Docker 是否安装正确</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$ docker run hello-world</span><br><span class="line">Unable to find image &apos;hello-world:latest&apos; locally</span><br><span class="line">latest: Pulling from library/hello-world</span><br><span class="line">9db2ca6ccae0: Pull complete </span><br><span class="line">Digest: sha256:4b8ff392a12ed9ea17784bd3c9a8b1fa3299cac44aca35a85c90c5e3c7afacdc</span><br><span class="line">Status: Downloaded newer image for hello-world:latest</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">To generate this message, Docker took the following steps:</span><br><span class="line"> 1. The Docker client contacted the Docker daemon.</span><br><span class="line"> 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.</span><br><span class="line">    (amd64)</span><br><span class="line"> 3. The Docker daemon created a new container from that image which runs the</span><br><span class="line">    executable that produces the output you are currently reading.</span><br><span class="line"> 4. The Docker daemon streamed that output to the Docker client, which sent it</span><br><span class="line">    to your terminal.</span><br><span class="line"></span><br><span class="line">To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line"> $ docker run -it ubuntu bash</span><br><span class="line"></span><br><span class="line">Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line"> https://hub.docker.com/</span><br><span class="line"></span><br><span class="line">For more examples and ideas, visit:</span><br><span class="line"> https://docs.docker.com/engine/userguide/</span><br></pre></td></tr></table></figure></li><li><p>配置镜像加速器</p><p>国内从 Docker Hub 拉取镜像有时会遇到困难，此时可以配置镜像加速器。Docker 官方和国内很多云服务商都提供了国内加速器服务，例如： </p><ul><li><a href="https://docs.docker.com/registry/recipes/mirror/#use-case-the-china-registry-mirror" target="_blank" rel="noopener">Docker 官方提供的中国 registry mirror <code>https://registry.docker-cn.com</code></a> </li><li><a href="https://kirk-enterprise.github.io/hub-docs/#/user-guide/mirror" target="_blank" rel="noopener">七牛云加速器 <code>https://reg-mirror.qiniu.com/</code></a> </li></ul><blockquote><p>当配置某一个加速器地址之后，若发现拉取不到镜像，请切换到另一个加速器地址。</p><p>国内各大云服务商均提供了 Docker 镜像加速服务，建议根据运行 Docker 的云平台选择对应的镜像加速服务。</p></blockquote><p>我们以 Docker 官方加速器 <code>https://registry.docker-cn.com</code> 为例进行介绍。 </p><p>在 <code>/etc/docker/daemon.json</code> 中写入如下内容（如果文件不存在则创建）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [</span><br><span class="line">    &quot;https://registry.docker-cn.com&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后重新启动服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl daemon-reload</span><br><span class="line">$ sudo systemctl restart docker</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-安装-Docker-compose"><a href="#5-安装-Docker-compose" class="headerlink" title="5. 安装 Docker-compose"></a>5. 安装 Docker-compose</h3><ul><li><p>通过二进制包来安装，从 <a href="https://github.com/docker/compose/releases" target="_blank" rel="noopener">官方 GitHub Release</a> 处直接下载编译好的二进制文件即可。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo curl -L https://github.com/docker/compose/releases/download/1.22.0/docker-compose-$(uname -s)-$(uname -m) -o /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line">$ sudo chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure></li><li><p>查看 Docker compose 版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose --version</span><br><span class="line">docker-compose version 1.22.0, build f46880fe</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="Clone-caliper-repository"><a href="#Clone-caliper-repository" class="headerlink" title="Clone caliper repository"></a>Clone caliper repository</h2><p>从 GitHub 克隆 caliper 代码仓库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/hyperledger/caliper.git</span><br></pre></td></tr></table></figure><p>进入 caliper 目录并运行 <code>npm install</code> 安装依赖包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd caliper/</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><hr><h2 id="Install-fabric-SDKs"><a href="#Install-fabric-SDKs" class="headerlink" title="Install fabric SDKs"></a>Install fabric SDKs</h2><p>在 caliper 目录下本地安装 fabric SDKs：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install grpc@1.10.1 fabric-ca-client fabric-client</span><br></pre></td></tr></table></figure><p>以上命令默认安装 fabric 最新版本的 SDKs，但是由于 caliper 验证过的最新版本是 v1.1.0，所以我们最好安装 v1.1.0 版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install fabric-ca-client@1.1.0 fabric-client@1.1.0</span><br></pre></td></tr></table></figure><hr><h2 id="Run-benchmark"><a href="#Run-benchmark" class="headerlink" title="Run benchmark"></a>Run benchmark</h2><p>性能测试示例在<code>benchmark</code>目录下，用法如下： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node benchmark/simple/main.js -c yourconfig.json -n yournetwork.json</span><br></pre></td></tr></table></figure><ul><li>-c 用于指定区块链的配置文件，不指定的话默认为<code>config.json</code>；</li><li>-n 用于指定区块链网络配置文件，不指定的话由-c指定的配置文件定义。</li></ul><p>运行一个 simple 的实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node benchmark/simple/main.js</span><br></pre></td></tr></table></figure><p>生成的报告如下：</p><p><img src="https://github.com/cao0507/My-Pictures-Repository/blob/master/Blockchain/caliper/simple-report-html.png?raw=true" alt=""></p><hr><h2 id="Bugs"><a href="#Bugs" class="headerlink" title="Bugs"></a>Bugs</h2><h3 id="运行测试遇到-REQUEST-TIMEOUT-的问题："><a href="#运行测试遇到-REQUEST-TIMEOUT-的问题：" class="headerlink" title="运行测试遇到 REQUEST_TIMEOUT 的问题："></a>运行测试遇到 <code>REQUEST_TIMEOUT</code> 的问题：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">$ node benchmark/simple/main.js </span><br><span class="line">TAP version 13</span><br><span class="line"># #######Caliper Test######</span><br><span class="line">docker-compose -f network/fabric/simplenetwork/docker-compose.yaml up -d</span><br><span class="line">Creating network &quot;simplenetwork_default&quot; with the default driver</span><br><span class="line">Creating ca_peerOrg1          ... done</span><br><span class="line">Creating simplenetwork_peer_1   ... done</span><br><span class="line">Creating orderer.example.com  ... done</span><br><span class="line">Creating ca_peerOrg2            ... done</span><br><span class="line">Creating simplenetwork_ca_1     ... done</span><br><span class="line">Creating peer1.org2.example.com ... done</span><br><span class="line">Creating peer0.org1.example.com ... done</span><br><span class="line">Creating peer1.org1.example.com ... done</span><br><span class="line">Creating peer0.org2.example.com ... done</span><br><span class="line"># create mychannel......</span><br><span class="line">ok 1 created mychannel successfully</span><br><span class="line"># Sleep 5s......</span><br><span class="line"># Join channel......</span><br><span class="line"># join mychannel</span><br><span class="line">ok 2 Successfully joined mychannel</span><br><span class="line"># install all chaincodes......</span><br><span class="line">info: [packager/Golang.js]: packaging GOLANG from contract/fabric/simple/go</span><br><span class="line">info: [packager/Golang.js]: packaging GOLANG from contract/fabric/simple/go</span><br><span class="line">ok 3 Installed chaincode simple successfully in all peers</span><br><span class="line"># Instantiate chaincode......</span><br><span class="line">error: [Peer.js]: sendProposal - timed out after:120000</span><br><span class="line">error: [Peer.js]: sendProposal - timed out after:120000</span><br><span class="line">error: [Peer.js]: sendProposal - timed out after:120000</span><br><span class="line">error: [Peer.js]: sendProposal - timed out after:120000</span><br><span class="line">error: [client-utils.js]: sendPeersProposal - Promise is rejected: Error: REQUEST_TIMEOUT</span><br><span class="line">    at Timeout._onTimeout (/home/user1/go/src/github.com/hyperledger/caliper/node_modules/fabric-client/lib/Peer.js:124:19)</span><br><span class="line">    at ontimeout (timers.js:498:11)</span><br><span class="line">    at tryOnTimeout (timers.js:323:5)</span><br><span class="line">    at Timer.listOnTimeout (timers.js:290:5)</span><br><span class="line">error: [client-utils.js]: sendPeersProposal - Promise is rejected: Error: REQUEST_TIMEOUT</span><br><span class="line">    at Timeout._onTimeout (/home/user1/go/src/github.com/hyperledger/caliper/node_modules/fabric-client/lib/Peer.js:124:19)</span><br><span class="line">    at ontimeout (timers.js:498:11)</span><br><span class="line">    at tryOnTimeout (timers.js:323:5)</span><br><span class="line">    at Timer.listOnTimeout (timers.js:290:5)</span><br><span class="line">error: [client-utils.js]: sendPeersProposal - Promise is rejected: Error: REQUEST_TIMEOUT</span><br><span class="line">    at Timeout._onTimeout (/home/user1/go/src/github.com/hyperledger/caliper/node_modules/fabric-client/lib/Peer.js:124:19)</span><br><span class="line">    at ontimeout (timers.js:498:11)</span><br><span class="line">    at tryOnTimeout (timers.js:323:5)</span><br><span class="line">    at Timer.listOnTimeout (timers.js:290:5)</span><br><span class="line">error: [client-utils.js]: sendPeersProposal - Promise is rejected: Error: REQUEST_TIMEOUT</span><br><span class="line">    at Timeout._onTimeout (/home/user1/go/src/github.com/hyperledger/caliper/node_modules/fabric-client/lib/Peer.js:124:19)</span><br><span class="line">    at ontimeout (timers.js:498:11)</span><br><span class="line">    at tryOnTimeout (timers.js:323:5)</span><br><span class="line">    at Timer.listOnTimeout (timers.js:290:5)</span><br><span class="line">not ok 4 Failed to instantiate chaincodes, Error: Failed to send instantiate due to error: Error: Failed to send instantiate Proposal or receive valid response. Response null or status is not 200. exiting... at Client.newDefaultKeyValueStore.then.then.then.then (/home/user1/go/src/github.com/hyperledger/caliper/src/fabric/e2eUtils.js:372:19) at &lt;anonymous&gt; at process._tickCallback (internal/process/next_tick.js:189:7) at Client.newDefaultKeyValueStore.then.then.then.then.then (/home/user1/go/src/github.com/hyperledger/caliper/src/fabric/e2eUtils.js:385:15) at &lt;anonymous&gt; at process._tickCallback (internal/process/next_tick.js:189:7)</span><br><span class="line">  ---</span><br><span class="line">    operator: fail</span><br><span class="line">    at: chaincodes.reduce.then.catch (/home/user1/go/src/github.com/hyperledger/caliper/src/fabric/instantiate-chaincode.js:60:19)</span><br><span class="line">    stack: |-</span><br><span class="line">      Error: Failed to instantiate chaincodes, Error: Failed to send instantiate due to error: Error: Failed to send instantiate Proposal or receive valid response. Response null or status is not 200. exiting...</span><br><span class="line">          at Client.newDefaultKeyValueStore.then.then.then.then (/home/user1/go/src/github.com/hyperledger/caliper/src/fabric/e2eUtils.js:372:19)</span><br><span class="line">          at &lt;anonymous&gt;</span><br><span class="line">          at process._tickCallback (internal/process/next_tick.js:189:7)</span><br><span class="line">          at Client.newDefaultKeyValueStore.then.then.then.then.then (/home/user1/go/src/github.com/hyperledger/caliper/src/fabric/e2eUtils.js:385:15)</span><br><span class="line">          at &lt;anonymous&gt;</span><br><span class="line">          at process._tickCallback (internal/process/next_tick.js:189:7)</span><br><span class="line">          at Test.assert [as _assert] (/home/user1/go/src/github.com/hyperledger/caliper/node_modules/tape/lib/test.js:224:54)</span><br><span class="line">          at Test.bound [as _assert] (/home/user1/go/src/github.com/hyperledger/caliper/node_modules/tape/lib/test.js:76:32)</span><br><span class="line">          at Test.fail (/home/user1/go/src/github.com/hyperledger/caliper/node_modules/tape/lib/test.js:317:10)</span><br><span class="line">          at Test.bound [as fail] (/home/user1/go/src/github.com/hyperledger/caliper/node_modules/tape/lib/test.js:76:32)</span><br><span class="line">          at chaincodes.reduce.then.catch (/home/user1/go/src/github.com/hyperledger/caliper/src/fabric/instantiate-chaincode.js:60:19)</span><br><span class="line">          at &lt;anonymous&gt;</span><br><span class="line">          at process._tickCallback (internal/process/next_tick.js:189:7)</span><br><span class="line">  ...</span><br><span class="line">fabric.installSmartContract() failed, Error: Fabric: instantiate chaincodes failed</span><br><span class="line">    at chaincodes.reduce.then.catch (/home/user1/go/src/github.com/hyperledger/caliper/src/fabric/instantiate-chaincode.js:61:31)</span><br><span class="line">    at &lt;anonymous&gt;</span><br><span class="line">    at process._tickCallback (internal/process/next_tick.js:189:7)</span><br><span class="line">[Transaction Info] - Submitted: 0 Succ: 0 Fail:0 Unfinished:0</span><br><span class="line">unexpected error, Error: Fabric: instantiate chaincodes failed</span><br><span class="line">    at chaincodes.reduce.then.catch (/home/user1/go/src/github.com/hyperledger/caliper/src/fabric/instantiate-chaincode.js:61:31)</span><br><span class="line">    at &lt;anonymous&gt;</span><br><span class="line">    at process._tickCallback (internal/process/next_tick.js:189:7)</span><br><span class="line">docker-compose -f network/fabric/simplenetwork/docker-compose.yaml down;docker rm $(docker ps -aq);docker rmi $(docker images dev* -q)</span><br><span class="line">Stopping peer0.org1.example.com ... done</span><br><span class="line">Stopping peer0.org2.example.com ... done</span><br><span class="line">Stopping peer1.org1.example.com ... done</span><br><span class="line">Stopping peer1.org2.example.com ... done</span><br><span class="line">Stopping simplenetwork_ca_1     ... done</span><br><span class="line">Stopping ca_peerOrg2            ... done</span><br><span class="line">Stopping orderer.example.com    ... done</span><br><span class="line">Stopping ca_peerOrg1            ... done</span><br><span class="line">Removing peer0.org1.example.com ... done</span><br><span class="line">Removing peer0.org2.example.com ... done</span><br><span class="line">Removing peer1.org1.example.com ... done</span><br><span class="line">Removing peer1.org2.example.com ... done</span><br><span class="line">Removing simplenetwork_ca_1     ... done</span><br><span class="line">Removing ca_peerOrg2            ... done</span><br><span class="line">Removing simplenetwork_peer_1   ... done</span><br><span class="line">Removing orderer.example.com    ... done</span><br><span class="line">Removing ca_peerOrg1            ... done</span><br><span class="line">Removing network simplenetwork_default</span><br><span class="line">&quot;docker rm&quot; requires at least 1 argument.</span><br><span class="line">See &apos;docker rm --help&apos;.</span><br><span class="line"></span><br><span class="line">Usage:  docker rm [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class="line"></span><br><span class="line">Remove one or more containers</span><br><span class="line">&quot;docker rmi&quot; requires at least 1 argument.</span><br><span class="line">See &apos;docker rmi --help&apos;.</span><br><span class="line"></span><br><span class="line">Usage:  docker rmi [OPTIONS] IMAGE [IMAGE...]</span><br><span class="line"></span><br><span class="line">Remove one or more images</span><br><span class="line"></span><br><span class="line">1..4</span><br><span class="line"># tests 4</span><br><span class="line"># pass  3</span><br><span class="line"># fail  1</span><br></pre></td></tr></table></figure><p>问题解决：</p><ol><li><p>首先需要检查环境依赖是否正确安装，尤其是 node-gyp 包。</p></li><li><p>然后查看 npm 包版本信息及 docker 镜像信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ npm ls fabric-client</span><br><span class="line">caliper@0.1.0 /home/user1/go/src/github.com/hyperledger/caliper</span><br><span class="line">└── fabric-client@1.1.0</span><br><span class="line"></span><br><span class="line">$ npm ls fabric-ca-client</span><br><span class="line">caliper@0.1.0 /home/user1/go/src/github.com/hyperledger/caliper</span><br><span class="line">└── fabric-ca-client@1.1.0</span><br><span class="line"></span><br><span class="line">$ npm ls grpc</span><br><span class="line">caliper@0.1.0 /home/user1/go/src/github.com/hyperledger/caliper</span><br><span class="line">├─┬ fabric-client@1.1.0</span><br><span class="line">│ └── grpc@1.10.1  deduped</span><br><span class="line">└── grpc@1.10.1</span><br></pre></td></tr></table></figure><p>需确认无误。因为 caliper 在创建 fabric 网络时默认是使用的 fabric v1.1.0 版本，docker 下载的 peer、Orderer、ca 镜像也是 x86_64-v1.1.0 版本，所以 fabric SDKs 的 版本必须一致。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls</span><br><span class="line">REPOSITORY                   TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">hyperledger/fabric-ca        x86_64-1.1.0        72617b4fa9b4        6 months ago        299MB</span><br><span class="line">hyperledger/fabric-orderer   x86_64-1.1.0        ce0c810df36a        6 months ago        180MB</span><br><span class="line">hyperledger/fabric-peer      x86_64-1.1.0        b023f9be0771        6 months ago        187MB</span><br></pre></td></tr></table></figure></li><li><p>修改请求超时时间</p><p>在一台虚拟机里面安装的测试环境，搭建的 fabric 网络将会运行有7个 nodes/containers（1 orderer，2 CAs，4 peers），可能由于虚拟机性能的原因，原本 2 分钟的请求超时时间可能不足以 instantiate chaincode（需要构建一个 docker 镜像，并在每个 peer 中运行 chaincode Init 函数）。所以应该尝试增加 timeout 的值。修改 src/fabric/e2eUtils.js 第211行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Client.setConfigSetting(&apos;request-timeout&apos;, 120000);</span><br></pre></td></tr></table></figure><p>将 120000 增加到 480000。</p><blockquote><p>参考链接：</p><p><a href="https://github.com/hyperledger/caliper/issues/118" target="_blank" rel="noopener">Instantiate chaincode…… #118</a></p><p><a href="https://github.com/hyperledger/caliper/issues/137" target="_blank" rel="noopener">instantiate chaincodes Error #137</a></p></blockquote></li></ol><hr>]]></content>
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hyperledger fabric </tag>
            
            <tag> Hyperledger caliper </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>阿里云服务器实现 frp 内网穿透</title>
      <link href="/2018/09/18/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9E%E7%8E%B0frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
      <url>/2018/09/18/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9E%E7%8E%B0frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前几天在一台具有公网IP的 vultr 云服务器上实现了 frp 内网穿透<a href="https://cao0507.github.io/2018/09/14/frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%AE%9E%E7%8E%B0ssh%E8%AE%BF%E9%97%AE%E5%86%85%E7%BD%91%E6%9C%BA%E5%99%A8/">（参考链接）</a>，可以从寝室 ssh 登录到教研室的服务器，但是由于 vultr 的云服务器位于国外的节点，连接速度太慢了，导致连接 ssh 登录的体验很差。今天又弄了一台阿里云的云服务器 ECS，所以现在来介绍如何在阿里云上实现 frp 内网穿透。</p><a id="more"></a><h2 id="配置-ssh-访问内网机器"><a href="#配置-ssh-访问内网机器" class="headerlink" title="配置 ssh 访问内网机器"></a>配置 ssh 访问内网机器</h2><p>之前使用的 vultr 的VPS是 CentOS 系统的，这次阿里云服务器是 Ubuntu 的操作系统，但其实不同操作系统的云服务器在使用 frp 时操作都是一样的，就是<strong>下载</strong>，<strong>配置</strong>，<strong>运行</strong>。可能有区别的地方就是防火墙相关的配置，不同云服务厂商的镜像不同可能也有一些差别。下面来说明在阿里云的公网服务器的 frp 实现步骤：</p><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p>在阿里云的公网服务器和内网机器上都要下载安装包并解压：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ wget https://github.com/fatedier/frp/releases/download/v0.21.0/frp_0.21.0_linux_amd64.tar.gz</span><br><span class="line">$ tar -xzvf frp_0.21.0_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure><p>解压之后的文件夹中既包含了服务端的文件又包括客户端的文件，所以可以分别在两个机器上删除掉不必要的文件，也可以不删，都没有影响。强迫症还是来删一下，在解压后的文件夹中： </p><ul><li><p>在公网服务器上删除客户端相关的文件，只保留一下两个文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frps  frps.ini</span><br></pre></td></tr></table></figure></li><li><p>在内网机器上删除服务端相关的文件，只保留以下两个文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frpc   frpc.ini</span><br></pre></td></tr></table></figure></li></ul><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>就是需要修改配置文件 <code>frps.ini</code> 及 <code>frpc.ini</code>。</p><ul><li><p>修改公网服务器上的服务端配置文件 <code>frps.ini</code>，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">bind_port = 7000  #frp服务端端口（必须）</span><br></pre></td></tr></table></figure></li><li><p>修改内网目标主机的客户端配置文件 <code>frpc.ini</code>，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = xxx.xxx.xxx.xxx   #frp服务端地址，必须是公网ip或者域名，这里假设为xxx.xxx.xxx.xxx</span><br><span class="line">server_port = 7000      #frp服务端端口，即填写服务端配置中的 bind_port</span><br><span class="line"></span><br><span class="line">[ssh]</span><br><span class="line">type = tcp              #连接类型，填tcp或udp</span><br><span class="line">local_ip = 127.0.0.1    #填127.0.0.1或内网ip都可以</span><br><span class="line">local_port = 22         #需要转发到的端口，ssh端口是22</span><br><span class="line">remote_port = 6000      #frp服务端的远程监听端口，即你访问服务端的remote_port就相当于访</span><br><span class="line">                        #问客户端的 local_port，如果填0则会随机分配一个端口</span><br></pre></td></tr></table></figure></li></ul><h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><ul><li><p>在公网服务器上运行服务端程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nohup ./frps -c frps.ini &amp;</span><br></pre></td></tr></table></figure><p>查看 nohup.out 的信息，success</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ tail -f nohup.out</span><br><span class="line">2018/09/17 21:34:01 [I] [service.go:130] frps tcp listen on 0.0.0.0:7000</span><br><span class="line">2018/09/17 21:34:01 [I] [root.go:207] Start frps success</span><br><span class="line">2018/09/17 22:06:02 [I] [service.go:319] client login info: ip [125.71.229.32:60516] version [0.21.0] hostname [] os [linux] arch [amd64]</span><br><span class="line">2018/09/17 22:06:02 [I] [proxy.go:217] [7940291c148c2fca] [ssh] tcp proxy listen port [6000]</span><br><span class="line">2018/09/17 22:06:02 [I] [control.go:335] [7940291c148c2fca] new proxy [ssh] success</span><br></pre></td></tr></table></figure></li><li><p>在内网目标主机上运行客户端程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nohup ./frpc -c frpc.ini &amp;</span><br></pre></td></tr></table></figure><p>查看 nohup.out 的信息，success</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ tail -f nohup.out</span><br><span class="line">2018/09/17 22:42:22 [I] [proxy_manager.go:300] proxy removed: []</span><br><span class="line">2018/09/17 22:42:22 [I] [proxy_manager.go:310] proxy added: [ssh1]</span><br><span class="line">2018/09/17 22:42:22 [I] [proxy_manager.go:333] visitor removed: []</span><br><span class="line">2018/09/17 22:42:22 [I] [proxy_manager.go:342] visitor added: []</span><br><span class="line">2018/09/17 22:42:23 [I] [control.go:246] [0624b332c3465118] login to server success, get run id [0624b332c3465118], server udp port [0]</span><br><span class="line">2018/09/17 22:42:23 [I] [control.go:169] [0624b332c3465118] [ssh1] start proxy success</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="配置多个内网主机"><a href="#配置多个内网主机" class="headerlink" title="配置多个内网主机"></a>配置多个内网主机</h2><h4 id="错误的多客户端配置"><a href="#错误的多客户端配置" class="headerlink" title="错误的多客户端配置"></a>错误的多客户端配置</h4><p>使用一台阿里云的公网服务器，我们可以配置很多内网机器的 frp 内网穿透，公网服务器上只需要按照上述的配置一次即可，但是内网机器的配置稍有不同，如果使用了一样的配置则后添加的内网机器是无法连接上公网服务器的。这里假设另一台内网机器2的 frpc.ini 配置如下，来说明会遇到的问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ vi frpc.ini</span><br><span class="line">[common]</span><br><span class="line">server_addr = xxx.xxx.xxx.xxx  &lt;==这里还是按照上面的假设，公网服务器的ip为xxx.xxx.xxx.xxx</span><br><span class="line">server_port = 7000</span><br><span class="line"></span><br><span class="line">[ssh]</span><br><span class="line">type = tcp </span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 22</span><br><span class="line">remote_port = 6001     &lt;==remote_port设置为另一个值</span><br></pre></td></tr></table></figure><p>两个内网主机的配置除了 remote_port 不一样之外，都是一样的。但是在内网机器2上运行 frpc 后，公网服务器的 nohup.out 中会记录一下的错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[W] [control.go:332] [280d36891a6ae0c7] new proxy [ssh] error: proxy name [ssh] is already in use</span><br></pre></td></tr></table></figure><p>后来发现，frp 中是通过 [ssh] 这个名字来区分不同客户端的，所以不同的客户端要配置成不同的名字。</p><h4 id="正确的多客户端配置"><a href="#正确的多客户端配置" class="headerlink" title="正确的多客户端配置"></a>正确的多客户端配置</h4><p>内网机器1和内网机器2的配置应该区分如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">内网机器1：</span><br><span class="line">[ssh]                      &lt;==不同点</span><br><span class="line">type = tcp </span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 22</span><br><span class="line">remote_port = 6000         &lt;==不同点</span><br><span class="line"></span><br><span class="line">内网机器2：</span><br><span class="line">[ssh1]                     &lt;==不同点</span><br><span class="line">type = tcp </span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 22</span><br><span class="line">remote_port = 6001         &lt;==不同点</span><br></pre></td></tr></table></figure><p>在两个内网机器上分别运行 frpc 客户端程序后，一般就可以通过以下的方法 ssh 登录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">内网机器1：</span><br><span class="line">$ ssh -p 6000 user_name1@server_addr</span><br><span class="line"></span><br><span class="line">内网机器2：</span><br><span class="line">$ ssh -p 6001 user_name2@server_addr</span><br></pre></td></tr></table></figure><blockquote><p>以上参数中，server_addr是公网服务器的公网ip；user_name1、user_name2 分别是内网机器1、2的用户名，之后分别使用登录密码就可以登录。</p></blockquote><hr><h2 id="connection-timed-out-解决"><a href="#connection-timed-out-解决" class="headerlink" title="connection timed out 解决"></a>connection timed out 解决</h2><p>但是有时候会发现按照以上的配置还是使 frp 的服务端与客户端建立连接，在客户端上会出现以下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2018/09/17 22:02:23 [W] [control.go:113] login to server failed: dial tcp xxx.xxx.xxx.xxx:7000: connect: connection timed out</span><br><span class="line">dial tcp xxx.xxx.xxx.xxx:7000: connect: connection timed out</span><br></pre></td></tr></table></figure><p>仔细检查了一下云服务器上面的防火墙设置，发现并没有任何过滤规则，那应该不是防火墙的问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># iptables -vnL</span><br><span class="line">Chain INPUT (policy ACCEPT 46165 packets, 28M bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination         </span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination         </span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT 42223 packets, 3001K bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination</span><br></pre></td></tr></table></figure><p>然后又仔细想了一下我以前在做关于 OpenStack 的项目中也碰到了类似的问题，就是创建了云实例，发现无法通过 ssh 来登录，就是因为 OpenStack 有安全组规则相关的设置。</p><blockquote><p>想到了这里就有一种熟悉的感觉，还是原来的配方，hahaha。。。</p></blockquote><p>登录到阿里云对应云服务器的管理控制台，如下找到左上方的本实例安全组：</p><p><img src="https://raw.githubusercontent.com/cao0507/My-Pictures-Repository/master/blog/aliyun%20instance%20info.jpg" alt="aliyun"></p><p>然后点击右上角的配置规则：</p><p><img src="https://raw.githubusercontent.com/cao0507/My-Pictures-Repository/master/blog/aliyun%20group%20rules.jpg" alt=""></p><p>再点击右上角的添加安全组规则：</p><p><img src="https://raw.githubusercontent.com/cao0507/My-Pictures-Repository/master/blog/aliyun%20groups%20rules%20setting.jpg" alt="aliyun"></p><p>最后在添加安全组规则的界面添加相应的规则：</p><p><img src="https://raw.githubusercontent.com/cao0507/My-Pictures-Repository/master/blog/aliyun%20group%20rules%20adding.jpg" alt="阿里云"></p><blockquote><p>主要有两个配置项，端口范围和授权对象</p><ul><li>端口范围就是你要开放的端口的范围，需要将 <code>server_port</code> 和 <code>remote_port</code> 都添加进去，可以分成两条规则分别添加；</li><li>授权对象是你要授权的对象，一般设为 <code>0.0.0.0/0</code>  表示允许所有IP的访问。</li></ul></blockquote><p>以上就是针对阿里云的云服务器的安全组设置，其他厂商如果有安全组规则也应该是类似的。</p><hr>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSH </tag>
            
            <tag> frp </tag>
            
            <tag> 内网穿透 </tag>
            
            <tag> aliyun </tag>
            
            <tag> 安全组规则 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于 SSH 的个人总结</title>
      <link href="/2018/09/15/%E5%85%B3%E4%BA%8ESSH%E7%9A%84%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
      <url>/2018/09/15/%E5%85%B3%E4%BA%8ESSH%E7%9A%84%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>在日常学习工作中，早已离不开远程的 Linux 服务器或虚拟机，每次都是借助 Xshell 中保存的用户密码方便的 ssh 登录，偶尔在配置环境中的时候用到了秘钥登录，但是从来没有总结一下相关的内容，每次有问题都是上网查，所以写下这篇个人经验总结的文章。本文将主要介绍 <u>ssh 的安装</u>， <u>ssh 免密登录</u>，<u>允许 root 登录</u>，<u>ssh 登录的一些选项</u>，<u>ssh 登录本机</u>等问题。</p><a id="more"></a><hr><h2 id="安装-ssh"><a href="#安装-ssh" class="headerlink" title="安装 ssh"></a>安装 ssh</h2><h5 id="基于-Debian-Ubuntu-系统"><a href="#基于-Debian-Ubuntu-系统" class="headerlink" title="基于 Debian/Ubuntu 系统"></a>基于 Debian/Ubuntu 系统</h5><ul><li><p>安装客户端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install openssh-client</span><br></pre></td></tr></table></figure></li><li><p>安装服务端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install openssh-server</span><br></pre></td></tr></table></figure></li></ul><h5 id="基于-RedHat-CentOS-系统"><a href="#基于-RedHat-CentOS-系统" class="headerlink" title="基于 RedHat/CentOS 系统"></a>基于 RedHat/CentOS 系统</h5><ul><li><p>安装客户端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install openssh-clients</span><br></pre></td></tr></table></figure></li><li><p>安装服务端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install openssh-server</span><br></pre></td></tr></table></figure></li></ul><blockquote><p> 关于客户端与服务端的区别就是：客户端用于你去登录别人，而服务端则是别人来登录你。</p></blockquote><hr><h2 id="ssh-免密登录"><a href="#ssh-免密登录" class="headerlink" title="ssh 免密登录"></a>ssh 免密登录</h2><h5 id="快速实现步骤："><a href="#快速实现步骤：" class="headerlink" title="快速实现步骤："></a>快速实现步骤：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa</span><br><span class="line">$ ssh-copy-id -i ~/.ssh/id_rsa.pub username@xxx.xxx.xxx.xxx</span><br></pre></td></tr></table></figure><h5 id="说明如下："><a href="#说明如下：" class="headerlink" title="说明如下："></a>说明如下：</h5><p>Linux系统有一个钥匙环(keyring)的管理程序。钥匙环受到用户登录密码的保护。当你登录Linux系统时，会自动解开钥匙环的密码，从而可访问钥匙环。SSH的密钥和公钥也存储在钥匙环。所以初次使用SSH密钥登录远程Linux服务器时需要输入一次SSH密钥的密码。而将来使用SSH密钥登录时不再输入密码。Ubuntu的钥匙环程序是seahorse。</p><p>SSH密钥就好比是你的身份证明。远程Linux服务器用你生成的SSH公钥来加密一条消息，而只有你的SSH密钥可以解开这条消息。所以其他人如果没有你的SSH密钥，是无法解开加密消息的，从而也就无法登录你的Linux服务器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/home/user1/.ssh/id_rsa): </span><br><span class="line">Enter passphrase (empty for no passphrase): </span><br><span class="line">Enter same passphrase again: </span><br><span class="line">Your identification has been saved in /home/user1/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved in /home/user1/.ssh/id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:BQeyB4pwfE1L7NAi7hjrTl5X814QW5Gu4dOZx0gIdng user1@ubuntu</span><br><span class="line">The key&apos;s randomart image is:</span><br><span class="line">+---[RSA 2048]----+</span><br><span class="line">|...  == +....    |</span><br><span class="line">| oo.+o+O E ..    |</span><br><span class="line">| ..o.++ =.+.     |</span><br><span class="line">|. .   .. ++o     |</span><br><span class="line">| =     oSo= =    |</span><br><span class="line">|o .   . o+.= o   |</span><br><span class="line">|.. . .   ....    |</span><br><span class="line">|o.. .   . .      |</span><br><span class="line">|.o       .       |</span><br><span class="line">+----[SHA256]-----+</span><br><span class="line"></span><br><span class="line">$ cd ~/.ssh/</span><br><span class="line">$ ls</span><br><span class="line">id_rsa  id_rsa.pub</span><br></pre></td></tr></table></figure><p><code>ssh-copy-id</code> 工具可以把本地主机的公钥复制到远程主机的 authorized_keys 文件上，<code>ssh-copy-id</code> 命令也会给远程主机的用户主目录（home）和<code>~/.ssh</code>, 和<code>~/.ssh/authorized_keys</code>设置合适的权限。 </p><ul><li><p>语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id [-i [identity_file]] [user@]machine</span><br></pre></td></tr></table></figure></li><li><p>选项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-i：指定公钥文件</span><br></pre></td></tr></table></figure></li><li><p>实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-copy-id -i ~/.ssh/id_rsa.pub user1@192.168.1.158</span><br><span class="line"></span><br><span class="line">/usr/bin/ssh-copy-id: INFO: Source of key(s) to be installed: &quot;/home/user1/.ssh/id_rsa.pub&quot;</span><br><span class="line">The authenticity of host &apos;192.168.1.158 (192.168.1.158)&apos; can&apos;t be established.</span><br><span class="line">ECDSA key fingerprint is SHA256:Gx0RFwV4EiROc6ymV/BmSLE2zNT9AswZvzq9pc6Srwo.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)? yes</span><br><span class="line">/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed</span><br><span class="line">/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys</span><br><span class="line">user1@192.168.1.158&apos;s password: </span><br><span class="line"></span><br><span class="line">Number of key(s) added: 1</span><br><span class="line"></span><br><span class="line">Now try logging into the machine, with:   &quot;ssh &apos;user1@192.168.1.158&apos;&quot;</span><br><span class="line">and check to make sure that only the key(s) you wanted were added.</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="root-用户登录"><a href="#root-用户登录" class="headerlink" title="root 用户登录"></a>root 用户登录</h2><p>在一些系统上，比如 ubuntu，root 用户是默认禁用的，也就是说通常不允许 root 账号通过网络登录。但是通过适当的配置可以允许 root 用户登录。</p><ol><li><p>设置 root 用户密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo passwd root</span><br></pre></td></tr></table></figure></li><li><p>允许 root 用户远程登录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># vi /etc/ssh/sshd_config</span><br><span class="line">...</span><br><span class="line">PermitRootLogin yes   #取消注释</span><br><span class="line"></span><br><span class="line"># service sshd restart   #重启ssh服务</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="ssh-登录选项"><a href="#ssh-登录选项" class="headerlink" title="ssh 登录选项"></a>ssh 登录选项</h2><h5 id="1-无选项参数运行-ssh"><a href="#1-无选项参数运行-ssh" class="headerlink" title="1. 无选项参数运行 ssh"></a>1. 无选项参数运行 ssh</h5><p>如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh 192.168.1.156</span><br></pre></td></tr></table></figure><p>这会用你的用户名去 <code>192.168.1.156</code> 这台主机，相当于省略了。如果目标主机上没有和你的用户名同名的，则每次输入密码都是显示密码错误。</p><h5 id="2-指定登录用户"><a href="#2-指定登录用户" class="headerlink" title="2. 指定登录用户"></a>2. 指定登录用户</h5><p>有如下两种方式指定用户名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh -l user1 192.168.1.156</span><br><span class="line"></span><br><span class="line">ssh user1@192.168.1.156</span><br></pre></td></tr></table></figure><h5 id="3-指定端口"><a href="#3-指定端口" class="headerlink" title="3. 指定端口"></a>3. 指定端口</h5><p>ssh 默认使用的端口号是 22。大多现代的 Linux 系统 22 端口都是开放的。如果你运行 ssh 程序而没有指定端口号，它直接就是通过 22 端口发送请求的。 当然也可以改变 ssh 的默认端口号，只需要修改 <code>/etc/ssh/sshd_config</code> 文件，找到此行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Port 22</span><br></pre></td></tr></table></figure><p>修改成你想要的端口，如 1234。然后重启 ssh 服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service sshd restart</span><br></pre></td></tr></table></figure><p>使用新的端口来访问 ssh 服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh -p 1234 user1@192.168.1.156</span><br><span class="line">或</span><br><span class="line">ssh -oPort=1234 user1@192.168.1.156</span><br></pre></td></tr></table></figure><h5 id="4-绑定源地址"><a href="#4-绑定源地址" class="headerlink" title="4. 绑定源地址"></a>4. 绑定源地址</h5><p>如果你的主机有多个 IP，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ ifconfig</span><br><span class="line">eth0      Link encap:Ethernet  HWaddr d0:94:66:52:07:57  </span><br><span class="line">          inet addr:192.168.1.10  Bcast:192.168.1.255  Mask:255.255.255.0</span><br><span class="line">          inet6 addr: fe80::d294:66ff:fe52:757/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:3217625896 errors:0 dropped:1996 overruns:0 frame:0</span><br><span class="line">          TX packets:3417264542 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000 </span><br><span class="line">          RX bytes:2364841876835 (2.3 TB)  TX bytes:2940832952714 (2.9 TB)</span><br><span class="line">          Memory:93300000-933fffff </span><br><span class="line"></span><br><span class="line">eth1      Link encap:Ethernet  HWaddr d0:94:66:52:07:58  </span><br><span class="line">          inet addr:192.168.1.20  Bcast:192.168.1.255  Mask:255.255.255.0</span><br><span class="line">          inet6 addr: fe80::d294:66ff:fe52:758/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:2387702 errors:0 dropped:2071 overruns:0 frame:0</span><br><span class="line">          TX packets:1052 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000 </span><br><span class="line">          RX bytes:275109861 (275.1 MB)  TX bytes:100254 (100.2 KB)</span><br><span class="line">          Memory:93200000-932fffff</span><br></pre></td></tr></table></figure><p>有时，你可能想指定以某个 IP 来登录别的 Linux 主机，则可以使用 -b 选项来指定一个 IP地址。这个 IP 将会用作建立连接的源地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -b 192.168.1.20 user1@192.168.1.156</span><br></pre></td></tr></table></figure><p>在服务端，可以使用 netstat 命令来检查 ssh 服务的连接建立情况。可以看到 IP 为 192.168.1.20 的连接已经建立。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ netstat |grep ssh</span><br><span class="line">tcp        0      0 192.168.1.156:ssh       192.168.1.20:43838      ESTABLISHED</span><br></pre></td></tr></table></figure><h5 id="5-公钥检查"><a href="#5-公钥检查" class="headerlink" title="5. 公钥检查"></a>5. 公钥检查</h5><p><strong>什么是公钥检查：</strong></p><p>ssh 连接远程主机时，会检查主机的公钥。如果是第一次该主机，会显示该主机的公钥摘要，提示用户是否信任该主机： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ssh user1@192.168.1.57</span><br><span class="line">The authenticity of host &apos;192.168.1.57 (192.168.1.57)&apos; can&apos;t be established.</span><br><span class="line">ECDSA key fingerprint is SHA256:Gx0RFwV4EiROc6ymV/BmSLE2zNT9AswZvzq9pc6Srwo.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)?</span><br></pre></td></tr></table></figure><p>当选择接受，就会将该主机的公钥追加到文件 ~/.ssh/known_hosts 中。当再次连接该主机时，就不会再提示该问题了。  如果因为某种原因（服务器系统重装，服务器间IP地址交换，DHCP，虚拟机重建，中间人劫持），该IP地址的公钥改变了，当使用 SSH  连接的时候，会报错： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!</span><br><span class="line">Someone could be eavesdropping on you right now (man-in-the-middle attack)!</span><br><span class="line">It is also possible that the RSA host key has just been changed.</span><br><span class="line">The fingerprint for the RSA key sent by the remote host is</span><br><span class="line">e9:0c:36:89:7f:3c:07:71:09:5a:9f:28:8c:44:e9:05.</span><br><span class="line">Please contact your system administrator.</span><br><span class="line">Add correct host key in /home/jiangxin/.ssh/known_hosts to get rid of this message.</span><br><span class="line">Offending key in /home/jiangxin/.ssh/known_hosts:81</span><br><span class="line">RSA host key for 192.168.0.110 has changed and you have requested strict checking.</span><br><span class="line">Host key verification failed.</span><br></pre></td></tr></table></figure><p>上面的警告信息说的是：</p><ul><li>服务器公钥已经改变，新的公钥的摘要是：e9:0c:36:89:7f:3c:07:71:09:5a:9f:28:8c:44:e9:05.</li><li>该服务器原来的公钥记录在文件 <code>~/.ssh/known_hosts</code> 中第 81 行。</li></ul><p>如果确认不是中间人劫持，需要连接到该服务器，怎么办呢？最简单的就是用 vi 打开 <code>~/.ssh/known_hosts</code> 文件，定位到 81 行，将该行删除。之后就可以使用 ssh 连接了。 </p><blockquote><p>我之前在项目中，基于 OpenStack 来搭建 SDN 网络时经常碰到上面的错误，因为经常会将一些云主机给删掉而将他们的 IP 分给新起的云主机。再用这个 IP 来登录新的主机时就会碰到这个问题，以前还不太明白咋回事，现在有种恍然大悟的感觉。</p></blockquote><p><strong>如何不进行公钥检查：</strong></p><p>在首次连接服务器时，会弹出公钥确认的提示。这会导致某些自动化任务，由于初次连接服务器而导致自动化任务中断。或者由于  <code>~/.ssh/known_hosts</code> 文件内容清空，导致自动化任务中断。 SSH 客户端的 StrictHostKeyChecking  配置指令，可以实现当第一次连接服务器时，自动接受新的公钥。只需要修改 <code>/etc/ssh/ssh_config</code> 文件，包含下列语句： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Host *</span><br><span class="line">   StrictHostKeyChecking no</span><br></pre></td></tr></table></figure><p>或者在 ssh 命令行中用 -o 参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -o StrictHostKeyChecking=no  user1@192.168.1.110</span><br></pre></td></tr></table></figure><blockquote><p>公钥检查确实很烦人，我以前在写自动化登录脚本时就觉得很棘手，导致自动化登录脚本经常出错。早知道是这个问题就好办多了，感觉写博客总结一下这些内容对于自己挺有帮助的。</p></blockquote><hr><h2 id="ssh-登录本机的问题"><a href="#ssh-登录本机的问题" class="headerlink" title="ssh 登录本机的问题"></a>ssh 登录本机的问题</h2><p>不试不知道，一试才知道 ssh 登录本机其实和登录其他的主机是一样的，也需要输入密码验证，免密登录也需要将自己的公钥记录在 <code>~/.ssh/authorized_keys</code> 文件中。ssh 登录本机可以使用本机的任意一个 IP 或者也可以用回环地址 <code>127.0.0.1</code> 。</p><hr><p>完结。。以上内容就是个人在学习工作中关于 ssh 的一些总结，感觉里面的学问真的是太大了，写了这么多其实还有很多很多相关的知识是我不知道不清楚的，不过学习就是这样的，总是由浅入深，不可能一下子就把所有的弄明白，剩下的就以后再慢慢总结啦！</p>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSH </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>frp 内网穿透实现 ssh 访问内网主机</title>
      <link href="/2018/09/14/frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%AE%9E%E7%8E%B0ssh%E8%AE%BF%E9%97%AE%E5%86%85%E7%BD%91%E6%9C%BA%E5%99%A8/"/>
      <url>/2018/09/14/frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%AE%9E%E7%8E%B0ssh%E8%AE%BF%E9%97%AE%E5%86%85%E7%BD%91%E6%9C%BA%E5%99%A8/</url>
      <content type="html"><![CDATA[<h2 id="本文目的"><a href="#本文目的" class="headerlink" title="本文目的"></a>本文目的</h2><p>frp 是一个可用于内网穿透的高性能的反向代理应用，支持 tcp, udp, http, https 协议。 本文将基于 frp 来实现内网穿透，从而实现从外网 ssh 登录内网主机，而不对 frp 其他的应用做过多的说明。</p><a id="more"></a><hr><h2 id="frp-的作用"><a href="#frp-的作用" class="headerlink" title="frp 的作用"></a>frp 的作用</h2><ul><li>利用处于内网或防火墙后的机器，对外网环境提供 http 或 https 服务。</li><li>对于 http, https 服务支持基于域名的虚拟主机，支持自定义域名绑定，使多个域名可以共用一个80端口。</li><li>利用处于内网或防火墙后的机器，对外网环境提供 tcp 和 udp 服务，例如在家里通过 ssh 访问处于公司内网环境内的主机。</li></ul><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p><img src="https://raw.githubusercontent.com/fatedier/frp/master/doc/pic/architecture.png" alt="架构"></p><p>在具有公网IP的服务器或VPS上安装运行 frp 的服务端程序frps，并在处于内网的目标主机上面安装运行 frp 的客户端程序 frpc ，然后 User 就可以通过公网服务器来实现内网穿透从而访问内网主机。</p><hr><h2 id="配置-ssh-访问内网机器"><a href="#配置-ssh-访问内网机器" class="headerlink" title="配置 ssh 访问内网机器"></a>配置 ssh 访问内网机器</h2><p>根据不同的系统架构选择不同的安装包，从 <a href="https://github.com/fatedier/frp/releases" target="_blank" rel="noopener">frp下载链接</a> 上下载合适的安装包。由于本人的公网服务器是 vultr 上面的一台 VPS，操作系统是 CentOS 7；内网机器也是一台 Linux 服务器，操作系统是 Ubuntu 16.04，所以我使用的安装包是 <code>frp_0.21.0_linux_amd64.tar.gz</code> 。配置步骤如下：</p><ol><li><p>下载安装包</p><p>在公网服务器和内网机器上都要下载安装包并解压：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ wget https://github.com/fatedier/frp/releases/download/v0.21.0/frp_0.21.0_linux_amd64.tar.gz</span><br><span class="line">$ tar -xzvf frp_0.21.0_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure><p>解压之后的文件夹中既包含了服务端的文件又包括客户端的文件，所以可以分别在两个机器上删除掉不必要的文件，也可以不删，都没有影响。强迫症还是来删一下，在解压后的文件夹中：</p><ul><li><p>在公网服务器上删除客户端相关的文件，只保留一下两个文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frps  frps.ini</span><br></pre></td></tr></table></figure></li><li><p>在内网机器上删除服务端相关的文件，只保留以下两个文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frpc   frpc.ini</span><br></pre></td></tr></table></figure></li></ul></li><li><p>在公网服务器上配置并启动</p><p>修改配置文件 <code>$ vi frps.ini</code>，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">bind_port = 7000  #frp服务端端口（必须）</span><br></pre></td></tr></table></figure><p>配置很简单，然后启动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nohup ./frps -c frps.ini &amp;</span><br></pre></td></tr></table></figure><p>查看 nohup.out 的信息，success</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># tail -f nohup.out </span><br><span class="line">2018/09/14 05:33:15 [I] [service.go:130] frps tcp listen on 0.0.0.0:7000</span><br><span class="line">2018/09/14 05:33:15 [I] [root.go:207] Start frps success</span><br><span class="line">2018/09/14 05:49:47 [I] [service.go:130] frps tcp listen on 0.0.0.0:7000</span><br><span class="line">2018/09/14 05:49:47 [I] [root.go:207] Start frps success</span><br><span class="line">2018/09/14 06:28:59 [I] [service.go:319] client login info: ip [125.71.219.33:37092] version [0.21.0] hostname [] os [linux] arch [amd64]</span><br><span class="line">2018/09/14 06:28:59 [I] [proxy.go:217] [93eec0dde173fc68] [ssh] tcp proxy listen port [6000]</span><br><span class="line">2018/09/14 06:28:59 [I] [control.go:335] [93eec0dde173fc68] new proxy [ssh] success</span><br></pre></td></tr></table></figure></li><li><p>在内网机器上配置并启动</p><p>修改配置文件 <code>$ vi frpc.ini</code>，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = 0.0.0.0   #frp服务端地址，可以填ip或者域名，这里假设为0.0.0.0</span><br><span class="line">server_port = 7000      #frp服务端端口，即填写服务端配置中的 bind_port</span><br><span class="line"></span><br><span class="line">[ssh]</span><br><span class="line">type = tcp              #连接类型，填tcp或udp</span><br><span class="line">local_ip = 127.0.0.1    #填127.0.0.1或内网ip都可以</span><br><span class="line">local_port = 22         #需要转发到的端口，ssh端口是22</span><br><span class="line">remote_port = 6000      #frp服务端的远程监听端口，即你访问服务端的remote_port就相当于访</span><br><span class="line">                        #问客户端的 local_port，如果填0则会随机分配一个端口</span><br></pre></td></tr></table></figure><p>启动客户端程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nohup ./frpc -c frpc.ini &amp;</span><br></pre></td></tr></table></figure><p>查看 nohup.out 的信息，success</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ tail -f nohup.out</span><br><span class="line">2018/09/14 14:28:58 [I] [proxy_manager.go:300] proxy removed: []</span><br><span class="line">2018/09/14 14:28:58 [I] [proxy_manager.go:310] proxy added: [ssh]</span><br><span class="line">2018/09/14 14:28:58 [I] [proxy_manager.go:333] visitor removed: []</span><br><span class="line">2018/09/14 14:28:58 [I] [proxy_manager.go:342] visitor added: []</span><br><span class="line">2018/09/14 14:28:59 [I] [control.go:246] [93eec0dde173fc68] login to server success, get run id [93eec0dde173fc68], server udp port [0]</span><br><span class="line">2018/09/14 14:29:00 [I] [control.go:169] [93eec0dde173fc68] [ssh] start proxy success</span><br></pre></td></tr></table></figure></li><li><p>登录</p><p>完成前面三步的配置就可以登录对应的内网机器了，执行 ssh 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh -oPort=6000 username@server_addr</span><br><span class="line">或者</span><br><span class="line">ssh -p 6000 username@server_addr</span><br></pre></td></tr></table></figure><blockquote><p>上面登录使用的 username 是<strong>内网机器的用户名</strong>，server_addr是<strong>公网服务器的IP</strong>，port 6000就是设置的 remote_port，最后的登录密码是<strong>内网机器的密码</strong>，而不是公网机器的密码，这一点一定要注意。</p></blockquote></li></ol><hr><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>在启动服务端和客户端程序之后，可能发现还是无法登录到内网内网机器，在内网机器上面执行 <code>tail -f nohup.out</code> 查看启动命令的执行结果，可以发现以下的问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ tail -f nohup.out </span><br><span class="line">2018/09/14 14:11:02 [I] [proxy_manager.go:333] visitor removed: []</span><br><span class="line">2018/09/14 14:11:02 [I] [proxy_manager.go:342] visitor added: []</span><br><span class="line">2018/09/14 14:13:09 [W] [control.go:113] login to server failed: dial tcp xxx.xxx.xxx.xxx:7000: connect: connection timed out</span><br><span class="line">dial tcp xxx.xxx.xxx.xxx:7000: connect: connection timed out</span><br></pre></td></tr></table></figure><p>仔细检查了一下，发现是我公网服务器防火墙的原因，没有允许对应端口的流量通过，所以需要配置防火墙：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># firewall-cmd --zone=public --add-port=7000/tcp --permanent</span><br><span class="line"># firewall-cmd --zone=public --add-port=6000/tcp --permanent</span><br><span class="line"># firewall-cmd --reload</span><br></pre></td></tr></table></figure><blockquote><p>上面配置防火墙的命令是针对 CentOS 的，如果是别的系统不太一样，如 Ubuntu 通过<code>iptables</code>命令来配置。</p></blockquote><hr>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSH </tag>
            
            <tag> frp </tag>
            
            <tag> 内网穿透 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>shell中set指令的用法</title>
      <link href="/2018/09/13/shell%E4%B8%ADset%E6%8C%87%E4%BB%A4%E7%9A%84%E7%94%A8%E6%B3%95/"/>
      <url>/2018/09/13/shell%E4%B8%ADset%E6%8C%87%E4%BB%A4%E7%9A%84%E7%94%A8%E6%B3%95/</url>
      <content type="html"><![CDATA[<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set [-可选参数] [-o 选项]</span><br></pre></td></tr></table></figure><h4 id="功能说明"><a href="#功能说明" class="headerlink" title="功能说明"></a>功能说明</h4><p>set 指令可根据不同的需求来设置当前所使用 shell 的执行方式，同时也可以用来设置或显示 shell 变量的值。当指定某个单一的选项时将设置 shell 的常用特性，如果在选项后使用 -o 参数将打开特殊特性，若是 +o 将关闭相应的特殊特性。而不带任何参数的 set 指令将显示当前 shell 中的全部变量，且总是返回 true，除非遇到非法的选项。</p><a id="more"></a><hr><h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h4><p>可选参数及其说明如下：</p><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:center">-a</td><td style="text-align:left">标示已修改的变量，以供输出至环境变量</td></tr><tr><td style="text-align:center">-b</td><td style="text-align:left">使被中止的后台程序立刻回报执行状态</td></tr><tr><td style="text-align:center">-d</td><td style="text-align:left">Shell预设会用杂凑表记忆使用过的指令，以加速指令的执行。使用-d参数可取消</td></tr><tr><td style="text-align:center"><strong>-e</strong></td><td style="text-align:left">若指令传回值不等于0，则立即退出shell</td></tr><tr><td style="text-align:center">-f</td><td style="text-align:left">取消使用通配符</td></tr><tr><td style="text-align:center">-h</td><td style="text-align:left">自动记录函数的所在位置</td></tr><tr><td style="text-align:center">-k</td><td style="text-align:left">指令所给的参数都会被视为此指令的环境变量</td></tr><tr><td style="text-align:center">-l</td><td style="text-align:left">记录for循环的变量名称</td></tr><tr><td style="text-align:center">-m</td><td style="text-align:left">使用监视模式</td></tr><tr><td style="text-align:center">-n</td><td style="text-align:left">测试模式，只读取指令，而不实际执行</td></tr><tr><td style="text-align:center">-p</td><td style="text-align:left">启动优先顺序模式</td></tr><tr><td style="text-align:center">-P</td><td style="text-align:left">启动-P参数后，执行指令时，会以实际的文件或目录来取代符号连接</td></tr><tr><td style="text-align:center">-t</td><td style="text-align:left">执行完随后的指令，即退出shell</td></tr><tr><td style="text-align:center">-u</td><td style="text-align:left">当执行时使用到未定义过的变量，则显示错误信息</td></tr><tr><td style="text-align:center">-v</td><td style="text-align:left">显示shell所读取的输入值</td></tr><tr><td style="text-align:center">-H shell</td><td style="text-align:left">可利用”!”加&lt;指令编号&gt;的方式来执行 history 中记录的指令</td></tr><tr><td style="text-align:center"><strong>-x</strong></td><td style="text-align:left">执行指令后，会先显示该指令及所下的参数</td></tr><tr><td style="text-align:center">+&lt;参数&gt;</td><td style="text-align:left">取消某个set曾启动的参数。与-&lt;参数&gt;相反</td></tr><tr><td style="text-align:center">-o option</td><td style="text-align:left">特殊属性有很多，大部分与上面的可选参数功能相同，这里就不列了</td></tr></tbody></table><hr><h4 id="重点参数"><a href="#重点参数" class="headerlink" title="重点参数"></a>重点参数</h4><p>最常用的两个参数就是 <strong>-e</strong> 与 <strong>-x</strong> ，一般写在 shell 代码逻辑之前，这两个组合在一起用，可以在 debug 的时候替你节省许多时间 。</p><ul><li><p><code>set -x</code> 会在执行每一行 shell 脚本时，把执行的内容输出来。它可以让你看到当前执行的情况，里面涉及的变量也会被替换成实际的值。 </p></li><li><p><code>set -e</code> 会在执行出错时结束程序，就像其他语言中的“抛出异常”一样。（准确说，不是所有出错的时候都会结束程序，见下面的注） </p><blockquote><p>注：set -e结束程序的条件比较复杂，在man bash里面，足足用了一段话描述各种情景。大多数执行都会在出错时退出，除非 shell 命令位于以下情况：</p><ol><li>一个 pipeline 的非结尾部分，比如error | ok</li><li>一个组合语句的非结尾部分，比如ok &amp;&amp; error || other</li><li>一连串语句的非结尾部分，比如error; ok</li><li>位于判断语句内，包括test、if、while等等。</li></ol></blockquote></li></ul><hr><h4 id="其他用法"><a href="#其他用法" class="headerlink" title="其他用法"></a>其他用法</h4><ul><li><p><strong>set：初始化位置参数</strong></p><p>调用 set 是接一个或多个参数时，set 会把参数的值赋予位置参数，从 $1 开始赋值。如下例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cat set-it.sh</span><br><span class="line">#!/bin/bash</span><br><span class="line">set first second third</span><br><span class="line">echo $3 $2 $1</span><br><span class="line"></span><br><span class="line">$ ./set-it.sh</span><br><span class="line">third second first</span><br></pre></td></tr></table></figure><p>如上，在执行 <code>set-it.sh</code> 脚本时并没有输入参数，但是使用 set 指令后会对位置参数进行赋值。</p></li><li><p><strong>set：显示 shell 变量</strong></p><p>如果不带任何参数的使用 set 命令，set 指令就会显示一列已设置的 shell 变量，包括用户定义的变量和关键字变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ set </span><br><span class="line">BASH_VERSION=&apos;4.2.24(1)-release&apos;</span><br><span class="line">COLORS=/etc/DIR_COLORS</span><br><span class="line">MAIL=/var/spool/mail/username</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ul><hr>]]></content>
      
      <categories>
          
          <category> Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> set </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hyperledger Fabric 多机环境部署</title>
      <link href="/2018/09/12/Fabric%E5%A4%9A%E6%9C%BA%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"/>
      <url>/2018/09/12/Fabric%E5%A4%9A%E6%9C%BA%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要基于 Hyperledger Fabric v1.0 的<a href="https://cao0507.github.io/2018/08/26/Fabric%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/">单机环境部署文档</a>来搭建多机环境。其中对于Fabric 的基础环境的配置都是一样的，也就是前 6 步都是一样的。配置好基础环境之后将配置好的虚拟机镜像复制 4 份，作为其他节点的镜像，该环境包括 5 个节点，是 4 Peer + 1 Orderer的架构，如下表：</p><a id="more"></a><table><thead><tr><th style="text-align:center">主机名</th><th style="text-align:center">IP地址</th></tr></thead><tbody><tr><td style="text-align:center">orderer.example.com</td><td style="text-align:center">192.168.1.130</td></tr><tr><td style="text-align:center">peer0.org1.example.com</td><td style="text-align:center">192.168.1.188</td></tr><tr><td style="text-align:center">peer1.org1.example.com</td><td style="text-align:center">192.168.1.186</td></tr><tr><td style="text-align:center">peer0.org2.example.com</td><td style="text-align:center">192.168.1.193</td></tr><tr><td style="text-align:center">peer1.org2.example.com</td><td style="text-align:center">192.168.1.112</td></tr></tbody></table><h1 id="环境部署"><a href="#环境部署" class="headerlink" title="环境部署"></a>环境部署</h1><h3 id="1-更换-apt-源"><a href="#1-更换-apt-源" class="headerlink" title="1. 更换 apt 源"></a>1. 更换 apt 源</h3><p>先备份 sources.list 文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak</span><br></pre></td></tr></table></figure><p>再修改 sources.list 文件，换成阿里云的国内源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vim /etc/apt/sources.list</span><br><span class="line">deb-src http://archive.ubuntu.com/ubuntu xenial main restricted #Added by software-properties</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted multiverse universe #Added by software-properties</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted multiverse universe #Added by software-properties</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial universe</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates universe</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse #Added by software-properties</span><br><span class="line">deb http://archive.canonical.com/ubuntu xenial partner</span><br><span class="line">deb-src http://archive.canonical.com/ubuntu xenial partner</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted multiverse universe #Added by software-properties</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-security universe</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-security multiverse</span><br></pre></td></tr></table></figure><p>最后更新一下源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br></pre></td></tr></table></figure><h3 id="2-安装-curl"><a href="#2-安装-curl" class="headerlink" title="2. 安装 curl"></a>2. 安装 curl</h3><p>Ubuntu 16.04 一般默认是安装了 curl 的，可以通过以下命令验证：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ curl -V</span><br><span class="line">curl 7.47.0 (x86_64-pc-linux-gnu) libcurl/7.47.0 GnuTLS/3.4.10 zlib/1.2.8 libidn/1.32 librtmp/2.3</span><br><span class="line">Protocols: dict file ftp ftps gopher http https imap imaps ldap ldaps pop3 pop3s rtmp rtsp smb smbs smtp smtps telnet tftp </span><br><span class="line">Features: AsynchDNS IDN IPv6 Largefile GSS-API Kerberos SPNEGO NTLM NTLM_WB SSL libz TLS-SRP UnixSockets</span><br></pre></td></tr></table></figure><p>如果没有安装，则通过 apt-get 安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install curl</span><br></pre></td></tr></table></figure><h3 id="3-安装-Docker"><a href="#3-安装-Docker" class="headerlink" title="3. 安装 Docker"></a>3. 安装 Docker</h3><ul><li><p>由于 apt 源使用HTTPS以确保软件下载过程中不被篡改。因此，我们首先需要添加使用HTTPS传输的软件包以及CA证书。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    software-properties-common</span><br></pre></td></tr></table></figure></li><li><p>为了确认所下载软件包的合法性，需要添加软件源的 GPG 秘钥</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure></li><li><p>然后，我们需要向 sources.list 中添加 Docker 软件源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo add-apt-repository \</span><br><span class="line">    &quot;deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu \</span><br><span class="line">    $(lsb_release -cs) \</span><br><span class="line">    stable&quot;</span><br></pre></td></tr></table></figure><blockquote><p>以上命令会添加稳定版本的Docker CE apt 镜像源。</p></blockquote></li><li><p>更新 apt 软件包缓存，并安装 docker-ce：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line"></span><br><span class="line">$ sudo apt-get install docker-ce</span><br></pre></td></tr></table></figure></li><li><p>查看 Docker 版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker -v</span><br><span class="line">Docker version 18.06.0-ce, build 0ffa825</span><br></pre></td></tr></table></figure><p>满足官方文档中 <em>Docker version 17.06.2-ce or greater is required</em> 的要求。</p></li><li><p>启动 Docker CE</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl enable docker</span><br><span class="line">$ sudo systemctl start docker</span><br></pre></td></tr></table></figure></li><li><p>建立 docker 用户组</p><p>默认情况下，<code>docker</code> 命令会使用 <a href="https://en.wikipedia.org/wiki/Unix_domain_socket" target="_blank" rel="noopener">Unix socket</a> 与 Docker 引擎通讯。而只有 <code>root</code> 用户和 <code>docker</code> 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 <code>root</code> 用户。因此，更好地做法是将需要使用 <code>docker</code> 的用户加入 <code>docker</code> 用户组。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo groupadd docker</span><br></pre></td></tr></table></figure><blockquote><p>其实一般按照上面的方法安装 Docker 后就已经创建好 docker 用户组了，可以使用 <code>$ cat /etc/group | grep docker</code> 命令来验证，所以就不需要再建立 docker 用户组了，再建立也会报错提示用户组已存在的。</p></blockquote></li><li><p>将当前用户加入 docker 用户组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo usermod -aG docker $USER</span><br></pre></td></tr></table></figure><blockquote><p>下次登录时即可方便的使用 docker 命令。</p></blockquote></li><li><p>测试 Docker 是否安装正确</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$ docker run hello-world</span><br><span class="line">Unable to find image &apos;hello-world:latest&apos; locally</span><br><span class="line">latest: Pulling from library/hello-world</span><br><span class="line">9db2ca6ccae0: Pull complete </span><br><span class="line">Digest: sha256:4b8ff392a12ed9ea17784bd3c9a8b1fa3299cac44aca35a85c90c5e3c7afacdc</span><br><span class="line">Status: Downloaded newer image for hello-world:latest</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">To generate this message, Docker took the following steps:</span><br><span class="line"> 1. The Docker client contacted the Docker daemon.</span><br><span class="line"> 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.</span><br><span class="line">    (amd64)</span><br><span class="line"> 3. The Docker daemon created a new container from that image which runs the</span><br><span class="line">    executable that produces the output you are currently reading.</span><br><span class="line"> 4. The Docker daemon streamed that output to the Docker client, which sent it</span><br><span class="line">    to your terminal.</span><br><span class="line"></span><br><span class="line">To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line"> $ docker run -it ubuntu bash</span><br><span class="line"></span><br><span class="line">Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line"> https://hub.docker.com/</span><br><span class="line"></span><br><span class="line">For more examples and ideas, visit:</span><br><span class="line"> https://docs.docker.com/engine/userguide/</span><br></pre></td></tr></table></figure></li><li><p>配置镜像加速器</p><p>国内从 Docker Hub 拉取镜像有时会遇到困难，此时可以配置镜像加速器。Docker 官方和国内很多云服务商都提供了国内加速器服务，例如： </p><ul><li><a href="https://docs.docker.com/registry/recipes/mirror/#use-case-the-china-registry-mirror" target="_blank" rel="noopener">Docker 官方提供的中国 registry mirror <code>https://registry.docker-cn.com</code></a> </li><li><a href="https://kirk-enterprise.github.io/hub-docs/#/user-guide/mirror" target="_blank" rel="noopener">七牛云加速器 <code>https://reg-mirror.qiniu.com/</code></a> </li></ul><blockquote><p>当配置某一个加速器地址之后，若发现拉取不到镜像，请切换到另一个加速器地址。</p><p>国内各大云服务商均提供了 Docker 镜像加速服务，建议根据运行 Docker 的云平台选择对应的镜像加速服务。</p></blockquote><p>我们以 Docker 官方加速器 <code>https://registry.docker-cn.com</code> 为例进行介绍。 </p><p>在 <code>/etc/docker/daemon.json</code> 中写入如下内容（如果文件不存在则创建）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [</span><br><span class="line">    &quot;https://registry.docker-cn.com&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后重新启动服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl daemon-reload</span><br><span class="line">$ sudo systemctl restart docker</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-安装-Docker-Compose"><a href="#4-安装-Docker-Compose" class="headerlink" title="4. 安装 Docker Compose"></a>4. 安装 Docker Compose</h3><ul><li><p>通过二进制包来安装，从 <a href="https://github.com/docker/compose/releases" target="_blank" rel="noopener">官方 GitHub Release</a> 处直接下载编译好的二进制文件即可。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo curl -L https://github.com/docker/compose/releases/download/1.22.0/docker-compose-$(uname -s)-$(uname -m) -o /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line">$ sudo chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure></li><li><p>查看 Docker compose 版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose --version</span><br><span class="line">docker-compose version 1.22.0, build f46880fe</span><br></pre></td></tr></table></figure><blockquote><p>满足官方文档中 <em>Docker Compose version 1.14.0 or greater</em>  的要求。</p></blockquote></li></ul><h3 id="5-安装-Go-语言环境"><a href="#5-安装-Go-语言环境" class="headerlink" title="5. 安装 Go 语言环境"></a>5. 安装 Go 语言环境</h3><p>Hyperledger Fabric 在很多组件中使用了 Go 语言，并且 <code>Hyperledger fabric 1.2.0</code> 要求使用的是 <code>GO version 1.10.x</code> ，所以需要在我们的环境中安装对应的 Go 语言。</p><ul><li><p>从官网下载 <code>1.10.x</code> 版本的 Linux 平台的源码包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget https://dl.google.com/go/go1.10.3.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>解压到指定目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo tar zxvf go1.10.3.linux-amd64.tar.gz -C /usr/local/</span><br></pre></td></tr></table></figure></li><li><p>先创建 Go 的工作目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir ~/go</span><br></pre></td></tr></table></figure></li><li><p>配置环境变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ vi ~/.bashrc</span><br><span class="line">添加</span><br><span class="line">export GOROOT=/usr/local/go</span><br><span class="line">export GOPATH=/home/user1/go</span><br><span class="line">export PATH=$PATH:$GOROOT/bin:$GOPATH/bin</span><br></pre></td></tr></table></figure><p>保存并使生效：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ source ~/.bashrc</span><br></pre></td></tr></table></figure></li><li><p>测试 Go 的 demo 程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/go</span><br><span class="line"></span><br><span class="line">$ vi hello.go</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">fmt.Printf(&quot;hello world\n&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ go build hello.go</span><br><span class="line"></span><br><span class="line">$ ls</span><br><span class="line">hello  hello.go</span><br><span class="line"></span><br><span class="line">$ ./hello</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure></li></ul><h3 id="6-Fabric-源码下载"><a href="#6-Fabric-源码下载" class="headerlink" title="6. Fabric 源码下载"></a>6. Fabric 源码下载</h3><ul><li><p>首先创建存放源码的文件夹：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir -p ~/go/src/github.com/hyperledger</span><br></pre></td></tr></table></figure></li><li><p>使用 Git 下载完整源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/hyperledger/fabric.git</span><br></pre></td></tr></table></figure></li><li><p>进入 fabric 目录查看版本分支并切换分支：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cd fabric</span><br><span class="line">$ git branch</span><br><span class="line">* release-1.2</span><br><span class="line">$ git checkout v1.0.0</span><br></pre></td></tr></table></figure></li><li><p>最后再解决 <code>examples/e2e_cli/base/peer-base.yaml</code> 文件中的一个小 bug：</p><p>将 <code>CORE_VM_DOCKER_HOSTCONFIG_NETWORKMODE</code> 环境变量的值修改为 <code>e2e_cli_default</code>，而不是原来的 <code>e2ecli_default</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- CORE_VM_DOCKER_HOSTCONFIG_NETWORKMODE=e2e_cli_default</span><br></pre></td></tr></table></figure><p>不然在启动 Fabric 网络时会出现问题。</p></li></ul><h3 id="7-启动其他节点"><a href="#7-启动其他节点" class="headerlink" title="7. 启动其他节点"></a>7. 启动其他节点</h3><p>将刚才配置好的虚拟机镜像拷贝四份，并基于这些镜像启动 5 台虚拟机，主机名分别设置为：</p><ul><li><code>orderer.example.com</code> </li><li><code>peer0.org1.example.com</code> </li><li><code>peer1.org1.example.com</code> </li><li><code>peer0.org2.example.com</code> </li><li><code>peer1.org2.example.com</code> </li></ul><h3 id="8-docker-compose-配置文件准备"><a href="#8-docker-compose-配置文件准备" class="headerlink" title="8. docker-compose 配置文件准备"></a>8. docker-compose 配置文件准备</h3><p>在 fabric 的源码中，提供了单机部署的 4 Peer+1 Orderer的示例，在 example/e2e_cli 文件夹下。我们将登录到 <code>orderer.example.com</code> 节点，生成公私钥，修改 docker-compose 配置文件，然后将 e2e_cli 整个文件夹分发到 Peer 节点，再分别登录到不同的 Peer 节点完成少部分的个性化配置工作。</p><h4 id="8-1-生成公私钥、证书、创世区块等"><a href="#8-1-生成公私钥、证书、创世区块等" class="headerlink" title="8.1 生成公私钥、证书、创世区块等"></a>8.1 生成公私钥、证书、创世区块等</h4><p>公私钥和证书是用于 Server 和 Server 之间的安全通信，另外要创建 Channel 并让其他节点加入 Channel 就需要创世区块，这些必备文件都可以一个命令生成，官方已经给出了脚本： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./generateArtifacts.sh mychannel</span><br></pre></td></tr></table></figure><p>运行这个命令后，系统会创建 channel-artifacts 文件夹，里面包含了 mychannel 这个通道相关的文件，另外还有一个 crypto-config 文件夹，里面包含了各个节点的公私钥和证书的信息。 </p><h4 id="8-2-设置-Peer-节点的-docker-compose-文件"><a href="#8-2-设置-Peer-节点的-docker-compose-文件" class="headerlink" title="8.2 设置 Peer 节点的 docker-compose 文件"></a>8.2 设置 Peer 节点的 docker-compose 文件</h4><p>e2e_cli 中提供了多个yaml文件，我们可以基于docker-compose-cli.yaml文件创建： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cp docker-compose-cli.yaml docker-compose-peer.yaml</span><br></pre></td></tr></table></figure><p>然后修改 docker-compose-peer.yaml，去掉 orderer 的配置，只保留一个 peer 和 cli，因为我们要多机部署，节点与节点之前又是通过主机名通讯，所以需要修改容器中的host文件，也就是 extra_hosts 设置，修改后的peer配置如下： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">peer0.org1.example.com:</span><br><span class="line">  container_name: peer0.org1.example.com</span><br><span class="line">  extends:</span><br><span class="line">    file:  base/docker-compose-base.yaml</span><br><span class="line">    service: peer0.org1.example.com</span><br><span class="line">  extra_hosts:</span><br><span class="line">   - &quot;orderer.example.com:192.168.1.130&quot;</span><br></pre></td></tr></table></figure><p>同样，cli也需要能够和各个节点通讯，所以cli下面也需要添加 extra_hosts 设置，去掉无效的依赖，并且去掉command 这一行，因为我们是每个 peer 都会有个对应的客户端，也就是 cli，所以我只需要去手动执行一次命令，而不是自动运行。修改后的cli配置如下： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">cli:</span><br><span class="line">  container_name: cli</span><br><span class="line">  image: hyperledger/fabric-tools</span><br><span class="line">  tty: true</span><br><span class="line">  environment:</span><br><span class="line">    - GOPATH=/opt/gopath</span><br><span class="line">    - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock</span><br><span class="line">    - CORE_LOGGING_LEVEL=DEBUG</span><br><span class="line">    - CORE_PEER_ID=cli</span><br><span class="line">    - CORE_PEER_ADDRESS=peer0.org1.example.com:7051</span><br><span class="line">    - CORE_PEER_LOCALMSPID=Org1MSP</span><br><span class="line">    - CORE_PEER_TLS_ENABLED=true</span><br><span class="line">    - CORE_PEER_TLS_CERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/server.crt</span><br><span class="line">    - CORE_PEER_TLS_KEY_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/server.key</span><br><span class="line">    - CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt</span><br><span class="line">    - CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp</span><br><span class="line">  working_dir: /opt/gopath/src/github.com/hyperledger/fabric/peer</span><br><span class="line">  volumes:</span><br><span class="line">      - /var/run/:/host/var/run/</span><br><span class="line">      - ../chaincode/go/:/opt/gopath/src/github.com/hyperledger/fabric/examples/chaincode/go</span><br><span class="line">      - ./crypto-config:/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/</span><br><span class="line">      - ./scripts:/opt/gopath/src/github.com/hyperledger/fabric/peer/scripts/</span><br><span class="line">      - ./channel-artifacts:/opt/gopath/src/github.com/hyperledger/fabric/peer/channel-artifacts</span><br><span class="line">  depends_on:</span><br><span class="line">    - peer0.org1.example.com</span><br><span class="line">  extra_hosts:</span><br><span class="line">   - &quot;orderer.example.com:192.168.1.130&quot;</span><br><span class="line">   - &quot;peer0.org1.example.com:192.168.1.188&quot;</span><br><span class="line">   - &quot;peer1.org1.example.com:192.168.1.186&quot;</span><br><span class="line">   - &quot;peer0.org2.example.com:192.168.1.193&quot;</span><br><span class="line">   - &quot;peer1.org2.example.com:192.168.1.112&quot;</span><br></pre></td></tr></table></figure><p>在单机模式下，4个peer会映射主机不同的端口，但是我们在多机部署的时候是不需要映射不同端口的，所以需要修改 base/docker-compose-base.yaml 文件，将所有 peer 的端口映射都改为相同的： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ports: </span><br><span class="line">  - 7051:7051 </span><br><span class="line">  - 7052:7052 </span><br><span class="line">  - 7053:7053</span><br></pre></td></tr></table></figure><h4 id="8-3-设置-Orderer-节点的-docker-compose-文件"><a href="#8-3-设置-Orderer-节点的-docker-compose-文件" class="headerlink" title="8.3 设置 Orderer 节点的 docker-compose 文件"></a>8.3 设置 Orderer 节点的 docker-compose 文件</h4><p>与创建peer的配置文件类似，我们也复制一个yaml文件出来进行修改： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cp docker-compose-cli.yaml docker-compose-orderer.yaml</span><br></pre></td></tr></table></figure><p>orderer 服务器上我们只需要保留 order 设置，其他 peer 和 cli 设置都可以删除。orderer 可以不设置 extra_hosts。 </p><h4 id="8-4-分发配置文件"><a href="#8-4-分发配置文件" class="headerlink" title="8.4 分发配置文件"></a>8.4 分发配置文件</h4><p>前面 3 步操作，都是在 <code>orderer.example.com</code>上完成的，接下来我们需要将这些文件分发到另外4台服务器上。Linux 之间的文件传输，我们可以使用 scp 命令。 peer 节点上已经存在了 e2e_cli 文件夹，使用 scp 命令发送时会直接覆盖。在 <code>orderer.example.com</code> 节点的 fabric 的根目录下的 examples 目录下执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ scp -r e2e_cli/ user1@192.168.1.188:/home/user1/go/src/github.com/hyperledger/fabric/examples</span><br><span class="line">$ scp -r e2e_cli/ user1@192.168.1.186:/home/user1/go/src/github.com/hyperledger/fabric/examples</span><br><span class="line">$ scp -r e2e_cli/ user1@192.168.1.193:/home/user1/go/src/github.com/hyperledger/fabric/examples</span><br><span class="line">$ scp -r e2e_cli/ user1@192.168.1.112:/home/user1/go/src/github.com/hyperledger/fabric/examples</span><br></pre></td></tr></table></figure><h4 id="8-5-Peer-节点的个性化配置"><a href="#8-5-Peer-节点的个性化配置" class="headerlink" title="8.5 Peer 节点的个性化配置"></a>8.5 Peer 节点的个性化配置</h4><p>因为之前配置的就是<code>peer0.org1.example.com</code> 节点，所以复制到<code>peer0.org1.example.com</code> 后不需要做任何修改。</p><p>复制到 <code>peer1.org1.example.com</code> 上，我们需要对 docker-compose-peer.yaml 做一个小小的修改，将启动的容器改为 <code>peer1.org1.example.com</code>，并且添加 <code>peer0.org1.example.com</code> 的 IP 映射，对应的 cli 中也改成对 <code>peer1.org1.example.com</code> 的依赖。这是修改后的 <code>peer1.org1.example.com</code> 上的配置文件： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">version: &apos;2&apos;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">  peer1.org1.example.com:</span><br><span class="line">    container_name: peer1.org1.example.com</span><br><span class="line">    extends:</span><br><span class="line">      file:  base/docker-compose-base.yaml</span><br><span class="line">      service: peer1.org1.example.com</span><br><span class="line">    extra_hosts:</span><br><span class="line">     - &quot;orderer.example.com:192.168.1.130&quot;</span><br><span class="line">     - &quot;peer0.org1.example.com:192.168.1.188&quot;</span><br><span class="line"></span><br><span class="line">  cli:</span><br><span class="line">    container_name: cli</span><br><span class="line">    image: hyperledger/fabric-tools</span><br><span class="line">    tty: true</span><br><span class="line">    environment:</span><br><span class="line">      - GOPATH=/opt/gopath</span><br><span class="line">      - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock</span><br><span class="line">      - CORE_LOGGING_LEVEL=DEBUG</span><br><span class="line">      - CORE_PEER_ID=cli</span><br><span class="line">      - CORE_PEER_ADDRESS=peer1.org1.example.com:7051</span><br><span class="line">      - CORE_PEER_LOCALMSPID=Org1MSP</span><br><span class="line">      - CORE_PEER_TLS_ENABLED=true</span><br><span class="line">      - CORE_PEER_TLS_CERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer1.org1.example.com/tls/server.crt</span><br><span class="line">      - CORE_PEER_TLS_KEY_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer1.org1.example.com/tls/server.key</span><br><span class="line">      - CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer1.org1.example.com/tls/ca.crt</span><br><span class="line">      - CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp</span><br><span class="line">    working_dir: /opt/gopath/src/github.com/hyperledger/fabric/peer</span><br><span class="line">    volumes:</span><br><span class="line">        - /var/run/:/host/var/run/</span><br><span class="line">        - ../chaincode/go/:/opt/gopath/src/github.com/hyperledger/fabric/examples/chaincode/go</span><br><span class="line">        - ./crypto-config:/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/</span><br><span class="line">        - ./scripts:/opt/gopath/src/github.com/hyperledger/fabric/peer/scripts/</span><br><span class="line">        - ./channel-artifacts:/opt/gopath/src/github.com/hyperledger/fabric/peer/channel-artifacts</span><br><span class="line">    depends_on:</span><br><span class="line">      - peer1.org1.example.com</span><br><span class="line">    extra_hosts:</span><br><span class="line">     - &quot;orderer.example.com:192.168.1.130&quot;</span><br><span class="line">     - &quot;peer0.org1.example.com:192.168.1.188&quot;</span><br><span class="line">     - &quot;peer1.org1.example.com:192.168.1.186&quot;</span><br><span class="line">     - &quot;peer0.org2.example.com:192.168.1.193&quot;</span><br><span class="line">     - &quot;peer1.org2.example.com:192.168.1.112&quot;</span><br></pre></td></tr></table></figure><p><code>peer0.org2.example.com</code> 和 <code>peer0.org2.example.com</code>  节点上面的 docker-compose-peer.yaml 也是同理修改。</p><blockquote><p>注意需要修改组织相关的信息。</p></blockquote><hr><h3 id="9-启动-Fabric"><a href="#9-启动-Fabric" class="headerlink" title="9. 启动 Fabric"></a>9. 启动 Fabric</h3><p>现在所有文件都已经准备完毕，我们可以启动我们的Fabric网络了。 </p><h4 id="9-1-启动-Orderer"><a href="#9-1-启动-Orderer" class="headerlink" title="9.1 启动 Orderer"></a>9.1 启动 Orderer</h4><p>让我们首先来启动orderer节点，在orderer服务器上运行： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose -f docker-compose-orderer.yaml up –d</span><br></pre></td></tr></table></figure><p>运行完毕后我们可以使用 <code>docker ps</code> 看到运行了一个名字为 <code>orderer.example.com</code> 的节点。 </p><h4 id="9-2-启动-peer"><a href="#9-2-启动-peer" class="headerlink" title="9.2 启动 peer"></a>9.2 启动 peer</h4><p>然后我们切换到 <code>peer0.org1.example.com</code> 服务器，启动本服务器的 peer 节点和 cli，命令为： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose -f docker-compose-peer.yaml up –d</span><br></pre></td></tr></table></figure><p>运行完毕后我们使用docker ps应该可以看到2个正在运行的容器。 </p><p>接下来依次在另外 3 台服务器运行启动peer节点容器的命令。</p><p>现在我们整个Fabric4+1服务器网络已经成型，接下来是创建channel和运行ChainCode。 </p><h4 id="9-3-创建-Channel-测试-Chaincode"><a href="#9-3-创建-Channel-测试-Chaincode" class="headerlink" title="9.3 创建 Channel 测试 Chaincode"></a>9.3 创建 Channel 测试 Chaincode</h4><p>我们切换到 <code>peer0.org1.example.com</code> 服务器上，使用该服务器上的 cli 来运行创建 Channel 和运行 ChainCode 的操作。首先进入cli 容器： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker exec -it cli bash</span><br></pre></td></tr></table></figure><p>进入容器后我们可以看到命令提示变为： </p><p><u>root@ad739321be2a:/opt/gopath/src/github.com/hyperledger/fabric/peer#</u></p><p>说明我们已经以 root 的身份进入到 cli 容器内部。官方已经提供了完整的创建 Channel 和测试 ChainCode 的脚本，并且已经映射到 cli 容器内部，所以我们只需要在 cli 内运行如下命令： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./scripts/script.sh mychannel</span><br></pre></td></tr></table></figure><p>那么该脚本就可以一步一步的完成创建通道，将其他节点加入通道，更新锚节点，创建 ChainCode，初始化账户，查询，转账，再次查询等链上代码的各个操作都可以自动化实现。直到最后，系统提示： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">===================== All GOOD, End-2-End execution completed =====================</span><br></pre></td></tr></table></figure><p>说明我们的 4+1 的 Fabric 多机部署成功了。 </p><hr>]]></content>
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hyperledger fabric </tag>
            
            <tag> Docker </tag>
            
            <tag> Docker Compose </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Fabric e2e_cli 案例流程分析</title>
      <link href="/2018/08/30/Fabric%E6%A1%88%E4%BE%8B%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/"/>
      <url>/2018/08/30/Fabric%E6%A1%88%E4%BE%8B%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<h1 id="0-Fabric-e2e-cli-案例的运行流程"><a href="#0-Fabric-e2e-cli-案例的运行流程" class="headerlink" title="0. Fabric e2e_cli 案例的运行流程"></a>0. Fabric e2e_cli 案例的运行流程</h1><p>在部署好 Hyperledger Fabric v1.0.0 的环境之后，我们通常会运行其 e2e_cli 的案例。在 <code>fabric/examples/e2e_cli</code> 目录下有一个 shell 脚本：<code>network_setup.sh</code>，这就是 e2e_cli 项目的入口，运行 <code>./network_setup.sh up</code> 即可启动 fabric 的网络并完成相关的测试，然后运行 <code>./network_setup.sh down</code> 可以删除相关的容器以及文件来结束测试。下面我们就来分析 e2e_cli 案例的运行流程。</p><a id="more"></a><p>首先看看 network_setup.sh 的具体内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">#</span><br><span class="line"># Copyright IBM Corp. All Rights Reserved.</span><br><span class="line">#</span><br><span class="line"># SPDX-License-Identifier: Apache-2.0</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line">UP_DOWN=&quot;$1&quot;</span><br><span class="line">CH_NAME=&quot;$2&quot;</span><br><span class="line">CLI_TIMEOUT=&quot;$3&quot;</span><br><span class="line">IF_COUCHDB=&quot;$4&quot;</span><br><span class="line"></span><br><span class="line">: $&#123;CLI_TIMEOUT:=&quot;10000&quot;&#125;</span><br><span class="line"></span><br><span class="line">COMPOSE_FILE=docker-compose-cli.yaml</span><br><span class="line">COMPOSE_FILE_COUCH=docker-compose-couch.yaml</span><br><span class="line">#COMPOSE_FILE=docker-compose-e2e.yaml</span><br><span class="line"></span><br><span class="line">function printHelp () &#123;</span><br><span class="line">echo &quot;Usage: ./network_setup &lt;up|down&gt; &lt;\$channel-name&gt; &lt;\$cli_timeout&gt; &lt;couchdb&gt;.\nThe arguments must be in order.&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function validateArgs () &#123;</span><br><span class="line">if [ -z &quot;$&#123;UP_DOWN&#125;&quot; ]; then</span><br><span class="line">echo &quot;Option up / down / restart not mentioned&quot;</span><br><span class="line">printHelp</span><br><span class="line">exit 1</span><br><span class="line">fi</span><br><span class="line">if [ -z &quot;$&#123;CH_NAME&#125;&quot; ]; then</span><br><span class="line">echo &quot;setting to default channel &apos;mychannel&apos;&quot;</span><br><span class="line">CH_NAME=mychannel</span><br><span class="line">fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function clearContainers () &#123;</span><br><span class="line">        CONTAINER_IDS=$(docker ps -aq)</span><br><span class="line">        if [ -z &quot;$CONTAINER_IDS&quot; -o &quot;$CONTAINER_IDS&quot; = &quot; &quot; ]; then</span><br><span class="line">                echo &quot;---- No containers available for deletion ----&quot;</span><br><span class="line">        else</span><br><span class="line">                docker rm -f $CONTAINER_IDS</span><br><span class="line">        fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function removeUnwantedImages() &#123;</span><br><span class="line">        DOCKER_IMAGE_IDS=$(docker images | grep &quot;dev\|none\|test-vp\|peer[0-9]-&quot; | awk &apos;&#123;print $3&#125;&apos;)</span><br><span class="line">        if [ -z &quot;$DOCKER_IMAGE_IDS&quot; -o &quot;$DOCKER_IMAGE_IDS&quot; = &quot; &quot; ]; then</span><br><span class="line">                echo &quot;---- No images available for deletion ----&quot;</span><br><span class="line">        else</span><br><span class="line">                docker rmi -f $DOCKER_IMAGE_IDS</span><br><span class="line">        fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function networkUp () &#123;</span><br><span class="line">    if [ -f &quot;./crypto-config&quot; ]; then</span><br><span class="line">      echo &quot;crypto-config directory already exists.&quot;</span><br><span class="line">    else</span><br><span class="line">      #Generate all the artifacts that includes org certs, orderer genesis block,</span><br><span class="line">      # channel configuration transaction</span><br><span class="line">      source generateArtifacts.sh $CH_NAME</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    if [ &quot;$&#123;IF_COUCHDB&#125;&quot; == &quot;couchdb&quot; ]; then</span><br><span class="line">      CHANNEL_NAME=$CH_NAME TIMEOUT=$CLI_TIMEOUT docker-compose -f $COMPOSE_FILE -f $COMPOSE_FILE_COUCH up -d 2&gt;&amp;1</span><br><span class="line">    else</span><br><span class="line">      CHANNEL_NAME=$CH_NAME TIMEOUT=$CLI_TIMEOUT docker-compose -f $COMPOSE_FILE up -d 2&gt;&amp;1</span><br><span class="line">    fi</span><br><span class="line">    if [ $? -ne 0 ]; then</span><br><span class="line">echo &quot;ERROR !!!! Unable to pull the images &quot;</span><br><span class="line">exit 1</span><br><span class="line">    fi</span><br><span class="line">    docker logs -f cli</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function networkDown () &#123;</span><br><span class="line">    docker-compose -f $COMPOSE_FILE down</span><br><span class="line"></span><br><span class="line">    #Cleanup the chaincode containers</span><br><span class="line">    clearContainers</span><br><span class="line"></span><br><span class="line">    #Cleanup images</span><br><span class="line">    removeUnwantedImages</span><br><span class="line"></span><br><span class="line">    # remove orderer block and other channel configuration transactions and certs</span><br><span class="line">    rm -rf channel-artifacts/*.block channel-artifacts/*.tx crypto-config</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">validateArgs</span><br><span class="line"></span><br><span class="line">#Create the network using docker compose</span><br><span class="line">if [ &quot;$&#123;UP_DOWN&#125;&quot; == &quot;up&quot; ]; then</span><br><span class="line">networkUp</span><br><span class="line">elif [ &quot;$&#123;UP_DOWN&#125;&quot; == &quot;down&quot; ]; then ## Clear the network</span><br><span class="line">networkDown</span><br><span class="line">elif [ &quot;$&#123;UP_DOWN&#125;&quot; == &quot;restart&quot; ]; then ## Restart the network</span><br><span class="line">networkDown</span><br><span class="line">networkUp</span><br><span class="line">else</span><br><span class="line">printHelp</span><br><span class="line">exit 1</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><hr><h1 id="1-启动过程"><a href="#1-启动过程" class="headerlink" title="1. 启动过程"></a>1. 启动过程</h1><h2 id="1-1-network-setup-sh-参数设置"><a href="#1-1-network-setup-sh-参数设置" class="headerlink" title="1.1  network_setup.sh 参数设置"></a>1.1  network_setup.sh 参数设置</h2><ol><li><p>传入参数</p><p>在运行 <code>./network_setup.sh up</code> 启动的时候，我们传入了 <code>up</code> 这个参数，使得内置的 <strong>UP_DOWN</strong> 参数设置成了 up，也就是确定执行类型为启动 fabric 网络，但其实该脚本还允许传入 3 个参数，分别是 <strong>CH_NAME</strong>（通道名称，默认设为 ”mychannel“）、<strong>CLI_TIMEOUT</strong>（客户端超时设置，默认设为 10000）和 <strong>IF_COUCHDB</strong>（是否启动 CouchDB 版本 yaml 文件，默认为不启用）。</p></li><li><p>验证参数：<strong>validateArgs</strong></p><p>在 <code>network_setup.sh</code> 脚本 88 行左右，调用了 <code>validateArgs</code> 函数来验证参数是否合法，如果不合法，也就是没有指定 <code>up/down/restart</code>，会打印帮助信息并退出脚本；如果合法，<code>$UP_DOWN</code> 设置合法，则判断是否指定 <code>$CH_NAME</code>，没有指定则设置为默认的 <code>mychannel</code>。</p></li></ol><hr><h2 id="1-2-启动网络：networkUp"><a href="#1-2-启动网络：networkUp" class="headerlink" title="1.2 启动网络：networkUp"></a>1.2 启动网络：networkUp</h2><ol><li><p>判断 crypto-config 目录是否存在</p><p>如果该目录不存在，会调用 generateArtifacts.sh 脚本创建 crypto-config 目录及所需的区块链网络整数等文件，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source generateArtifacts.sh $CH_NAME</span><br></pre></td></tr></table></figure><blockquote><p>详细请看 1.3 节</p></blockquote></li><li><p>判断是否启用 CouchDB</p><p>如果启用了 CouchDB，会执行以下 docker-compose 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CHANNEL_NAME=$CH_NAME TIMEOUT=$CLI_TIMEOUT docker-compose -f $COMPOSE_FILE -f $COMPOSE_FILE_COUCH up -d 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p>否则执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CHANNEL_NAME=$CH_NAME TIMEOUT=$CLI_TIMEOUT docker-compose -f $COMPOSE_FILE up -d 2&gt;&amp;1</span><br></pre></td></tr></table></figure><blockquote><p>详细请看 1.4 节</p></blockquote><p>最后会查看 cli 容器的日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs -f cli</span><br></pre></td></tr></table></figure><blockquote><p>详细请看 1.5 节</p></blockquote></li></ol><hr><h2 id="1-3-调用-generateArtifacts-sh"><a href="#1-3-调用-generateArtifacts-sh" class="headerlink" title="1.3 调用 generateArtifacts.sh"></a>1.3 调用 generateArtifacts.sh</h2><p>先看看 generateArtifacts.sh 脚本的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash +x</span><br><span class="line">#</span><br><span class="line"># Copyright IBM Corp. All Rights Reserved.</span><br><span class="line">#</span><br><span class="line"># SPDX-License-Identifier: Apache-2.0</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line">#set -e</span><br><span class="line"></span><br><span class="line">CHANNEL_NAME=$1</span><br><span class="line">: $&#123;CHANNEL_NAME:=&quot;mychannel&quot;&#125;</span><br><span class="line">echo $CHANNEL_NAME</span><br><span class="line"></span><br><span class="line">export FABRIC_ROOT=$PWD/../..</span><br><span class="line">export FABRIC_CFG_PATH=$PWD</span><br><span class="line">echo</span><br><span class="line"></span><br><span class="line">OS_ARCH=$(echo &quot;$(uname -s|tr &apos;[:upper:]&apos; &apos;[:lower:]&apos;|sed &apos;s/mingw64_nt.*/windows/&apos;)-$(uname -m | sed &apos;s/x86_64/amd64/g&apos;)&quot; | awk &apos;&#123;print tolower($0)&#125;&apos;)</span><br><span class="line"></span><br><span class="line">## Using docker-compose template replace private key file names with constants</span><br><span class="line">function replacePrivateKey () &#123;</span><br><span class="line">ARCH=`uname -s | grep Darwin`</span><br><span class="line">if [ &quot;$ARCH&quot; == &quot;Darwin&quot; ]; then</span><br><span class="line">OPTS=&quot;-it&quot;</span><br><span class="line">else</span><br><span class="line">OPTS=&quot;-i&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">cp docker-compose-e2e-template.yaml docker-compose-e2e.yaml</span><br><span class="line"></span><br><span class="line">        CURRENT_DIR=$PWD</span><br><span class="line">        cd crypto-config/peerOrganizations/org1.example.com/ca/</span><br><span class="line">        PRIV_KEY=$(ls *_sk)</span><br><span class="line">        cd $CURRENT_DIR</span><br><span class="line">        sed $OPTS &quot;s/CA1_PRIVATE_KEY/$&#123;PRIV_KEY&#125;/g&quot; docker-compose-e2e.yaml</span><br><span class="line">        cd crypto-config/peerOrganizations/org2.example.com/ca/</span><br><span class="line">        PRIV_KEY=$(ls *_sk)</span><br><span class="line">        cd $CURRENT_DIR</span><br><span class="line">        sed $OPTS &quot;s/CA2_PRIVATE_KEY/$&#123;PRIV_KEY&#125;/g&quot; docker-compose-e2e.yaml</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">## Generates Org certs using cryptogen tool</span><br><span class="line">function generateCerts ()&#123;</span><br><span class="line">CRYPTOGEN=$FABRIC_ROOT/release/$OS_ARCH/bin/cryptogen</span><br><span class="line"></span><br><span class="line">if [ -f &quot;$CRYPTOGEN&quot; ]; then</span><br><span class="line">            echo &quot;Using cryptogen -&gt; $CRYPTOGEN&quot;</span><br><span class="line">else</span><br><span class="line">    echo &quot;Building cryptogen&quot;</span><br><span class="line">    make -C $FABRIC_ROOT release</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">echo</span><br><span class="line">echo &quot;##########################################################&quot;</span><br><span class="line">echo &quot;##### Generate certificates using cryptogen tool #########&quot;</span><br><span class="line">echo &quot;##########################################################&quot;</span><br><span class="line">$CRYPTOGEN generate --config=./crypto-config.yaml</span><br><span class="line">echo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">## Generate orderer genesis block , channel configuration transaction and anchor peer update transactions</span><br><span class="line">function generateChannelArtifacts() &#123;</span><br><span class="line"></span><br><span class="line">CONFIGTXGEN=$FABRIC_ROOT/release/$OS_ARCH/bin/configtxgen</span><br><span class="line">if [ -f &quot;$CONFIGTXGEN&quot; ]; then</span><br><span class="line">            echo &quot;Using configtxgen -&gt; $CONFIGTXGEN&quot;</span><br><span class="line">else</span><br><span class="line">    echo &quot;Building configtxgen&quot;</span><br><span class="line">    make -C $FABRIC_ROOT release</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">echo &quot;##########################################################&quot;</span><br><span class="line">echo &quot;#########  Generating Orderer Genesis block ##############&quot;</span><br><span class="line">echo &quot;##########################################################&quot;</span><br><span class="line"># Note: For some unknown reason (at least for now) the block file can&apos;t be</span><br><span class="line"># named orderer.genesis.block or the orderer will fail to launch!</span><br><span class="line">$CONFIGTXGEN -profile TwoOrgsOrdererGenesis -outputBlock ./channel-artifacts/genesis.block</span><br><span class="line"></span><br><span class="line">echo</span><br><span class="line">echo &quot;#################################################################&quot;</span><br><span class="line">echo &quot;### Generating channel configuration transaction &apos;channel.tx&apos; ###&quot;</span><br><span class="line">echo &quot;#################################################################&quot;</span><br><span class="line">$CONFIGTXGEN -profile TwoOrgsChannel -outputCreateChannelTx ./channel-artifacts/channel.tx -channelID $CHANNEL_NAME</span><br><span class="line"></span><br><span class="line">echo</span><br><span class="line">echo &quot;#################################################################&quot;</span><br><span class="line">echo &quot;#######    Generating anchor peer update for Org1MSP   ##########&quot;</span><br><span class="line">echo &quot;#################################################################&quot;</span><br><span class="line">$CONFIGTXGEN -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org1MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org1MSP</span><br><span class="line"></span><br><span class="line">echo</span><br><span class="line">echo &quot;#################################################################&quot;</span><br><span class="line">echo &quot;#######    Generating anchor peer update for Org2MSP   ##########&quot;</span><br><span class="line">echo &quot;#################################################################&quot;</span><br><span class="line">$CONFIGTXGEN -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org2MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org2MSP</span><br><span class="line">echo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">generateCerts</span><br><span class="line">replacePrivateKey</span><br><span class="line">generateChannelArtifacts</span><br></pre></td></tr></table></figure><p>脚本最后调用了三个函数：</p><ol><li><p><strong>generateCerts</strong></p><p>该函数首先判断 <code>fabric/release/linux-amd64/bin/cryptogen</code> 是否存在，如果不存在则先编译生成，这个是 Fabric 基于 Go 语言的 crypto 库提供的工具，通过 cryptogen 可以快速地根据配置自动批量生成所需要的密钥和证书文件。cryptogen 根据 crypto-config.yaml 文件读入网络的拓扑结构，执行的命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fabric/release/linux-amd64/bin/cryptogen generate --config=./crypto-config.yaml</span><br></pre></td></tr></table></figure><p>crypto-config.yaml 配置文件可以指定两类组织的信息：</p><ul><li>OrdererOrgs：构成 Orderer 集群的节点所属组织；</li><li>PeerOrgs：构成 Peer 集群的节点所属的组织</li></ul><p>每个组织拥有：</p><ul><li>名称（name）：组织的名称；</li><li>组织域（Domain）：组织的命名域；</li><li>CA：组织的 CA 地址，包括 Hostname 域；</li><li>若干节点（Node）：一个节点包括 Hostname、CommonName、SANS 等域，可以用 Specs 字段指定一组节点，或者用 Template 字段指定自动生成节点的个数；</li><li>用户（User）模板：自动生成除 admin 外的用户个数。</li></ul><p>示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">OrdererOrgs:</span><br><span class="line">  - Name: Orderer</span><br><span class="line">    Domain: example.com</span><br><span class="line">    Specs:</span><br><span class="line">      - Hostname: orderer</span><br><span class="line">PeerOrgs:</span><br><span class="line">  - Name: Org1</span><br><span class="line">    Domain: org1.example.com</span><br><span class="line">    Template:</span><br><span class="line">      Count: 2</span><br><span class="line">    Users:</span><br><span class="line">      Count: 1</span><br><span class="line">  - Name: Org2</span><br><span class="line">    Domain: org2.example.com</span><br><span class="line">    Template:</span><br><span class="line">      Count: 2</span><br><span class="line">    Users:</span><br><span class="line">      Count: 1</span><br></pre></td></tr></table></figure><p>上面的示例配置中，Orderer 组织通过 Specs 字段指定了一个主机 order.example.com；而两个 Peer 组织则采用 Template 来自动生成了 Count 个数的主机。</p><p>同样，Users 字段下的 Count 字段值会让 cryptogen 工具以自动顺序生成指定个数的普通用户（除默认的 Admin 用户外）。</p></li><li><p><strong>replacePrivatekey</strong></p><p>在这个函数中，会替换 docker-compose-e2e-template.yaml 文件中的 CA1_PRIVATE_KEY 为当前目录 crypto-config/peerOrganizationsorg1.example.com/ca/ 下的以 <code>_sk</code> 结尾的文件名，同时替换 CA2_PRIVATE_KEY 为当前目录crypto-config/peerOrganizationsorg2.example.com/ca/ 下的以 <code>_sk</code> 结尾的文件名。</p><p>最终生成的新文件被创建在当前文件夹下并命名为 docker-compose-e2e.yaml，在该文件中定义了 CA 的 CERTFILE 及 KEYFILE，同时也通过 command 内置参数显示启动了 Fabric-CA 服务端。</p><blockquote><p>其实在后续的过程中并没有使用这里生成的这个 docker-compose-e2e.yaml 配置文件，而使用的是 docker-compose-cli.yaml，在 network_setup.sh 脚本中的 COMPOSE_FILE 变量指定了要使用的配置文件，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; COMPOSE_FILE=docker-compose-cli.yaml</span><br><span class="line">&gt; #COMPOSE_FILE=docker-compose-e2e.yaml</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></li><li><p><strong>generateChannelArtifacts</strong></p><p>这个函数首先判断 <code>fabric/release/linux-amd64/bin/configtxgen</code> 是否存在，如果不存在则先编译生成。configtxgen 可以配合 cryptogen 生成的组织结构身份文件使用，离线生成跟通道有关的配置信息，<strong>其主要功能有如下三个：</strong></p><ul><li>生成启动 Orderer 需要的初始化区块，并支持检查区块内容；</li><li>生成创建应用通道需要的配置交易，并支持检查交易内容；</li><li>生成 2 个锚节点 Peer 的更新配置交易。</li></ul><p>configtxgen 调用的配置文件为 configtx.yaml ，<strong>该配置文件一般包括四个部分：</strong></p><ul><li>Profiles：一系列通道配置模板，包括 Orderer 系统通道模板和应用通道类型模板；</li><li>Organization：一系列组织结构定义，被其他部分引用；</li><li>Orderer：Orderer 系统通道相关配置，包括 Orderer 服务配置和参与 Ordering 服务的可用组织信息；</li><li>Application：应用通道相关配置，主要包括参与应用网络的可用组织信息。</li></ul><p>调用该函数最终在 channel-artifacts 目录下<strong>生成了四个文件</strong>，对应于上述的三个功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.tx    genesis.block    Org1MSPanchors.tx    Org2MSPanchors.tx</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="1-4-docker-compose-启动容器服务"><a href="#1-4-docker-compose-启动容器服务" class="headerlink" title="1.4 docker-compose 启动容器服务"></a>1.4 docker-compose 启动容器服务</h2><p>如 1.2 节所述，默认情况下，会执行以下命令<strong>启动容器服务：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CHANNEL_NAME=$CH_NAME TIMEOUT=$CLI_TIMEOUT docker-compose -f $COMPOSE_FILE up -d 2&gt;&amp;1</span><br></pre></td></tr></table></figure><blockquote><p>其中变量的值为： CHANNEL_NAME=mychannel，TIMEOUT=10000，COMPOSE_FILE=docker-compose-cli.yaml。</p><p>-d：指定在后台运行容器；</p><p>2&gt;&amp;1：指定同时重定向标准输出（stdout）与标准错误（stderr）</p></blockquote><p>容器启动配置文件 docker-compose-cli.yaml 的内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"># Copyright IBM Corp. All Rights Reserved.</span><br><span class="line">#</span><br><span class="line"># SPDX-License-Identifier: Apache-2.0</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line">version: &apos;2&apos;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">  orderer.example.com:</span><br><span class="line">    extends:</span><br><span class="line">      file:   base/docker-compose-base.yaml</span><br><span class="line">      service: orderer.example.com</span><br><span class="line">    container_name: orderer.example.com</span><br><span class="line"></span><br><span class="line">  peer0.org1.example.com:</span><br><span class="line">    container_name: peer0.org1.example.com</span><br><span class="line">    extends:</span><br><span class="line">      file:  base/docker-compose-base.yaml</span><br><span class="line">      service: peer0.org1.example.com</span><br><span class="line"></span><br><span class="line">  peer1.org1.example.com:</span><br><span class="line">    container_name: peer1.org1.example.com</span><br><span class="line">    extends:</span><br><span class="line">      file:  base/docker-compose-base.yaml</span><br><span class="line">      service: peer1.org1.example.com</span><br><span class="line"></span><br><span class="line">  peer0.org2.example.com:</span><br><span class="line">    container_name: peer0.org2.example.com</span><br><span class="line">    extends:</span><br><span class="line">      file:  base/docker-compose-base.yaml</span><br><span class="line">      service: peer0.org2.example.com</span><br><span class="line"></span><br><span class="line">  peer1.org2.example.com:</span><br><span class="line">    container_name: peer1.org2.example.com</span><br><span class="line">    extends:</span><br><span class="line">      file:  base/docker-compose-base.yaml</span><br><span class="line">      service: peer1.org2.example.com</span><br><span class="line"></span><br><span class="line">  cli:</span><br><span class="line">    container_name: cli</span><br><span class="line">    image: hyperledger/fabric-tools</span><br><span class="line">    tty: true</span><br><span class="line">    environment:</span><br><span class="line">      - GOPATH=/opt/gopath</span><br><span class="line">      - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock</span><br><span class="line">      - CORE_LOGGING_LEVEL=DEBUG</span><br><span class="line">      - CORE_PEER_ID=cli</span><br><span class="line">      - CORE_PEER_ADDRESS=peer0.org1.example.com:7051</span><br><span class="line">      - CORE_PEER_LOCALMSPID=Org1MSP</span><br><span class="line">      - CORE_PEER_TLS_ENABLED=true</span><br><span class="line">      - CORE_PEER_TLS_CERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/server.crt</span><br><span class="line">      - CORE_PEER_TLS_KEY_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/server.key</span><br><span class="line">      - CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt</span><br><span class="line">      - CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp</span><br><span class="line">    working_dir: /opt/gopath/src/github.com/hyperledger/fabric/peer</span><br><span class="line">    command: /bin/bash -c &apos;./scripts/script.sh $&#123;CHANNEL_NAME&#125;; sleep $TIMEOUT&apos;</span><br><span class="line">    volumes:</span><br><span class="line">        - /var/run/:/host/var/run/</span><br><span class="line">        - ../chaincode/go/:/opt/gopath/src/github.com/hyperledger/fabric/examples/chaincode/go</span><br><span class="line">        - ./crypto-config:/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/</span><br><span class="line">        - ./scripts:/opt/gopath/src/github.com/hyperledger/fabric/peer/scripts/</span><br><span class="line">        - ./channel-artifacts:/opt/gopath/src/github.com/hyperledger/fabric/peer/channel-artifacts</span><br><span class="line">    depends_on:</span><br><span class="line">      - orderer.example.com</span><br><span class="line">      - peer0.org1.example.com</span><br><span class="line">      - peer1.org1.example.com</span><br><span class="line">      - peer0.org2.example.com</span><br><span class="line">      - peer1.org2.example.com</span><br></pre></td></tr></table></figure><p>从配置文件不难看出，排序服务节点继承了 base/docker-compose-base.yaml 中的 order.example.com 属性；而其他四个 Peer 节点继承了 base/docker-compose-base.yaml 中的与之容器名称对应的属性，并又都继承了 base/peer-base.yaml 中的属性。</p><p>在上述文件所继承的文件属性中，关键属性如下：</p><ul><li>environment：当前所配置的外界的环境变量</li><li>working_dir：当前容器启动后的工作路径</li><li>volumes：外界物理机路径挂载或指引到容器内的路径</li><li>ports：指定当前容器启动后映射到物理机上的端口号</li><li>depends_on：指定当前容器启动所依赖的启动容器对象</li></ul><p>在 docker-compose-cli.yaml 文件中，官方的节点配置信息基本已经满足实际生产应用，而真正使用这些服务节点进行数据维护和管理的则是交由客户端或 SDK 来执行。这里也就是配置文件中的 cli 客户端容器。cli 容器的 command 属性指定当 cli 容器启动后会执行当前目录中的 scripts 目录下的 script.sh 脚本，也就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/bash -c &apos;./scripts/script.sh $&#123;CHANNEL_NAME&#125;; sleep $TIMEOUT&apos;</span><br></pre></td></tr></table></figure><blockquote><p>在 1.5 节中将会分析 cli 容器执行上述脚本的日志记录。</p></blockquote><hr><h2 id="1-5-docker-logs-f-cli-查看容器日志"><a href="#1-5-docker-logs-f-cli-查看容器日志" class="headerlink" title="1.5 docker logs -f cli 查看容器日志"></a>1.5 docker logs -f cli 查看容器日志</h2><p>script.sh 脚本的执行则是 e2e_cli 中真正地对 Peer 节点、频道以及合约的集合操作演示，先来看看该脚本内的函数执行顺序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">## Create channel</span><br><span class="line">echo &quot;Creating channel...&quot;</span><br><span class="line">createChannel</span><br><span class="line"></span><br><span class="line">## Join all the peers to the channel</span><br><span class="line">echo &quot;Having all peers join the channel...&quot;</span><br><span class="line">joinChannel</span><br><span class="line"></span><br><span class="line">## Set the anchor peers for each org in the channel</span><br><span class="line">echo &quot;Updating anchor peers for org1...&quot;</span><br><span class="line">updateAnchorPeers 0</span><br><span class="line">echo &quot;Updating anchor peers for org2...&quot;</span><br><span class="line">updateAnchorPeers 2</span><br><span class="line"></span><br><span class="line">## Install chaincode on Peer0/Org1 and Peer2/Org2</span><br><span class="line">echo &quot;Installing chaincode on org1/peer0...&quot;</span><br><span class="line">installChaincode 0</span><br><span class="line">echo &quot;Install chaincode on org2/peer2...&quot;</span><br><span class="line">installChaincode 2</span><br><span class="line"></span><br><span class="line">#Instantiate chaincode on Peer2/Org2</span><br><span class="line">echo &quot;Instantiating chaincode on org2/peer2...&quot;</span><br><span class="line">instantiateChaincode 2</span><br><span class="line"></span><br><span class="line">#Query on chaincode on Peer0/Org1</span><br><span class="line">echo &quot;Querying chaincode on org1/peer0...&quot;</span><br><span class="line">chaincodeQuery 0 100</span><br><span class="line"></span><br><span class="line">#Invoke on chaincode on Peer0/Org1</span><br><span class="line">echo &quot;Sending invoke transaction on org1/peer0...&quot;</span><br><span class="line">chaincodeInvoke 0</span><br><span class="line"></span><br><span class="line">## Install chaincode on Peer2/Org2</span><br><span class="line">echo &quot;Installing chaincode on org2/peer3...&quot;</span><br><span class="line">installChaincode 3</span><br><span class="line"></span><br><span class="line">#Query on chaincode on Peer2/Org2, check if the result is 90</span><br><span class="line">echo &quot;Querying chaincode on org2/peer3...&quot;</span><br><span class="line">chaincodeQuery 3 90</span><br></pre></td></tr></table></figure><p>该脚本设计 Peer 节点及排序服务节点的操作分别有如下九个步骤：</p><ol><li><strong>createChannel</strong>：根据之前在 generateArtifacts.sh 脚本中通过 configtx.yaml 配置文件生成的频道文件创建频道；</li><li><strong>joinChannel</strong>：Peer 节点加入指定频道；</li><li><strong>updateAnchorPeers 0/2</strong>：为频道中的每个组织设置 Peer 节点；</li><li><strong>installChaincode 0/2</strong>：在 Peer0/Org1 和 Peer0/Org2 上安装智能合约；</li><li><strong>instantiateChaincode 2</strong>：在 Peer0/Org2 上对智能合约进行实例化操作；</li><li><strong>chaincodeQuery 0 100</strong>：在 Peer0/Org1 上执行智能合约中的查询方法，判断是否等于 100；</li><li><strong>chaincodeInvoke 0</strong>：在 Peer0/Org1 上执行智能合约中的交易方法；</li><li><strong>installChaincode 3</strong>：在 Peer1/Org2 上安装智能合约；</li><li><strong>chaincodeQuery 3 90</strong>：在 Peer1/Org2 上执行智能合约中的查询方法，判断是否等于 90； </li></ol><blockquote><p><strong>注：</strong>这里需要说明的是脚本中最后两步的注释以及回显命令中的内容都有点小问题，”Peer2/Org2” 和 “org2/peer3” 都是不存在的，“3” 其实对应的节点是 Peer1/Org2。看到有的资料在分析这部分内容的时候也是按照错误的注释来解释的，让人很困惑。</p></blockquote><p>上面的脚本会在 cli 客户端容器启动之后执行，在 network_setup.sh 脚本的最后会执行 <code>docker logs -f cli</code> 来查看 cli 容器的日志信息，在开始时会出现如下的字符图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">echo</span><br><span class="line">echo &quot; ____    _____      _      ____    _____           _____   ____    _____ &quot;</span><br><span class="line">echo &quot;/ ___|  |_   _|    / \    |  _ \  |_   _|         | ____| |___ \  | ____|&quot;</span><br><span class="line">echo &quot;\___ \    | |     / _ \   | |_) |   | |    _____  |  _|     __) | |  _|  &quot;</span><br><span class="line">echo &quot; ___) |   | |    / ___ \  |  _ &lt;    | |   |_____| | |___   / __/  | |___ &quot;</span><br><span class="line">echo &quot;|____/    |_|   /_/   \_\ |_| \_\   |_|           |_____| |_____| |_____|&quot;</span><br><span class="line">echo</span><br></pre></td></tr></table></figure><p>在结束时显示的字符图如下，并提示执行完成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">echo</span><br><span class="line">echo &quot;===================== All GOOD, End-2-End execution completed ===================== &quot;</span><br><span class="line">echo</span><br><span class="line"></span><br><span class="line">echo</span><br><span class="line">echo &quot; _____   _   _   ____            _____   ____    _____ &quot;</span><br><span class="line">echo &quot;| ____| | \ | | |  _ \          | ____| |___ \  | ____|&quot;</span><br><span class="line">echo &quot;|  _|   |  \| | | | | |  _____  |  _|     __) | |  _|  &quot;</span><br><span class="line">echo &quot;| |___  | |\  | | |_| | |_____| | |___   / __/  | |___ &quot;</span><br><span class="line">echo &quot;|_____| |_| \_| |____/          |_____| |_____| |_____|&quot;</span><br><span class="line">echo</span><br></pre></td></tr></table></figure><p>以上就是e2e_cli 案例启动 fabric 网络的流程分析，接下来分析关闭 fabric 网络的流程。</p><hr><h1 id="2-关闭过程"><a href="#2-关闭过程" class="headerlink" title="2. 关闭过程"></a>2. 关闭过程</h1><h2 id="2-1-network-setup-sh-参数设置"><a href="#2-1-network-setup-sh-参数设置" class="headerlink" title="2.1 network_setup.sh 参数设置"></a>2.1 network_setup.sh 参数设置</h2><p>当执行 <code>./network_setup.sh down</code> 命令时，down 参数传入脚本作为变量 UP_DOWN 的值，表示关闭 fabric 网络的操作。脚本中判断 $UP_DOWN=down 后将执行 networkDown 函数，如 2.2 节。</p><hr><h2 id="2-2-关闭网络：networkDown"><a href="#2-2-关闭网络：networkDown" class="headerlink" title="2.2 关闭网络：networkDown"></a>2.2 关闭网络：networkDown</h2><p>在 networkDown 函数中，首先会执行 docker-compose 相关的命令来关闭容器服务，然后调用 clearContainers 和 removeUnwantedImages 函数删除相应的容器及镜像，最后会删除 generateArtifacts.sh 脚本创建的 crypto-config 目录和区块链网络证书等文件。如后面 3 节。</p><hr><h2 id="2-3-docker-compose-关闭容器服务"><a href="#2-3-docker-compose-关闭容器服务" class="headerlink" title="2.3 docker-compose 关闭容器服务"></a>2.3 docker-compose 关闭容器服务</h2><p>执行的命令为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose -f $COMPOSE_FILE down</span><br></pre></td></tr></table></figure><blockquote><p>$COMPOSE_FILE 就是 docker-compose-cli.yaml 文件。</p></blockquote><p>该命令会将由 docker-compose-cli.yaml 文件创建的容器服务全部关闭。</p><hr><h2 id="2-4-删除容器及镜像"><a href="#2-4-删除容器及镜像" class="headerlink" title="2.4 删除容器及镜像"></a>2.4 删除容器及镜像</h2><p>在运行 e2e_cli  案例之后，环境中会启动总共 9 个容器，使用 <code>docker ps -a</code> 命令查看，这里只列出容器的名字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">orderer.example.com                   &lt;==Orderer排序节点</span><br><span class="line">peer0.org1.example.com                &lt;==Peer0/Org1</span><br><span class="line">peer1.org1.example.com                &lt;==Peer1/Org2</span><br><span class="line">peer0.org2.example.com                &lt;==Peer0/Org2</span><br><span class="line">peer1.org2.example.com                &lt;==Peer1/Org2</span><br><span class="line">cli                                   &lt;==客户端容器</span><br><span class="line">dev-peer0.org1.example.com-mycc-1.0   &lt;==运行智能合约的容器，基于Peer0/Org1安装智能合约后生成</span><br><span class="line">dev-peer0.org2.example.com-mycc-1.0   &lt;==运行智能合约的容器，基于Peer0/Org2安装智能合约后生成</span><br><span class="line">dev-peer1.org2.example.com-mycc-1.0   &lt;==运行智能合约的容器，基于Peer1/Org2安装智能合约后生成</span><br></pre></td></tr></table></figure><p>另外也会生成上面运行智能合约的容器对应的镜像，使用 <code>docker image ls</code> 列出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls</span><br><span class="line">REPOSITORY                            TAG        IMAGE ID           CREATED         SIZE</span><br><span class="line">dev-peer1.org2.example.com-mycc-1.0   latest    8c03b3cb4f3f      36 hours ago      173MB</span><br><span class="line">dev-peer0.org1.example.com-mycc-1.0   latest    9aa4e69a149f      36 hours ago      173MB</span><br><span class="line">dev-peer0.org2.example.com-mycc-1.0   latest    f3fef07f5dcc      36 hours ago      173MB</span><br></pre></td></tr></table></figure><p>以上的容器和镜像就是要被删除的，这里调用了两个函数：clearContainers 和 removeUnwantedImages 分别来删除，函数内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function clearContainers () &#123;</span><br><span class="line">        CONTAINER_IDS=$(docker ps -aq)</span><br><span class="line">        if [ -z &quot;$CONTAINER_IDS&quot; -o &quot;$CONTAINER_IDS&quot; = &quot; &quot; ]; then</span><br><span class="line">                echo &quot;---- No containers available for deletion ----&quot;</span><br><span class="line">        else</span><br><span class="line">                docker rm -f $CONTAINER_IDS</span><br><span class="line">        fi  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function removeUnwantedImages() &#123;</span><br><span class="line">        DOCKER_IMAGE_IDS=$(docker images | grep &quot;dev\|none\|test-vp\|peer[0-9]-&quot; | awk &apos;&#123;print $3&#125;&apos;)</span><br><span class="line">        if [ -z &quot;$DOCKER_IMAGE_IDS&quot; -o &quot;$DOCKER_IMAGE_IDS&quot; = &quot; &quot; ]; then</span><br><span class="line">                echo &quot;---- No images available for deletion ----&quot;</span><br><span class="line">        else</span><br><span class="line">                docker rmi -f $DOCKER_IMAGE_IDS</span><br><span class="line">        fi  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="2-5-删除相关目录文件"><a href="#2-5-删除相关目录文件" class="headerlink" title="2.5 删除相关目录文件"></a>2.5 删除相关目录文件</h2><p>在 networkDown 函数的最后就是要删除由 generateArtifacts.sh 脚本创建的 crypto-config 目录和区块链网络证书等文件，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># remove orderer block and other channel configuration transactions and certs</span><br><span class="line">rm -rf channel-artifacts/*.block channel-artifacts/*.tx crypto-config</span><br></pre></td></tr></table></figure><p>结束以上步骤之后就完成了关闭 fabric 网络的操作。</p><hr>]]></content>
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hyperledger fabric </tag>
            
            <tag> e2e_cli </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hyperledger fabric v1.0.0 环境部署过程</title>
      <link href="/2018/08/26/Fabric%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"/>
      <url>/2018/08/26/Fabric%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要基于 Hyperledger fabric 的官方文档来搭建其实验环境，但官方文档对于很多步骤都有省略，所以本文将比较详细的在一台新安装的 Ubuntu 16.04 虚拟机上来介绍 fabric 的环境部署流程步骤。</p><a id="more"></a><h1 id="环境部署"><a href="#环境部署" class="headerlink" title="环境部署"></a>环境部署</h1><h3 id="1-更换-apt-源"><a href="#1-更换-apt-源" class="headerlink" title="1. 更换 apt 源"></a>1. 更换 apt 源</h3><p>先备份 sources.list 文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak</span><br></pre></td></tr></table></figure><p>再修改 sources.list 文件，换成阿里云的国内源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vim /etc/apt/sources.list</span><br><span class="line">deb-src http://archive.ubuntu.com/ubuntu xenial main restricted #Added by software-properties</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted multiverse universe #Added by software-properties</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted multiverse universe #Added by software-properties</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial universe</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates universe</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse #Added by software-properties</span><br><span class="line">deb http://archive.canonical.com/ubuntu xenial partner</span><br><span class="line">deb-src http://archive.canonical.com/ubuntu xenial partner</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted multiverse universe #Added by software-properties</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-security universe</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-security multiverse</span><br></pre></td></tr></table></figure><p>最后更新一下源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br></pre></td></tr></table></figure><h3 id="2-安装-curl"><a href="#2-安装-curl" class="headerlink" title="2. 安装 curl"></a>2. 安装 curl</h3><p>Ubuntu 16.04 一般默认是安装了 curl 的，可以通过以下命令验证：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ curl -V</span><br><span class="line">curl 7.47.0 (x86_64-pc-linux-gnu) libcurl/7.47.0 GnuTLS/3.4.10 zlib/1.2.8 libidn/1.32 librtmp/2.3</span><br><span class="line">Protocols: dict file ftp ftps gopher http https imap imaps ldap ldaps pop3 pop3s rtmp rtsp smb smbs smtp smtps telnet tftp </span><br><span class="line">Features: AsynchDNS IDN IPv6 Largefile GSS-API Kerberos SPNEGO NTLM NTLM_WB SSL libz TLS-SRP UnixSockets</span><br></pre></td></tr></table></figure><p>如果没有安装，则通过 apt-get 安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install curl</span><br></pre></td></tr></table></figure><h3 id="3-安装-Docker"><a href="#3-安装-Docker" class="headerlink" title="3. 安装 Docker"></a>3. 安装 Docker</h3><ul><li><p>由于 apt 源使用HTTPS以确保软件下载过程中不被篡改。因此，我们首先需要添加使用HTTPS传输的软件包以及CA证书。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    software-properties-common</span><br></pre></td></tr></table></figure></li><li><p>为了确认所下载软件包的合法性，需要添加软件源的 GPG 秘钥</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure></li><li><p>然后，我们需要向 sources.list 中添加 Docker 软件源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo add-apt-repository \</span><br><span class="line">    &quot;deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu \</span><br><span class="line">    $(lsb_release -cs) \</span><br><span class="line">    stable&quot;</span><br></pre></td></tr></table></figure><blockquote><p>以上命令会添加稳定版本的Docker CE apt 镜像源。</p></blockquote></li><li><p>更新 apt 软件包缓存，并安装 docker-ce：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line"></span><br><span class="line">$ sudo apt-get install docker-ce</span><br></pre></td></tr></table></figure></li><li><p>查看 Docker 版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker -v</span><br><span class="line">Docker version 18.06.0-ce, build 0ffa825</span><br></pre></td></tr></table></figure><p>满足官方文档中 <em>Docker version 17.06.2-ce or greater is required</em> 的要求。</p></li><li><p>启动 Docker CE</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl enable docker</span><br><span class="line">$ sudo systemctl start docker</span><br></pre></td></tr></table></figure></li><li><p>建立 docker 用户组</p><p>默认情况下，<code>docker</code> 命令会使用 <a href="https://en.wikipedia.org/wiki/Unix_domain_socket" target="_blank" rel="noopener">Unix socket</a> 与 Docker 引擎通讯。而只有 <code>root</code> 用户和 <code>docker</code> 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 <code>root</code> 用户。因此，更好地做法是将需要使用 <code>docker</code> 的用户加入 <code>docker</code> 用户组。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo groupadd docker</span><br></pre></td></tr></table></figure><blockquote><p>其实一般按照上面的方法安装 Docker 后就已经创建好 docker 用户组了，可以使用 <code>$ cat /etc/group | grep docker</code> 命令来验证，所以就不需要再建立 docker 用户组了，再建立也会报错提示用户组已存在的。</p></blockquote></li><li><p>将当前用户加入 docker 用户组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo usermod -aG docker $USER</span><br></pre></td></tr></table></figure><blockquote><p>下次登录时即可方便的使用 docker 命令。</p></blockquote></li><li><p>测试 Docker 是否安装正确</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$ docker run hello-world</span><br><span class="line">Unable to find image &apos;hello-world:latest&apos; locally</span><br><span class="line">latest: Pulling from library/hello-world</span><br><span class="line">9db2ca6ccae0: Pull complete </span><br><span class="line">Digest: sha256:4b8ff392a12ed9ea17784bd3c9a8b1fa3299cac44aca35a85c90c5e3c7afacdc</span><br><span class="line">Status: Downloaded newer image for hello-world:latest</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">To generate this message, Docker took the following steps:</span><br><span class="line"> 1. The Docker client contacted the Docker daemon.</span><br><span class="line"> 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.</span><br><span class="line">    (amd64)</span><br><span class="line"> 3. The Docker daemon created a new container from that image which runs the</span><br><span class="line">    executable that produces the output you are currently reading.</span><br><span class="line"> 4. The Docker daemon streamed that output to the Docker client, which sent it</span><br><span class="line">    to your terminal.</span><br><span class="line"></span><br><span class="line">To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line"> $ docker run -it ubuntu bash</span><br><span class="line"></span><br><span class="line">Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line"> https://hub.docker.com/</span><br><span class="line"></span><br><span class="line">For more examples and ideas, visit:</span><br><span class="line"> https://docs.docker.com/engine/userguide/</span><br></pre></td></tr></table></figure></li><li><p>配置镜像加速器</p><p>国内从 Docker Hub 拉取镜像有时会遇到困难，此时可以配置镜像加速器。Docker 官方和国内很多云服务商都提供了国内加速器服务，例如： </p><ul><li><a href="https://docs.docker.com/registry/recipes/mirror/#use-case-the-china-registry-mirror" target="_blank" rel="noopener">Docker 官方提供的中国 registry mirror <code>https://registry.docker-cn.com</code></a> </li><li><a href="https://kirk-enterprise.github.io/hub-docs/#/user-guide/mirror" target="_blank" rel="noopener">七牛云加速器 <code>https://reg-mirror.qiniu.com/</code></a> </li></ul><blockquote><p>当配置某一个加速器地址之后，若发现拉取不到镜像，请切换到另一个加速器地址。</p><p>国内各大云服务商均提供了 Docker 镜像加速服务，建议根据运行 Docker 的云平台选择对应的镜像加速服务。</p></blockquote><p>我们以 Docker 官方加速器 <code>https://registry.docker-cn.com</code> 为例进行介绍。 </p><p>在 <code>/etc/docker/daemon.json</code> 中写入如下内容（如果文件不存在则创建）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [</span><br><span class="line">    &quot;https://registry.docker-cn.com&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后重新启动服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl daemon-reload</span><br><span class="line">$ sudo systemctl restart docker</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-安装-Docker-Compose"><a href="#4-安装-Docker-Compose" class="headerlink" title="4. 安装 Docker Compose"></a>4. 安装 Docker Compose</h3><ul><li><p>通过二进制包来安装，从 <a href="https://github.com/docker/compose/releases" target="_blank" rel="noopener">官方 GitHub Release</a> 处直接下载编译好的二进制文件即可。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo curl -L https://github.com/docker/compose/releases/download/1.22.0/docker-compose-$(uname -s)-$(uname -m) -o /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line">$ sudo chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure></li><li><p>查看 Docker compose 版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose --version</span><br><span class="line">docker-compose version 1.22.0, build f46880fe</span><br></pre></td></tr></table></figure><blockquote><p> 满足官方文档中 <em>Docker Compose version 1.14.0 or greater</em>  的要求。</p></blockquote></li></ul><h3 id="5-安装-Go-语言环境"><a href="#5-安装-Go-语言环境" class="headerlink" title="5. 安装 Go 语言环境"></a>5. 安装 Go 语言环境</h3><p>Hyperledger Fabric 在很多组件中使用了 Go 语言，并且 <code>Hyperledger fabric 1.2.0</code> 要求使用的是 <code>GO version 1.10.x</code> ，所以需要在我们的环境中安装对应的 Go 语言。</p><ul><li><p>从官网下载 <code>1.10.x</code> 版本的 Linux 平台的源码包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget https://dl.google.com/go/go1.10.3.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>解压到指定目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo tar zxvf go1.10.3.linux-amd64.tar.gz -C /usr/local/</span><br></pre></td></tr></table></figure></li><li><p>先创建 Go 的工作目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir ~/go</span><br></pre></td></tr></table></figure></li><li><p>配置环境变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ vi ~/.bashrc</span><br><span class="line">添加</span><br><span class="line">export GOROOT=/usr/local/go</span><br><span class="line">export GOPATH=/home/user1/go</span><br><span class="line">export PATH=$PATH:$GOROOT/bin:$GOPATH/bin</span><br></pre></td></tr></table></figure><p>保存并使生效：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ source ~/.bashrc</span><br></pre></td></tr></table></figure></li><li><p>测试 Go 的 demo 程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/go</span><br><span class="line"></span><br><span class="line">$ vi hello.go</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">fmt.Printf(&quot;hello world\n&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ go build hello.go</span><br><span class="line"></span><br><span class="line">$ ls</span><br><span class="line">hello  hello.go</span><br><span class="line"></span><br><span class="line">$ ./hello</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure></li></ul><h3 id="6-Fabric-源码下载"><a href="#6-Fabric-源码下载" class="headerlink" title="6. Fabric 源码下载"></a>6. Fabric 源码下载</h3><ul><li><p>首先创建存放源码的文件夹：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir -p ~/go/src/github.com/hyperledger</span><br></pre></td></tr></table></figure></li><li><p>使用 Git 下载完整源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/hyperledger/fabric.git</span><br></pre></td></tr></table></figure></li><li><p>进入 fabric 目录查看版本分支并切换分支：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cd fabric</span><br><span class="line">$ git branch</span><br><span class="line">* release-1.2</span><br><span class="line">$ git checkout v1.0.0</span><br></pre></td></tr></table></figure><p>由于在 release-1.2 版本中碰到没有解决的问题，所以先切换到 v1.0.0 来完成搭建并测试的过程。</p></li></ul><h3 id="7-Fabric-Docker-镜像下载"><a href="#7-Fabric-Docker-镜像下载" class="headerlink" title="7. Fabric Docker 镜像下载"></a>7. Fabric Docker 镜像下载</h3><p>进入 <code>~/go/src/github.com/hyperledger/fabrci/examples/e2e_cli/</code> 目录，完成镜像下载，执行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/go/src/github.com/hyperledger/fabrci/examples/e2e_cli/</span><br><span class="line">$ ls</span><br><span class="line">base                docker-compose-cli.yaml           download-dockerimages.sh  scripts</span><br><span class="line">channel-artifacts   docker-compose-couch.yaml         end-to-end.rst</span><br><span class="line">configtx.yaml       docker-compose-e2e-template.yaml  generateArtifacts.sh</span><br><span class="line">crypto-config.yaml  docker-compose-e2e.yaml           network_setup.sh</span><br><span class="line">$ source download-dockerimages.sh -c x86_64-1.0.0 -f x86_64-1.0.0</span><br><span class="line">$ docker image list</span><br><span class="line">REPOSITORY                     TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">hyperledger/fabric-tools       latest              0403fd1c72c7        13 months ago       1.32GB</span><br><span class="line">hyperledger/fabric-tools       x86_64-1.0.0        0403fd1c72c7        13 months ago       1.32GB</span><br><span class="line">hyperledger/fabric-couchdb     latest              2fbdbf3ab945        13 months ago       1.48GB</span><br><span class="line">hyperledger/fabric-couchdb     x86_64-1.0.0        2fbdbf3ab945        13 months ago       1.48GB</span><br><span class="line">hyperledger/fabric-kafka       latest              dbd3f94de4b5        13 months ago       1.3GB</span><br><span class="line">hyperledger/fabric-kafka       x86_64-1.0.0        dbd3f94de4b5        13 months ago       1.3GB</span><br><span class="line">hyperledger/fabric-zookeeper   latest              e545dbf1c6af        13 months ago       1.31GB</span><br><span class="line">hyperledger/fabric-zookeeper   x86_64-1.0.0        e545dbf1c6af        13 months ago       1.31GB</span><br><span class="line">hyperledger/fabric-orderer     latest              e317ca5638ba        13 months ago       179MB</span><br><span class="line">hyperledger/fabric-orderer     x86_64-1.0.0        e317ca5638ba        13 months ago       179MB</span><br><span class="line">hyperledger/fabric-peer        latest              6830dcd7b9b5        13 months ago       182MB</span><br><span class="line">hyperledger/fabric-peer        x86_64-1.0.0        6830dcd7b9b5        13 months ago       182MB</span><br><span class="line">hyperledger/fabric-javaenv     latest              8948126f0935        13 months ago       1.42GB</span><br><span class="line">hyperledger/fabric-javaenv     x86_64-1.0.0        8948126f0935        13 months ago       1.42GB</span><br><span class="line">hyperledger/fabric-ccenv       latest              7182c260a5ca        13 months ago       1.29GB</span><br><span class="line">hyperledger/fabric-ccenv       x86_64-1.0.0        7182c260a5ca        13 months ago       1.29GB</span><br><span class="line">hyperledger/fabric-ca          latest              a15c59ecda5b        13 months ago       238MB</span><br><span class="line">hyperledger/fabric-ca          x86_64-1.0.0        a15c59ecda5b        13 months ago       238MB</span><br><span class="line">hyperledger/fabric-baseos      x86_64-0.3.1        4b0cab202084        15 months ago       157MB</span><br></pre></td></tr></table></figure><h3 id="8-启动-fabric-网络并完成-chaincode-测试"><a href="#8-启动-fabric-网络并完成-chaincode-测试" class="headerlink" title="8. 启动 fabric 网络并完成 chaincode 测试"></a>8. 启动 fabric 网络并完成 chaincode 测试</h3><p>还是在刚刚的 e2e_cli 文件加下，执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ./network_setup.sh up</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">===================== All GOOD, End-2-End execution completed ===================== </span><br><span class="line"> _____   _   _   ____            _____   ____    _____ </span><br><span class="line">| ____| | \ | | |  _ \          | ____| |___ \  | ____|</span><br><span class="line">|  _|   |  \| | | | | |  _____  |  _|     __) | |  _|  </span><br><span class="line">| |___  | |\  | | |_| | |_____| | |___   / __/  | |___ </span><br><span class="line">|_____| |_| \_| |____/          |_____| |_____| |_____|</span><br></pre></td></tr></table></figure><p>最后出现上面字符说明 fabric 网络已经启动并完成了 chaincode 的测试。</p><hr><h1 id="搭建过程中碰到的问题："><a href="#搭建过程中碰到的问题：" class="headerlink" title="搭建过程中碰到的问题："></a>搭建过程中碰到的问题：</h1><p>v1.0.0 版本搭建过程中会碰到的问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">===================== Chaincode is installed on remote peer PEER2 ===================== </span><br><span class="line"></span><br><span class="line">Instantiating chaincode on org2/peer2...</span><br><span class="line">CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt</span><br><span class="line">CORE_PEER_TLS_KEY_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/server.key</span><br><span class="line">CORE_PEER_LOCALMSPID=Org2MSP</span><br><span class="line">CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock</span><br><span class="line">CORE_PEER_TLS_CERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/server.crt</span><br><span class="line">CORE_PEER_TLS_ENABLED=true</span><br><span class="line">CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp</span><br><span class="line">CORE_PEER_ID=cli</span><br><span class="line">CORE_LOGGING_LEVEL=DEBUG</span><br><span class="line">CORE_PEER_ADDRESS=peer0.org2.example.com:7051</span><br><span class="line">2018-08-21 13:24:09.596 UTC [msp] GetLocalMSP -&gt; DEBU 001 Returning existing local MSP</span><br><span class="line">2018-08-21 13:24:09.596 UTC [msp] GetDefaultSigningIdentity -&gt; DEBU 002 Obtaining default signing identity</span><br><span class="line">2018-08-21 13:24:09.602 UTC [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 003 Using default escc</span><br><span class="line">2018-08-21 13:24:09.602 UTC [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 004 Using default vscc</span><br><span class="line">2018-08-21 13:24:09.603 UTC [msp/identity] Sign -&gt; DEBU 005 Sign: plaintext: 0A95070A6708031A0C08F9A4F0DB0510...324D53500A04657363630A0476736363 </span><br><span class="line">2018-08-21 13:24:09.603 UTC [msp/identity] Sign -&gt; DEBU 006 Sign: digest: D73172E2164A0DD4FA9B64DBAFE980C3ABC412EB3CD32FEBF6EF7A7AFE3B6431 </span><br><span class="line">Error: Error endorsing chaincode: rpc error: code = Unknown desc = Error starting container: API error (404): &#123;&quot;message&quot;:&quot;network e2ecli_default not found&quot;&#125;</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line">  peer chaincode instantiate [flags]</span><br><span class="line"></span><br><span class="line">Flags:</span><br><span class="line">  -C, --channelID string   The channel on which this command should be executed (default &quot;testchainid&quot;)</span><br><span class="line">  -c, --ctor string        Constructor message for the chaincode in JSON format (default &quot;&#123;&#125;&quot;)</span><br><span class="line">  -E, --escc string        The name of the endorsement system chaincode to be used for this chaincode</span><br><span class="line">  -l, --lang string        Language the chaincode is written in (default &quot;golang&quot;)</span><br><span class="line">  -n, --name string        Name of the chaincode</span><br><span class="line">  -P, --policy string      The endorsement policy associated to this chaincode</span><br><span class="line">  -v, --version string     Version of the chaincode specified in install/instantiate/upgrade commands</span><br><span class="line">  -V, --vscc string        The name of the verification system chaincode to be used for this chaincode</span><br><span class="line"></span><br><span class="line">Global Flags:</span><br><span class="line">      --cafile string              Path to file containing PEM-encoded trusted certificate(s) for the ordering endpoint</span><br><span class="line">      --logging-level string       Default logging level and overrides, see core.yaml for full syntax</span><br><span class="line">  -o, --orderer string             Ordering service endpoint</span><br><span class="line">      --test.coverprofile string   Done (default &quot;coverage.cov&quot;)</span><br><span class="line">      --tls                        Use TLS when communicating with the orderer endpoint</span><br><span class="line"></span><br><span class="line">!!!!!!!!!!!!!!! Chaincode instantiation on PEER2 on channel &apos;mychannel&apos; failed !!!!!!!!!!!!!!!!</span><br><span class="line">================== ERROR !!! FAILED to execute End-2-End Scenario ==================</span><br></pre></td></tr></table></figure><p><strong>解决方法：</strong></p><p>这个主要是因为 e2e_cli/base目录下的 peer-base.yaml 文件中的网络名称打成了 <code>e2ecli_default</code>，将其改成 <code>e2e_cli_default</code> 即可。</p><hr>]]></content>
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hyperledger fabric </tag>
            
            <tag> Docker </tag>
            
            <tag> Docker Compose </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>迁移vim-python开发环境</title>
      <link href="/2018/08/23/%E8%BF%81%E7%A7%BBvim-python%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
      <url>/2018/08/23/%E8%BF%81%E7%A7%BBvim-python%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>之前配置好了自己的 vim python 开发环境，为了方便在其他主机上面迁移之前的开发环境，所以将所有的插件包都打包压缩了一份，和 vim 配置文件 .vimrc 一起上传到了百度云盘（下载链接：<a href="https://pan.baidu.com/s/1QJtx7CPloS4sKmwD3xjj8g" target="_blank" rel="noopener">vim插件包</a> 密码：neio）。通过下载这个文件夹就可以在新的主机上部署 vim 的 python 开发环境了。</p><a id="more"></a><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><ol><li><p>下载插件包与配置文件</p><p>先使用百度云盘下载这两个文件，然后再通过 ftp 上传到你的 Linux 主机上。我也试过直接在 Linux 里面通过 wget 来下载百度云盘的文件，但是这个要使用浏览器来生成下载链接，挺麻烦的，所以我就不在这里说明了。</p></li><li><p>将 .vimrc 放到用户主目录下，即 <code>~/</code> 目录</p><p>.vimrc 文件里面主要记录需要安装哪些插件，我的 vim python 开发环境安装的插件有：</p><ul><li><code>VundleVim/Vundle.vim</code></li><li><code>Valloric/YouCompleteMe</code></li><li><code>Lokaltog/vim-powerline</code></li><li><code>scrooloose/nerdtree</code></li><li><code>Yggdroot/indentLine</code></li><li><code>jiangmiao/auto-pairs</code></li><li><code>tell-k/vim-autopep8</code></li><li><code>scrooloose/nerdcommenter</code></li><li><code>altercation/vim-colors-solarized</code></li><li><code>w0rp/ale</code></li><li><code>scrooloose/syntastic</code></li><li><code>nvie/vim-flake8</code></li></ul><p>以及一些常用的配置信息，具体如下所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line">$ vi ~/.vimrc</span><br><span class="line">&quot;去掉vi的一致性&quot;</span><br><span class="line">set nocompatible</span><br><span class="line"></span><br><span class="line">filetype off</span><br><span class="line">set rtp+=~/.vim/bundle/Vundle.vim</span><br><span class="line">call vundle#begin()</span><br><span class="line">Plugin &apos;VundleVim/Vundle.vim&apos;</span><br><span class="line">Plugin &apos;Valloric/YouCompleteMe&apos;</span><br><span class="line">Plugin &apos;Lokaltog/vim-powerline&apos;</span><br><span class="line">Plugin &apos;scrooloose/nerdtree&apos;</span><br><span class="line">Plugin &apos;Yggdroot/indentLine&apos;</span><br><span class="line">Plugin &apos;jiangmiao/auto-pairs&apos;</span><br><span class="line">Plugin &apos;tell-k/vim-autopep8&apos;</span><br><span class="line">Plugin &apos;scrooloose/nerdcommenter&apos;</span><br><span class="line">Plugin &apos;altercation/vim-colors-solarized&apos;</span><br><span class="line">&quot;Plugin &apos;w0rp/ale&apos;</span><br><span class="line">Plugin &apos;scrooloose/syntastic&apos;</span><br><span class="line">Plugin &apos;nvie/vim-flake8&apos;</span><br><span class="line">call vundle#end()</span><br><span class="line">filetype plugin indent on</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&quot;显示行号&quot;</span><br><span class="line">set number</span><br><span class="line">&quot; 隐藏滚动条&quot;    </span><br><span class="line">&quot;set guioptions-=r </span><br><span class="line">&quot;set guioptions-=L</span><br><span class="line">&quot;set guioptions-=b</span><br><span class="line">&quot;隐藏顶部标签栏&quot;</span><br><span class="line">&quot;set showtabline=0</span><br><span class="line">&quot;设置字体&quot;</span><br><span class="line">set guifont=Monaco:h13         </span><br><span class="line">set nowrap  &quot;设置不折行&quot;</span><br><span class="line">&quot;set fileformat=unix &quot;设置以unix的格式保存文件&quot;</span><br><span class="line">&quot;set cindent     &quot;设置C样式的缩进格式&quot;</span><br><span class="line">set tabstop=4   &quot;设置table长度&quot;</span><br><span class="line">set shiftwidth=4        &quot;同上&quot;</span><br><span class="line">set showmatch   &quot;显示匹配的括号&quot;</span><br><span class="line">set scrolloff=5     &quot;距离顶部和底部5行&quot;</span><br><span class="line">set laststatus=2    &quot;命令行为两行&quot;</span><br><span class="line">set fenc=utf-8      &quot;文件编码&quot;</span><br><span class="line">set backspace=2</span><br><span class="line">set mouse=v     &quot;启用鼠标&quot;</span><br><span class="line">set selection=exclusive</span><br><span class="line">set selectmode=mouse,key</span><br><span class="line">set matchtime=5</span><br><span class="line">set ignorecase      &quot;忽略大小写&quot;</span><br><span class="line">set incsearch</span><br><span class="line">set hlsearch        &quot;高亮搜索项&quot;</span><br><span class="line">set noexpandtab     &quot;不允许扩展table&quot;</span><br><span class="line">set whichwrap+=&lt;,&gt;,h,l</span><br><span class="line">set autoread</span><br><span class="line">set cursorline      &quot;突出显示当前行&quot;</span><br><span class="line">&quot;set cursorcolumn        &quot;突出显示当前列&quot;</span><br><span class="line">syntax on   &quot;开启语法高亮&quot;</span><br><span class="line">&quot;set background=dark     &quot;设置背景色&quot;</span><br><span class="line">&quot;colorscheme solarized</span><br><span class="line">&quot;let g:solarized_termcolors=256  &quot;solarized主题设置在终端下的设置&quot;</span><br><span class="line"></span><br><span class="line">&quot;syntastic</span><br><span class="line">let python_highlight_all=1</span><br><span class="line">&quot;设置error和warning的标志</span><br><span class="line">let g:syntastic_enable_signs=1</span><br><span class="line">let g:syntastic_error_symbol=&apos;✗&apos;</span><br><span class="line">let g:syntastic_warning_symbol=&apos;►&apos;</span><br><span class="line">&quot;总是打开Location</span><br><span class="line">&quot;List（相当于QuickFix）窗口，如果你发现syntastic因为与其他插件冲突而经常崩溃，将下面选项置0</span><br><span class="line">let g:syntastic_always_populate_loc_list = 0</span><br><span class="line">&quot;自动打开LocatonList，默认值为2，表示发现错误时不自动打开，当修正以后没有再发现错误时自动关闭，置1表示自动打开自动关闭，0表示关闭自动打开和自动关闭，3表示自动打开，但不自动关闭</span><br><span class="line">let g:syntastic_auto_loc_list = 2</span><br><span class="line">&quot;修改Locaton List窗口高度</span><br><span class="line">let g:syntastic_loc_list_height = 3</span><br><span class="line">&quot;打开文件时自动进行检查</span><br><span class="line">let g:syntastic_check_on_open = 1</span><br><span class="line">let g:syntastic_check_on_wq = 1</span><br><span class="line">&quot;自动跳转到发现的第一个错误或警告处</span><br><span class="line">let g:syntastic_auto_jump = 1</span><br><span class="line">&quot;高亮错误</span><br><span class="line">let g:syntastic_enable_highlighting=0</span><br><span class="line">&quot;设置pyflakes为默认的python语法检查工具</span><br><span class="line">let g:syntastic_python_checkers = [&apos;pyflakes&apos;]</span><br><span class="line"></span><br><span class="line">&quot;按F5运行python&quot;</span><br><span class="line">map &lt;F5&gt; :call RunPython()&lt;CR&gt;</span><br><span class="line">function RunPython()</span><br><span class="line">exec &quot;W&quot;</span><br><span class="line">if &amp;filetype == &apos;python&apos;</span><br><span class="line">exec &quot;!time python %&quot;</span><br><span class="line">endif</span><br><span class="line">endfunction</span><br><span class="line"></span><br><span class="line">&quot;默认配置文件路径&quot;</span><br><span class="line">let g:ycm_global_ycm_extra_conf = &apos;~/.ycm_extra_conf.py&apos;</span><br><span class="line">&quot;打开vim时不再询问是否加载ycm_extra_conf.py配置&quot;</span><br><span class="line">let g:ycm_confirm_extra_conf=0</span><br><span class="line">set completeopt=longest,menu</span><br><span class="line">&quot;python解释器路径&quot;</span><br><span class="line">let g:ycm_path_to_python_interpreter=&apos;/usr/bin/python&apos;</span><br><span class="line">&quot;是否开启语义补全&quot;</span><br><span class="line">let g:ycm_seed_identifiers_with_syntax=1 </span><br><span class="line">&quot;是否在注释中也开启补全&quot; </span><br><span class="line">let g:ycm_complete_in_comments=1 </span><br><span class="line">let g:ycm_collect_identifiers_from_comments_and_strings = 0</span><br><span class="line">&quot;开始补全的字符数&quot;</span><br><span class="line">let g:ycm_min_num_of_chars_for_completion=2</span><br><span class="line">&quot;补全后自动关机预览窗口&quot;</span><br><span class="line">let g:ycm_autoclose_preview_window_after_completion=1</span><br><span class="line">&quot; 禁止缓存匹配项,每次都重新生成匹配项&quot;</span><br><span class="line">let g:ycm_cache_omnifunc=0</span><br><span class="line">&quot;字符串中也开启补全&quot;</span><br><span class="line">let g:ycm_complete_in_strings = 1</span><br><span class="line">&quot;离开插入模式后自动关闭预览窗口&quot;</span><br><span class="line">autocmd InsertLeave * if pumvisible() == 0|pclose|endif</span><br><span class="line"></span><br><span class="line">&quot;回车即选中当前项&quot;</span><br><span class="line">&quot;inoremap &lt;expr&gt; &lt;CR&gt;       pumvisible() ? &apos;&lt;C-y&gt;&apos; : &apos;\&lt;CR&gt;&apos;</span><br><span class="line">&quot;上下左右键行为&quot;</span><br><span class="line">inoremap &lt;expr&gt; &lt;Down&gt;     pumvisible() ? &apos;\&lt;C-n&gt;&apos; : &apos;\&lt;Down&gt;&apos;</span><br><span class="line">inoremap &lt;expr&gt; &lt;Up&gt;       pumvisible() ? &apos;\&lt;C-p&gt;&apos; : &apos;\&lt;Up&gt;&apos;</span><br><span class="line">inoremap &lt;expr&gt; &lt;PageDown&gt; pumvisible() ? &apos;\&lt;PageDown&gt;\&lt;C-p&gt;\&lt;C-n&gt;&apos; : &apos;\&lt;PageDown&gt;&apos;</span><br><span class="line">inoremap &lt;expr&gt; &lt;PageUp&gt;   pumvisible() ? &apos;\&lt;PageUp&gt;\&lt;C-p&gt;\&lt;C-n&gt;&apos; : &apos;\&lt;PageUp&gt;&apos;</span><br><span class="line"></span><br><span class="line">&quot;F2开启和关闭树&quot;</span><br><span class="line">map &lt;F2&gt; :NERDTreeToggle&lt;CR&gt;</span><br><span class="line">let NERDTreeChDirMode=1</span><br><span class="line">&quot;显示书签&quot;</span><br><span class="line">let NERDTreeShowBookmarks=1</span><br><span class="line">&quot;设置忽略文件类型&quot;</span><br><span class="line">let NERDTreeIgnore=[&apos;\~$&apos;, &apos;\.pyc$&apos;, &apos;\.swp$&apos;]</span><br><span class="line">&quot;窗口大小&quot;</span><br><span class="line">let NERDTreeWinSize=25</span><br><span class="line"></span><br><span class="line">&quot;split navigations</span><br><span class="line">nnoremap &lt;C-J&gt; &lt;C-W&gt;&lt;C-J&gt;</span><br><span class="line">nnoremap &lt;C-K&gt; &lt;C-W&gt;&lt;C-K&gt;</span><br><span class="line">nnoremap &lt;C-L&gt; &lt;C-W&gt;&lt;C-L&gt;</span><br><span class="line">nnoremap &lt;C-H&gt; &lt;C-W&gt;&lt;C-H&gt;</span><br><span class="line"></span><br><span class="line">&quot;缩进指示线&quot;</span><br><span class="line">let g:indentLine_char=&apos;┆&apos;</span><br><span class="line">let g:indentLine_enabled = 1</span><br><span class="line"></span><br><span class="line">&quot;autopep8设置&quot;</span><br><span class="line">let g:autopep8_disable_show_diff=1</span><br><span class="line"></span><br><span class="line">let mapleader=&apos;,&apos;</span><br><span class="line"></span><br><span class="line">map &lt;F4&gt; &lt;leader&gt;ci &lt;CR&gt;</span><br></pre></td></tr></table></figure></li><li><p>在用户主目录下新建一个 .vim 文件夹，并将插件包解压缩至该文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir ~/.vim</span><br><span class="line">$ tar -jxv -f bundle.tar.bz2 -C ~/.vim</span><br></pre></td></tr></table></figure><p>到这里，除了自动补全的插件 YouCompleteMe ，其实大部分的插件都已经起作用了，我们的插件包有几百兆主要就是因为 YouCompleteMe 这个插件比较大，这也是因为这个插件的功能太强大了，这个插件在下载完成后还需要编译安装，接下来就来完成这个步骤。</p></li><li><p>安装 python 和 python 库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install python python-dev</span><br></pre></td></tr></table></figure><p>这一步没有完成在安装的时候可能会碰到下面的问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WARNING: this script is deprecated. Use the install.py script instead.</span><br><span class="line">Searching Python 2.7 libraries...</span><br><span class="line">ERROR: unable to find an appropriate Python library.</span><br></pre></td></tr></table></figure></li><li><p>安装编译环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install cmake gcc build-essential</span><br></pre></td></tr></table></figure><p>未完成这步可能会遇到的问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WARNING: this script is deprecated. Use the install.py script instead.</span><br><span class="line">ERROR: Unable to find executable &apos;cmake&apos;. CMake is required to build ycmd</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No CMAKE_CXX_COMPILER could be found.</span><br></pre></td></tr></table></figure></li><li><p>执行 YouCompleteMe 安装脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/.vim/bundle/YouCompleteMe</span><br><span class="line">$ ./install.sh</span><br></pre></td></tr></table></figure><p>完成上面的过程就实现了 YouCompleteMe 的安装，接下来就可以体验 vim 强大的功能啦！</p></li></ol>]]></content>
      
      <categories>
          
          <category> VIM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> vim </tag>
            
            <tag> YouCompleteMe </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Ubuntu 配置 shadowsocks 客户端</title>
      <link href="/2018/08/21/ubuntu%E9%85%8D%E7%BD%AEshadowsocks%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
      <url>/2018/08/21/ubuntu%E9%85%8D%E7%BD%AEshadowsocks%E5%AE%A2%E6%88%B7%E7%AB%AF/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在日常的工作学习中，经常需要搭建各种环境，而很多环境都是由国外开发并开源的，有一些软件或源码必须要到墙外面才能够下载，所以需要在自己的环境中配置 shadowsocks 客户端来连接国外的网络。在这里将介绍如何在 Ubuntu 系统下搭建 shadowsocks 客户端。</p><a id="more"></a><hr><h1 id="安装-shadowsocks"><a href="#安装-shadowsocks" class="headerlink" title="安装 shadowsocks"></a>安装 shadowsocks</h1><ol><li><p>安装 python pip工具</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install python-pip</span><br></pre></td></tr></table></figure></li><li><p>安装 shadowsocks</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pip install shadowsocks</span><br></pre></td></tr></table></figure></li><li><p>配置 shadowsocks</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vi /etc/shadowsocks.json</span><br></pre></td></tr></table></figure><p>输入以下 json 格式的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;server&quot;: &quot;服务器ip&quot;,</span><br><span class="line">    &quot;server_port&quot;: 服务器端口,</span><br><span class="line">    &quot;password&quot;: &quot;你的密码&quot;,</span><br><span class="line">    &quot;method&quot;: &quot;aes-256-cfb&quot;,</span><br><span class="line">    &quot;timeout&quot;: 300</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>启动 shadowsocks 服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sslocal -c /etc/shadowsocks.json &amp;</span><br></pre></td></tr></table></figure><blockquote><p>加上 &amp; 以让 shadowsocks 进程在后台运行</p></blockquote></li><li><p>设置 shadowsocks 开机自启动</p><p>将启动服务的命令添加到 <code>/etc/rc.local</code> 文件中的 <code>exit 0</code> 之前</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vi /etc/rc.local</span><br><span class="line">……</span><br><span class="line">sslocal -c /etc/shadowsocks.json &amp;</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure></li></ol><p>以上就是SS的搭建了，这个时候我们发现上网时并不可以翻墙，原因是需要将sock5代理映射为http代理。代理的软件很多，我选择了推荐度比较高的privoxy，下面是privoxy的配置。</p><hr><h1 id="安装-privoxy"><a href="#安装-privoxy" class="headerlink" title="安装 privoxy"></a>安装 privoxy</h1><ol><li><p>安装 privoxy</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install privoxy</span><br></pre></td></tr></table></figure></li><li><p>配置 privoxy</p><p>打开 <code>/etc/privoxy/config</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vi /etc/privoxy/config</span><br></pre></td></tr></table></figure><p>找到其中的4.1节，看一下有没有一句<code>listen-address localhost:8118</code>的代码，如果被注释了，取消注释。因为版本不一样这句的状态可能会不一样。 然后再将 <code>localhost</code> 改成 <code>127.0.0.1</code>（这一步很重要，反正我因为这一步的设置问题搞了很久都不知道为什么连不上外网），如图所示：</p><p><img src="https://raw.githubusercontent.com/cao0507/My-Pictures-Repository/master/blog/VPN%E9%85%8D%E7%BD%AEprivoxy%20%E5%9B%BE%E4%B8%80.png" alt="privoxy配置图"></p><p>接着找到5.2节，在本节末尾加入代码 <code>forward-socks5t / 127.0.0.1:1080 .</code>，注意最后有一个点号，如图：</p><p><img src="https://raw.githubusercontent.com/cao0507/My-Pictures-Repository/master/blog/VPN%E9%85%8D%E7%BD%AEprivoxy%20%E5%9B%BE%E4%BA%8C.png" alt="privoxy配置图"></p></li><li><p>重启 privoxy 服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo /etc/init.d/privoxy restart</span><br></pre></td></tr></table></figure></li><li><p>设置开机自启动 privoxy 服务</p><p>将启动服务的命令添加到 <code>/etc/rc.local</code> 文件中的 <code>exit 0</code> 之前：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vi /etc/rc.local</span><br><span class="line">……</span><br><span class="line">sslocal -c /etc/shadowsocks.json &amp;</span><br><span class="line">/etc/init.d/privoxy start</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure></li><li><p>代理配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vi /etc/profile</span><br><span class="line">export http_proxy=http://127.0.0.1:8118</span><br><span class="line">export https_proxy=http://127.0.0.1:8118</span><br><span class="line"></span><br><span class="line">$ source /etc/profile</span><br></pre></td></tr></table></figure></li></ol><hr><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl www.google.com</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget www.google.com</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> VPN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> shadowsocks </tag>
            
            <tag> privoxy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vultr CentOS搭建shadowsocks服务端并开启BBR加速</title>
      <link href="/2018/08/21/VPS%E6%90%AD%E5%BB%BAshadowsocks%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%B9%B6%E5%BC%80%E5%90%AFBBR%E5%8A%A0%E9%80%9F/"/>
      <url>/2018/08/21/VPS%E6%90%AD%E5%BB%BAshadowsocks%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%B9%B6%E5%BC%80%E5%90%AFBBR%E5%8A%A0%E9%80%9F/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近教研室很多同学来问有没有公用的 VPN，教研室以前有师兄去买过一些 VPN，但现在师兄也毕业了就用不了了。为了同学们的方便，作为网管应该尽力满足大家日常查阅资料的需求，于是向老师申请了经费去购买了一台 VPS 来搭建教研室公用的 VPN。<br><a id="more"></a></p><h1 id="购买-VPS"><a href="#购买-VPS" class="headerlink" title="购买 VPS"></a>购买 VPS</h1><p>我这里购买的是 vultr 的 VPS，在新加坡的节点，每个月5美元，其实是按小时计费，每小时0.007美元，如果出问题了可以方便的停止购买，不像其他厂商按年一次性付费的话，万一不能用了就很亏。操作系统选择 CentOS 7 64位。</p><h1 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h1><h3 id="安装-Shadowsocks-服务"><a href="#安装-Shadowsocks-服务" class="headerlink" title="安装 Shadowsocks 服务"></a>安装 Shadowsocks 服务</h3><p>shadowsocks有很多版本，如Python，node.js，libev，Go等，Python版本用的人是最多的，但很久没有更新了，这里选择 Go 版本的shadowsocks。</p><p>在安装shadowsocks之前需要先<strong>安装 Go 语言的环境</strong>：</p><ul><li><p>从官网下载 Linux 平台的源码包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># wget https://dl.google.com/go/go1.10.3.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>解压到指定目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sudo tar zxvf go1.10.3.linux-amd64.tar.gz -C /usr/local/</span><br></pre></td></tr></table></figure></li><li><p>配置环境变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># vi .bashrc</span><br><span class="line">添加</span><br><span class="line">export PATH=$PATH:/usr/local/go/bin</span><br></pre></td></tr></table></figure><p>保存并使生效：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># source .bashrc</span><br></pre></td></tr></table></figure></li></ul><p><strong>安装 shadowsocks</strong>，使用一键安装脚本（<a href="https://github.com/iMeiji/shadowsocks_install）" target="_blank" rel="noopener">https://github.com/iMeiji/shadowsocks_install）</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># wget --no-check-certificate https://raw.githubusercontent.com/iMeiji/shadowsocks_install/master/shadowsocks-go.sh</span><br><span class="line"># chmod +x shadowsocks-go.sh</span><br><span class="line"># ./shadowsocks-go.sh 2&gt;&amp;1 | tee shadowsocks-go.log</span><br></pre></td></tr></table></figure><p><strong>卸载 shadowsocks 方法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ./shadowsocks-go.sh uninstall</span><br></pre></td></tr></table></figure><p><strong>shadowsocks 常用命令：</strong></p><ul><li>启动：<code>/etc/init.d/shadowsocks start</code></li><li>停止：<code>/etc/init.d/shadowsocks stop</code></li><li>重启：<code>/etc/init.d/shadowsocks restart</code> </li><li>状态：<code>/etc/init.d/shadowsocks status</code></li></ul><p>执行完前面的安装脚本后，查看 shadowsocks 的运行状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># /etc/init.d/shadowsocks status</span><br><span class="line">shadowsocks-go running with PID 1629</span><br></pre></td></tr></table></figure><p>能看到进程 ID 说明 shadowsocks 服务已经在运行了。</p><p><strong>配置 shadowsocks 开机自启动：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># vi /etc/rc.local</span><br><span class="line">添加</span><br><span class="line">/etc/init.d/shadowsocks restart</span><br></pre></td></tr></table></figure><p>这样在系统重启后就可以自动加载 shadowsocks 服务了。</p><p><strong>配置防火墙：</strong></p><p>检查防火墙是否允许你设定的端口进行通信</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># iptables -vnL | grep 8989</span><br></pre></td></tr></table></figure><p>如果没有信息的话，就是防火墙不允许该端口进行通信。 </p><p>需设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># firewall-cmd --zone=public --add-port=8989/tcp --permanent</span><br><span class="line"># firewall-cmd --reload</span><br></pre></td></tr></table></figure><blockquote><p>由于 CentOS 7 默认安装的是 firewalld，并没有安装 iptables-services，不能使用 iptables-save 来保存iptables 规则并在下次启动时自动加载，所以上面使用是 firewalld 来配置永久规则，这样在关机重启后规则也不会消失。</p></blockquote><p>到这里，shadowsocks 服务器就基本上已经配置好了，你可以使用客户端来上外网了。但这时候的网络连接的速度可能只能够保证查查网页，如果要下载或者看 YouTube 速度很慢，所以后将进行配置TCP 加速。</p><hr><h3 id="TCP-加速"><a href="#TCP-加速" class="headerlink" title="TCP 加速"></a>TCP 加速</h3><p>在后面会升级系统内核，所以先查看一下服务器的内核版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># uname -a</span><br><span class="line">Linux vultr.guest 3.10.0-862.3.2.el7.x86_64 #1 SMP Mon May 21 23:36:36 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure><p>加速有锐速加速和 Google BBR 加速，这里使用 BBR 加速。TCP BBR是谷歌出品的 TCP 拥塞控制算法，目的是要尽量跑满带宽，并且尽量不要有排队的情况。BBR 可以起到单边加速 TCP 连接的效果。</p><p>Google提交到Linux主线并发表在ACM  queue期刊上的TCP-BBR拥塞控制算法。继承了Google“先在生产环境上部署，再开源和发论文”的研究传统。TCP-BBR已经再YouTube服务器和Google跨数据中心的内部广域网(B4)上部署。由此可见出该算法的前途。 </p><p>TCP-BBR的目标就是最大化利用网络上瓶颈链路的带宽。一条网络链路就像一条水管，要想最大化利用这条水管，最好的办法就是给这跟水管灌满水。 </p><p>BBR解决了两个问题： </p><ul><li>在有一定丢包率的网络链路上充分利用带宽。非常适合高延迟，高带宽的网络链路。 </li><li>降低网络链路上的buffer占用率，从而降低延迟。非常适合慢速接入网络的用户。 </li></ul><p>Google 在 2016年9月份开源了他们的优化网络拥堵算法BBR，最新版本的 Linux内核(4.9-rc8)中已经集成了该算法。 </p><p><strong>一键安装脚本：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh</span><br><span class="line"># chmod +x bbr.sh</span><br><span class="line"># ./bbr.sh</span><br></pre></td></tr></table></figure><p>安装完成后会提示重启，重启完成后，查看内核：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># uname -r</span><br><span class="line">4.18.3-1.el7.elrepo.x86_64</span><br></pre></td></tr></table></figure><p>高于 4.9 就可以了</p><p>检查是否开启 BBR：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># sysctl net.ipv4.tcp_available_congestion_control</span><br><span class="line">net.ipv4.tcp_available_congestion_control = reno cubic bbr</span><br><span class="line"></span><br><span class="line"># sysctl net.ipv4.tcp_congestion_control</span><br><span class="line">net.ipv4.tcp_congestion_control = bbr</span><br><span class="line"></span><br><span class="line"># sysctl net.core.default_qdisc</span><br><span class="line">net.core.default_qdisc = fq</span><br><span class="line"></span><br><span class="line"># lsmod | grep bbr</span><br><span class="line">tcp_bbr                20480  7</span><br><span class="line">#返回值有 tcp_bbr 则说明已经启动</span><br></pre></td></tr></table></figure><p>完成以上步骤，则 TCP 加速也已经配置好了，接下来就可以体验飞快的下载速度以及 1080p 的高清视屏啦！</p><p>shadowsocks 客户端下载连接：<a href="https://shadowsocks.org/en/download/clients.html" target="_blank" rel="noopener">Shadowsocks - Clients</a> </p>]]></content>
      
      <categories>
          
          <category> VPN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> centos </tag>
            
            <tag> shadowsocks </tag>
            
            <tag> BBR </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>KVM 虚拟机磁盘扩容</title>
      <link href="/2018/07/24/KVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A3%81%E7%9B%98%E6%89%A9%E5%AE%B9/"/>
      <url>/2018/07/24/KVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A3%81%E7%9B%98%E6%89%A9%E5%AE%B9/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在 KVM 环境中，通常通过创建一个各种格式的磁盘来安装虚拟机，可能创建时你觉得大小够用，但是可能用着用着到了某一天你发现你的磁盘容量不够用了，很多程序都打不开，你可能会很慌，其实并不需要慌，因为有很多方法可以给你的虚拟机扩容，哈哈哈，如：</p><ul><li>通过<code>virsh attach-disk</code>添加一个新的磁盘</li><li>通过<code>virsh attach-device</code>添加一个新的存储设备</li><li>直接给原来用的磁盘扩容</li></ul><a id="more"></a><p>上面的三种方法都能实现给你的虚拟机扩容，但是本文想介绍的是第三种方法，直接给安装了虚拟机的磁盘来扩容，这样的好处是在你的主机上看来一个虚拟机就是一个磁盘，管理方便，而且只通过这一个磁盘来分享迁移你的虚拟机，也是更方便。</p><p>#创建虚拟机</p><ol><li><p><strong>创建磁盘</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ qemu-img create -f qcow2 centos.qcow2 50G</span><br></pre></td></tr></table></figure><p>这里创建了一个50G的磁盘，格式为qcow2，这种格式的特点是分配给虚拟机的实际使用的磁盘的大小是动态增长的，并不是一下子把所有的空间都给配给虚拟机，可以通过命令查看磁盘信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ qemu-img info centos.qcow2</span><br><span class="line">image: centos.qcow2</span><br><span class="line">file format: qcow2</span><br><span class="line">virtual size: 50G (53687091200 bytes)</span><br><span class="line">disk size: 1.2G</span><br><span class="line">cluster_size: 65536</span><br><span class="line">Format specific information:</span><br><span class="line">    compat: 1.1</span><br><span class="line">    lazy refcounts: false</span><br><span class="line">    refcount bits: 16</span><br><span class="line">    corrupt: false</span><br></pre></td></tr></table></figure><p>可以看到50G的磁盘目前的实际大小只有1.2个G。</p></li><li><p><strong>安装虚拟机</strong></p><p>可以通过 virt-manager 通过图形界面安装，但是我一般都是通过远程连接服务器的，所以常用命令行安装虚拟机，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ virt-install --virt-type kvm --name test-centos --ram 2048 --vcpus=1 \</span><br><span class="line">--cdrom CentOS-7-x86_64-Minimal-1804.iso \</span><br><span class="line">--disk path=test-centos.qcow2,format=qcow2 \</span><br><span class="line">--network network=default,model=virtio \</span><br><span class="line">--graphics vnc,listen=0.0.0.0 --noautoconsole \</span><br><span class="line">--os-type=linux</span><br></pre></td></tr></table></figure><p>系统安装的过程就不介绍了，但在安装系统的过程中，对于磁盘分区部分一般分两个区，根目录 <code>/</code> 和 交换分区 <code>swap</code> 。</p></li><li><p><strong>查看虚拟机磁盘</strong></p><ul><li><p>查看磁盘空间信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ df -lh</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/sda2        46G  1.1G   45G   3% /</span><br><span class="line">devtmpfs        909M     0  909M   0% /dev</span><br><span class="line">tmpfs           920M     0  920M   0% /dev/shm</span><br><span class="line">tmpfs           920M  8.5M  911M   1% /run</span><br><span class="line">tmpfs           920M     0  920M   0% /sys/fs/cgroup</span><br><span class="line">tmpfs           184M     0  184M   0% /run/user/1000</span><br><span class="line">tmpfs           184M     0  184M   0% /run/user/0</span><br></pre></td></tr></table></figure><p>可以看到 <code>/dev/sda2</code> 被挂载到了系统根目录 <code>/</code> </p></li><li><p>查看系统磁盘分区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># fdisk -l</span><br><span class="line">Disk /dev/sda: 53.7 GB, 53687091200 bytes, 104857600 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disk label type: dos</span><br><span class="line">Disk identifier: 0x00015299</span><br><span class="line"></span><br><span class="line">   Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sda1            2048     8390655     4194304   82  Linux swap / Solaris</span><br><span class="line">/dev/sda2   *     8390656   104857599    48233472   83  Linux</span><br></pre></td></tr></table></figure><p>我这里系统磁盘被成了两个区：/dev/sda1 和 /dev/sda2，就是我们前面说的一个用于交换分区，另一个用于挂载到根目录。</p><blockquote><p>注：磁盘分区信息中可以看到原来我们 50个G 的磁盘到这里怎么变成 53.7GB 了呢？其实只是单位不一样而已，前面我们用的是 GiB 为单位，这两个单位的计算方式不同，<code>1 GiB = 1024*1024*1024 Bytes</code>，而 <code>1GB = 1000*1000*1000 Bytes</code> 。</p></blockquote><p>到这里，假如我们发现磁盘空间不够用了，接下来就来看看如何给虚拟机的磁盘扩容吧。</p></li></ul></li></ol><h1 id="磁盘扩容"><a href="#磁盘扩容" class="headerlink" title="磁盘扩容"></a>磁盘扩容</h1><ol><li><p>首先将我们的虚拟机关机，然后进行<strong>磁盘扩容</strong>，在服务器主机上操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># qemu-img resize centos.qcow2 60G</span><br><span class="line">Image resized.</span><br></pre></td></tr></table></figure><p>上面我们把磁盘大小扩成了 60G</p></li><li><p>重启虚拟机，在虚拟机内，使用 <code>fdisk</code> 指令<strong>对磁盘进行分区：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"># fdisk /dev/sda     #我们的整块磁盘是sda，对整个磁盘进行分区</span><br><span class="line">Command (m for help): p</span><br><span class="line"></span><br><span class="line">Disk /dev/sda: 64.4 GB, 64424509440 bytes, 125829120 sectors   #磁盘大小变成64.4GB了，扩容成功</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disk label type: dos</span><br><span class="line">Disk identifier: 0x00015299</span><br><span class="line"></span><br><span class="line">   Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sda1            2048     8390655     4194304   82  Linux swap / Solaris</span><br><span class="line">/dev/sda2   *     8390656   104857599    48233472   83  Linux   #结束sector号小于磁盘的总数</span><br><span class="line"></span><br><span class="line">Command (m for help): n</span><br><span class="line">Partition type:</span><br><span class="line">   p   primary (2 primary, 0 extended, 2 free)</span><br><span class="line">   e   extended</span><br><span class="line">Select (default p): e    #添加扩展分区</span><br><span class="line">Partition number (3,4, default 3): 3  #分区号，填写默认的3</span><br><span class="line">First sector (104857600-125829119, default 104857600):   #直接回车选择默认</span><br><span class="line">Using default value 104857600</span><br><span class="line">Last sector, +sectors or +size&#123;K,M,G&#125; (104857600-125829119, default 125829119): #回车选择默认 </span><br><span class="line">Using default value 125829119</span><br><span class="line">Partition 3 of type Extended and of size 10 GiB is set</span><br><span class="line"></span><br><span class="line">Command (m for help): p    #再次查看分区表</span><br><span class="line"></span><br><span class="line">Disk /dev/sda: 64.4 GB, 64424509440 bytes, 125829120 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disk label type: dos</span><br><span class="line">Disk identifier: 0x00015299</span><br><span class="line"></span><br><span class="line">   Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sda1            2048     8390655     4194304   82  Linux swap / Solaris</span><br><span class="line">/dev/sda2   *     8390656   104857599    48233472   83  Linux</span><br><span class="line">/dev/sda3       104857600   125829119    10485760    5  Extended   #新添加的扩展分区</span><br><span class="line"></span><br><span class="line">Command (m for help): n    #再添加逻辑分区，因为扩展分区是不能格式化后挂载的</span><br><span class="line">Partition type:</span><br><span class="line">   p   primary (2 primary, 1 extended, 1 free)</span><br><span class="line">   l   logical (numbered from 5)</span><br><span class="line">Select (default p): l    #逻辑分区</span><br><span class="line">Adding logical partition 5</span><br><span class="line">First sector (104859648-125829119, default 104859648):   #回车选择默认</span><br><span class="line">Using default value 104859648</span><br><span class="line">Last sector, +sectors or +size&#123;K,M,G&#125; (104859648-125829119, default 125829119): #回车选择默认</span><br><span class="line">Using default value 125829119</span><br><span class="line">Partition 5 of type Linux and of size 10 GiB is set</span><br><span class="line"></span><br><span class="line">Command (m for help): p</span><br><span class="line"></span><br><span class="line">Disk /dev/sda: 64.4 GB, 64424509440 bytes, 125829120 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disk label type: dos</span><br><span class="line">Disk identifier: 0x00015299</span><br><span class="line"></span><br><span class="line">   Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sda1            2048     8390655     4194304   82  Linux swap / Solaris</span><br><span class="line">/dev/sda2   *     8390656   104857599    48233472   83  Linux</span><br><span class="line">/dev/sda3       104857600   125829119    10485760    5  Extended</span><br><span class="line">/dev/sda5       104859648   125829119    10484736   83  Linux   #新添加的逻辑分区</span><br><span class="line"></span><br><span class="line">Command (m for help): w   #保存分区配置，并退出 </span><br><span class="line">The partition table has been altered!</span><br><span class="line"></span><br><span class="line">Calling ioctl() to re-read partition table.</span><br><span class="line"></span><br><span class="line">WARNING: Re-reading the partition table failed with error 16: Device or resource busy.</span><br><span class="line">The kernel still uses the old table. The new table will be used at</span><br><span class="line">the next reboot or after you run partprobe(8) or kpartx(8)</span><br><span class="line">Syncing disks.    #需要重启或者重新获取分区表</span><br><span class="line">#</span><br></pre></td></tr></table></figure></li><li><p><strong>重新获取分区表：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># partprobe</span><br></pre></td></tr></table></figure></li><li><p><strong>格式化分区：</strong></p><p>可以先查看一下其他分区是什么格式的文件系统：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># mount |grep /dev/sda</span><br><span class="line">/dev/sda2 on / type xfs (rw,relatime,seclabel,attr2,inode64,noquota)</span><br></pre></td></tr></table></figure><p><code>/dev/sda2</code> 是 <code>xfs</code> 格式的，CentOS 7默认文件系统格式是xfs，在CentOS 6以及之前的版本，使用的是ext文件系统格式，CentOS 6是ext4格式、CentOS 5是ext3格式。那我们也把 <code>/dev/sda5</code> 格式化成一样格式的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># mkfs -t xfs /dev/sda5     #-t 指定格式 </span><br><span class="line">meta-data=/dev/sda5              isize=512    agcount=4, agsize=655296 blks</span><br><span class="line">         =                       sectsz=512   attr=2, projid32bit=1</span><br><span class="line">         =                       crc=1        finobt=0, sparse=0</span><br><span class="line">data     =                       bsize=4096   blocks=2621184, imaxpct=25</span><br><span class="line">         =                       sunit=0      swidth=0 blks</span><br><span class="line">naming   =version 2              bsize=4096   ascii-ci=0 ftype=1</span><br><span class="line">log      =internal log           bsize=4096   blocks=2560, version=2</span><br><span class="line">         =                       sectsz=512   sunit=0 blks, lazy-count=1</span><br><span class="line">realtime =none                   extsz=4096   blocks=0, rtextents=0</span><br></pre></td></tr></table></figure></li><li><p><strong>挂载磁盘：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># mount /dev/sda5  /mnt/newdisk</span><br></pre></td></tr></table></figure><p>将 <code>/dev/sda5</code> 挂载到 <code>/mnt/newdisk</code>，需要注意的是，<code>newdisk</code> 最好是一个空文件夹，不然挂载之后文件夹内的文件将会暂时隐藏，直到你卸载到磁盘后才能恢复。</p></li><li><p><strong>查看磁盘空间信息：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># df -lh</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/sda2        46G  1.1G   45G   3% /</span><br><span class="line">devtmpfs        909M     0  909M   0% /dev</span><br><span class="line">tmpfs           920M     0  920M   0% /dev/shm</span><br><span class="line">tmpfs           920M  8.5M  911M   1% /run</span><br><span class="line">tmpfs           920M     0  920M   0% /sys/fs/cgroup</span><br><span class="line">tmpfs           184M     0  184M   0% /run/user/1000</span><br><span class="line">/dev/sda5        10G   33M   10G   1% /mnt/newdisk</span><br></pre></td></tr></table></figure><p>到这里就基本上结束了，你的磁盘又多了 10个G 的容量，可以正常读写磁盘啦。</p></li></ol><h1 id="命令附录"><a href="#命令附录" class="headerlink" title="命令附录"></a>命令附录</h1><p>这里先介绍几个会用到的关于Linux磁盘操作指令：</p><ol><li><p><strong>df 指令</strong>：磁盘信息命令 </p><ul><li><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ df [OPTION]... [FILE]...</span><br></pre></td></tr></table></figure></li><li><p>功能说明：</p><blockquote><p>使用 df 指令查看磁盘空间的信息。指令可以查看指定文件系统的占用情况。如果指令中未指定文件名，将显示当前所有挂载的文件系统的可用空间。</p></blockquote></li><li><p>参数说明：</p><p>|        参数         |                   说明                    |<br>| :—————–: | :—————————————: |<br>|         -a          |   显示包括0区块在内的所有文件系统的情况   |<br>|         -h          |        以可读性较高的方式显示信息         |<br>|         -H          | 相当于“-h”但在计算时，1K=1000，而不是1024 |<br>|         -i          |            显示 inode 节点信息            |<br>|         -k          |            区块大小为1024字节             |<br>|         -l          |            尽显示本地文件系统             |<br>|      –no-sync      |      取得磁盘信息前，忽略 sync 指令       |<br>|         -P          |              输出 POSIX 格式              |<br>|       –sync        |    在取得磁盘信息前，先执行 sync 指令     |<br>|         -T          |             显示文件系统类型              |<br>| –block-size=<size> |               指定区块大小                |<br>| -t filesystem-type  |       只显示选定文件系统的磁盘信息        |<br>| -x filesystem-type  |       不显示选定文件系统的磁盘信息        |<br>|       –help        |                 帮助信息                  |<br>|      –version      |                 版本信息                  |</size></p></li><li><p>常用命令：<code>$ df -lh</code></p></li></ul></li><li><p><strong>fdisk 指令</strong>：Linux磁盘分区命令 </p><ul><li><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fdisk [options] &lt;disk&gt;    change partition table</span><br><span class="line">fdisk [options] -l &lt;disk&gt; list partition table(s)</span><br><span class="line">fdisk -s &lt;partition&gt;      give partition size(s) in blocks</span><br></pre></td></tr></table></figure></li><li><p>功能说明：</p><blockquote><p>fdisk 指令是Linux下管理分区的程序。应用该程序不仅可以创建磁盘分区，还可以对磁盘进行维护，改变分区类型。</p></blockquote></li><li><p>参数说明：</p><p>|    参数     |              说明              |<br>| :———: | :—————————-: |<br>|  -b <size>  |         指定各分区大小         |<br>|     -l      |         列出分区表情况         |<br>| -s <number> | 输出指定分区大小到标准输出设备 |<br>|     -u      |  与“-l”参数搭配，显示分区数目  |<br>|     -v      |            版本信息            |</number></size></p><p>【fdisk 程序指令】</p><ul><li><strong>a：</strong>设置/删除可引导分区标记</li><li><strong>d：</strong>删除指定分区</li><li><strong>l：</strong>列出分区类型</li><li><strong>m：</strong>显示 fdisk 程序指令</li><li><strong>n：</strong>新建分区</li><li><strong>p：</strong>列出当前分区信息</li><li><strong>q：</strong>退出 fdisk 分区，对更改不保存</li><li><strong>t：</strong>改变分区 ID</li><li><strong>v：</strong>检测当前分区信息</li><li><strong>w：</strong>退出 fdisk 分区，保存更改</li></ul><p><strong>注：</strong>不同的版本略差别</p></li></ul></li><li><p><strong>mkfs 指令</strong>：建立各种文件系统</p><ul><li><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># mkfs [options] [-t &lt;type&gt;] [fs-options] &lt;device&gt; [&lt;size&gt;]</span><br></pre></td></tr></table></figure></li><li><p>功能说明：</p><blockquote><p> mkfs 指令可用来在指定的设备上建立各种文件系统，它通过调用相关的程序来执行文件系统的构建，本身并不执行系统构建。</p></blockquote></li><li><p>参数说明：</p><p>|         参数         |                          说明                          |<br>| :——————: | :—————————————————-: |<br>|          -c          |        在创建文件系统之前，检查是否有损坏的区块        |<br>|          fs          | 指定建立文件系统时的参数，针对不同的文件系统的参数不同 |<br>| -t <filesystem type=""> |         指定要创建的文件系统的类型，默认为ext2         |<br>|          -v          |                   显示详细的处理信息                   |<br>|          -V          |                        版本信息                        |</filesystem></p></li><li><p>常用命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># mkfs -t ext3 /dev/sda3</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>mount 指令</strong>：挂载文件系统</p><ul><li><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># mount [options] &lt;source&gt; &lt;directory&gt;</span><br></pre></td></tr></table></figure></li><li><p>功能说明：</p><blockquote><p> 使用 mount 指令可将指定设备挂载到已存在的目录。当文件系统挂载完成后，用户可通过该目录进行操作，来实现对指定设备的文件读写等操作。</p></blockquote></li><li><p>必要参数说明：</p><p>|    参数     |       说明       |<br>| :———: | :————–: |<br>|   <souce>   | 指定要挂载的设备 |<br>| <directory> | 指定要挂载的目录 |</directory></souce></p></li><li><p>常用示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># mount /dev/sda3  /mnt</span><br></pre></td></tr></table></figure></li></ul></li></ol><hr>]]></content>
      
      <categories>
          
          <category> KVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KVM </tag>
            
            <tag> 磁盘扩容 </tag>
            
            <tag> df </tag>
            
            <tag> fdisk </tag>
            
            <tag> mkfs </tag>
            
            <tag> mount </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于Linux Shell新的收获</title>
      <link href="/2018/07/21/%E5%85%B3%E4%BA%8EShell%E6%96%B0%E7%9A%84%E6%94%B6%E8%8E%B7/"/>
      <url>/2018/07/21/%E5%85%B3%E4%BA%8EShell%E6%96%B0%E7%9A%84%E6%94%B6%E8%8E%B7/</url>
      <content type="html"><![CDATA[<p>最近又翻阅了几本Linux相关的工具书，在这里记录一些关于Linux shell的新的小小的收获。</p><a id="more"></a><h1 id="查看正在使用的shell"><a href="#查看正在使用的shell" class="headerlink" title="查看正在使用的shell"></a>查看正在使用的shell</h1><p>有很多方法可以查看当前正在使用的shell：</p><ul><li><p>使用特殊参数<code>$0</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo $0</span><br><span class="line">-bash</span><br></pre></td></tr></table></figure><p>对于这里有点疑问的是有资料说在<strong>本地系统</strong>执行可能的结果会是<code>/bin/bash</code>，但是我尝试了一下发现结果还是<code>bash</code>或者<code>-bash</code>。不知道资料中说的本地系统指的是什么意思。</p></li><li><p>输入不存在的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ asdf</span><br><span class="line">-bash: asdf: command not found</span><br></pre></td></tr></table></figure><p>从shell提示中可以看出当前正在使用的shell是bash。</p></li></ul><h1 id="查看用户登录默认的shell"><a href="#查看用户登录默认的shell" class="headerlink" title="查看用户登录默认的shell"></a>查看用户登录默认的shell</h1><ul><li><p>通过查看<code>/etc/passwd</code>文件找到用户对应的那一行，最后一列就是用户登录的shell</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user1@ubuntu:~$ cat /etc/passwd | grep user1</span><br><span class="line">user1:x:1000:1000:user1,,,:/home/user1:/bin/bash</span><br></pre></td></tr></table></figure></li><li><p>最常用的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo $SHELL</span><br><span class="line">/bin/bash</span><br></pre></td></tr></table></figure></li><li><p>从环境变量中查看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ env |grep SHELL</span><br><span class="line">SHELL=/bin/bash</span><br></pre></td></tr></table></figure></li></ul><h1 id="切换用户正在使用的shell"><a href="#切换用户正在使用的shell" class="headerlink" title="切换用户正在使用的shell"></a>切换用户正在使用的shell</h1><p>直接输入对应shell的命令即可切换：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ echo $0</span><br><span class="line">-bash    &lt;==当前正在使用的shell</span><br><span class="line">$ zsh    &lt;==运行zsh</span><br><span class="line">$ echo $0</span><br><span class="line">zsh      &lt;==当前正在使用的shell已经变成zsh</span><br></pre></td></tr></table></figure><h1 id="修改用户的登录shell"><a href="#修改用户的登录shell" class="headerlink" title="修改用户的登录shell"></a>修改用户的登录shell</h1><ul><li><p>首先可以查看用户合法的shell：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ chsh -l</span><br><span class="line">/bin/sh</span><br><span class="line">/bin/bash</span><br><span class="line">/sbin/nologin   &lt;==合法不可登录的shell</span><br><span class="line">/bin/tcsh</span><br><span class="line">/bin/csh</span><br><span class="line">/bin/mksh</span><br><span class="line">/bin/ksh</span><br><span class="line">/bin/zsh</span><br></pre></td></tr></table></figure><p><code>chsh -l</code>命令并不总是可用，对于某些Linux发行版，<code>chsh</code>命令没有<code>-l</code>的选项，如<code>ubuntu16.04</code>，但是可以直接查看/etc/shells文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ cat /etc/shells</span><br><span class="line">/bin/sh</span><br><span class="line">/bin/bash</span><br><span class="line">/sbin/nologin   &lt;==合法不可登录的shell</span><br><span class="line">/bin/tcsh</span><br><span class="line">/bin/csh</span><br><span class="line">/bin/mksh</span><br><span class="line">/bin/ksh</span><br><span class="line">/bin/zsh</span><br></pre></td></tr></table></figure></li><li><p>修改用户登录shell</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ chsh -s /bin/zsh</span><br><span class="line">Password:</span><br><span class="line">$ cat /etc/passwd | grep user1</span><br><span class="line">user1:x:1000:1000:user1,,,:/home/user1:/bin/zsh   &lt;== /etc/passwd文件中已经发生变化</span><br><span class="line">$ echo $SHELL</span><br><span class="line">/bin/bash      &lt;==但是再次查看$SHELL，发现并没有变，其实退出shell再次登录就会看到变化了</span><br></pre></td></tr></table></figure></li></ul><hr>]]></content>
      
      <categories>
          
          <category> Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
            <tag> linux </tag>
            
            <tag> chsh </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>自动化脚本与程序实现</title>
      <link href="/2018/07/09/%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC%E4%B8%8E%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/07/09/%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC%E4%B8%8E%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>最近的项目中有远程登录虚拟机并执行相关命令的需求，所以尝试了远程免密码登录虚拟机（在另一篇博客中有介绍<a href="https://cao0507.github.io/2018/07/07/远程免密码登录Openstack实例/">链接</a>)。但是发现这还不够，因为登录远程虚拟机后执行的脚本可能会有需要交互的操作，比如<code>sudo</code>命令需要输入密码，所以就想实现一个完全自动化的脚本，包括登录时的密码自动输入以及登录后执行命令的自动交互。查阅相关资料后学习到，在Linux中可以用<code>expect</code>来实现自动化的交互，且在python中也有相应的一个模块pexpect具有此功能。本文将先介绍<strong>shell自动化交互脚本</strong>的实现，然后介绍其<strong>python程序实现</strong>。</p><a id="more"></a><h1 id="shell脚本"><a href="#shell脚本" class="headerlink" title="shell脚本"></a>shell脚本</h1><h2 id="Expect介绍"><a href="#Expect介绍" class="headerlink" title="Expect介绍"></a>Expect介绍</h2><ol><li><p>简要介绍：</p><p>Expect 是由Don Libes基于<code>Tcl（Tool Command Language）</code>语言开发的，主要应用于自动化交互式操作的场景，借助expect处理交互的命令，可以将交互过程如：ssh登录，ftp登录等写在一个脚本上，使之自动化完成。尤其适用于需要对多台服务器执行相同操作的环境中，可以大大提高系统管理人员的工作效率 。</p></li><li><p>主要命令：</p><ul><li><p><strong>spawn</strong>：启动新的进程</p><p><code>spawn</code>命令会<code>fork</code>一个子进程去执行<code>command</code>命令，然后在此子进程中执行后面的命令；<code>spawn</code>后的<code>send</code>和<code>expect</code>命令都是和<code>spawn</code>打开的进程进行交互的。如果没有<code>spawn</code>语句，整个<code>Expect</code>就无法进行下去，当然，如果真的不要<code>spawn</code>过程也没有关系，虽然这样就没有办法单独执行，但是这个脚本可以与任何调用它的进程进行交互。 </p><p><strong>使用方法：</strong>ssh自动登录脚本中，通过<code>spawn ssh user_name@ip_addr</code>，<code>fork</code>一个子进程执行ssh登录命令；连接远程ftp服务器，<code>spawn ftp ftp.server.com</code>。</p></li><li><p><strong>expect</strong>：从进程接收字符串</p><p><code>expect</code>命令是Expect解释器的关键命令，它的一般用法为 <code>expect “string”</code>，即期望获取到<code>string</code>字符串，可在在<code>string</code>字符串里使用 * 等通配符。</p><p><strong>使用方法：</strong>在执行<code>spawn</code>命令ssh登录时，子进程会要求输入密码，因此可以使用<code>expect</code>命令检查子进程中的输出中是否包含<code>“password”</code>子字符串，命令为<code>expect &quot;password&quot;</code>。</p></li><li><p><strong>send</strong>：用于向进程发送字符串</p><p>send命令的一般用法为 send “string”，它们会我们平常输入命令一样向命令行输入一条信息，当然不要忘了在string后面添加上 \r 表示输入回车 。</p><p><strong>使用方法：</strong>在使用expect命令接收到字符串“password”后，就需要使用send命令来发送“PASSWORD”。</p></li><li><p><strong>interact</strong>：允许用户交互</p><p><code>interact</code>命令很简单，执行到此命令时，脚本<code>fork</code>的子进程会将操作权交给用户，允许用户与当前shell进行交互，让人在适当的时候干预这个过程了 。</p><p><strong>使用方法：</strong>直接在脚本适当的位置加入一行<code>interact</code>。</p></li></ul></li><li><p>安装方法：</p><p><code>$ sudo apt-get install expect</code></p></li></ol><h2 id="脚本编写"><a href="#脚本编写" class="headerlink" title="脚本编写"></a>脚本编写</h2><p>我需要实现一个脚本，其功能是ssh登录虚拟机，并在远程虚拟机用户目录下记录远程登录的日志文件，然后修改其<code>iptables</code>规则，禁止转发tcp 22号端口的报文。</p><ul><li><p>ssh登录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spawn ssh $user@$ip</span><br><span class="line">expect &#123;</span><br><span class="line">    &quot;(yes/no)&quot; &#123;send &quot;yes\r&quot;; exp_continue&#125;</span><br><span class="line">    &quot;password:&quot; &#123;send &quot;$password\r&quot;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>expect中可能会接收到两种字符串，”(yes/no)”表示你的主机还未登录过远程虚拟机，即你的用户目录下的文件<code>~/.ssh/know_hosts</code>中还未记录该远程虚拟机，问你是否需要将其添加到<code>know_hosts</code>中，回复”yes”，下次再登录就不会出现这个提醒了；然后就会收到<code>&quot;password:&quot;</code>，这时就需要将密码发送过去，这样就已经登录到远程虚拟机。</p></li><li><p>记录日志文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect &quot;*$&quot; &#123;send &quot;echo &apos;login +1&apos; &gt;&gt; ~/remote_login.log\r&quot;&#125;</span><br></pre></td></tr></table></figure><p>登录之后会收到”$”或”#”的命令行提示符，然后就可以发送需要执行的命令了。</p></li><li><p>修改<code>iptables</code>规则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect &quot;*$&quot; &#123;send &quot;sudo iptables -A FORWARD -p tcp --dport 22 -j REJECT\r&quot;&#125;</span><br><span class="line">expect &quot;password&quot; &#123;send &quot;$password\r&quot;&#125;</span><br></pre></td></tr></table></figure></li><li><p>退出子程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect &quot;*$&quot; &#123;send exit\r&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>完整的脚本：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/expect</span><br><span class="line">set ip 192.168.1.75</span><br><span class="line">set user openstack</span><br><span class="line">set passwd 123456</span><br><span class="line">set timeout 5</span><br><span class="line"></span><br><span class="line">spawn ssh $user@$ip</span><br><span class="line">expect &#123;</span><br><span class="line">    &quot;(yes/no)&quot; &#123;send &quot;yes\r&quot;; exp_continue&#125;</span><br><span class="line">    &quot;password:&quot; &#123;send &quot;$password\r&quot;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">expect &quot;*$&quot; &#123;send &quot;echo &apos;login +1&apos; &gt;&gt; ~/remote_login.log\r&quot;&#125;;</span><br><span class="line"></span><br><span class="line">expect &quot;*$&quot; &#123;send &quot;sudo iptables -A FORWARD -p tcp --dport 22 -j REJECT\r&quot;&#125;;</span><br><span class="line">expect &quot;password&quot; &#123;send &quot;$passwd\r&quot;&#125;;</span><br><span class="line"></span><br><span class="line">expect &quot;*$&quot; &#123;send exit\r&#125;;</span><br><span class="line">expect eof;</span><br></pre></td></tr></table></figure><h1 id="python程序"><a href="#python程序" class="headerlink" title="python程序"></a>python程序</h1><h2 id="Pexpect介绍"><a href="#Pexpect介绍" class="headerlink" title="Pexpect介绍"></a>Pexpect介绍</h2><p>Pexpect 是Expect 的一个 Python 实现，是一个用来启动子程序，并使用正则表达式对程序输出做出特定响应，以此实现与其自动交互的 Python 模块。 Pexpect 的使用范围很广，可以用来实现与 <code>ssh、ftp 、telnet</code>  等程序的自动交互；可以用来自动复制软件安装包并在不同机器自动安装；还可以用来实现软件测试中与命令行交互的自动化。</p><p>其依赖 <code>pty module</code> ，所以 <code>Pexpect</code> 还不能在 Windows 的标准 python 环境中执行，如果想在 Windows 平台使用，可以使用在 Windows 中运行 Cygwin 做为替代方案。</p><p><code>pexpect</code>主要包含两个接口，一个是<code>run()</code>函数，另一个是<code>spawn</code>类。<code>spawn</code>类的功能很强大，<code>run()</code>函数要更简单，更适用于快速调用程序。</p><ol><li><p><code>spawn class</code></p><p>使用这个类来开始和控制子程序。</p><ul><li><p><code>spawn</code>的构造函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class spawn:</span><br><span class="line">    def __init__(self,command,args=[],timeout=30,maxread=2000,\</span><br><span class="line">    searchwindowsize=None, logfile=None, cwd=None, env=None)</span><br></pre></td></tr></table></figure><p><code>spawn</code>是<code>Pexpect</code>模块主要的类，用以实现启动子程序，它有丰富的方法与子程序交互从而实现用户对子程序的控制。它主要使用 <code>pty.fork()</code> 生成子进程，并调用 <code>exec()</code> 系列函数执行 <code>command</code> 参数的内容。  使用示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">child = pexpect.spawn(&apos;/usr/bin/ftp&apos;)</span><br><span class="line">child = pexpect.spawn(&apos;/usr/bin/ssh user@example.com&apos;)</span><br></pre></td></tr></table></figure><p>由于需要实现不断匹配子程序输出， <code>searchwindowsize</code> 指定了从输入缓冲区中进行模式匹配的位置，默认从开始匹配。 </p></li><li><p>使用<code>pexpect</code>控制子程序</p><ul><li><p><code>expect()</code>定义</p><p><code>expect(self, pattern, timeout=-1, searchwindowsize=None)</code> </p><p>在参数中： <code>pattern</code> 可以是正则表达式， <code>pexpect.EOF</code> ， <code>pexpect.TIMEOUT</code>  ，或者由这些元素组成的列表。需要注意的是，当 <code>pattern</code>  的类型是一个列表时，且子程序输出结果中不止一个被匹配成功，则匹配返回的结果是缓冲区中最先出现的那个元素，或者是列表中最左边的元素。使用  <code>timeout</code> 可以指定等待结果的超时时间 ，该时间以秒为单位。当超过预订时间时， <code>expect</code> 匹配到<code>pexpect.TIMEOUT</code>。</p><p><code>expect</code> 不断从读入缓冲区中匹配目标正则表达式，当匹配结束时 <code>pexpect</code> 的 <code>before</code> 成员中保存了缓冲区中匹配成功处之前的内容， <code>pexpect</code> 的 <code>after</code> 成员保存的是缓冲区中与目标正则表达式相匹配的内容。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print child.before</span><br><span class="line">print child.after</span><br></pre></td></tr></table></figure></li><li><p><code>send</code>系列函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">send(self, s) </span><br><span class="line">sendline(self, s=&apos;&apos;) </span><br><span class="line">sendcontrol(self, char)</span><br></pre></td></tr></table></figure><p>这些方法用来向子程序发送命令，模拟输入命令的行为。 与 <code>send()</code> 不同的是 <code>sendline()</code> 会额外输入一个回车符 ，更加适合用来模拟对子程序进行输入命令的操作。 当需要模拟发送 <code>“Ctrl+c”</code> 的行为时，还可以使用 <code>sendcontrol()</code> 发送控制字符。 </p><p><code>child.sendcontrol(&#39;c&#39;)</code> </p><p>由于 <code>send()</code> 系列函数向子程序发送的命令会在终端显示，所以也会在子程序的输入缓冲区中出现，因此不建议使用 <code>expect</code> 匹配最近一次 <code>sendline()</code> 中包含的字符。否则可能会在造成不希望的匹配结果。 </p></li><li><p>interact()定义</p><p><code>interact(self, escape_character = chr(29), input_filter = None, output_filter = None)</code> </p><p>Pexpect还可以调用<code>interact()</code> 让出控制权，用户可以继续当前的会话控制子程序。用户可以敲入特定的退出字符跳出，其默认值为<code>“^]”</code> 。 </p></li></ul></li></ul></li><li><p><code>run() function</code></p><ul><li><p><code>run()</code>的定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">run(command,timeout=-1,withexitstatus=False,events=None,\</span><br><span class="line">    extra_args=None,logfile=None, cwd=None, env=None)</span><br></pre></td></tr></table></figure><p>函数 <code>run</code> 可以用来运行命令，其作用与 <code>Python os</code> 模块中 <code>system()</code> 函数相似。<code>run()</code> 是通过 <code>Pexpect spawn</code>类实现的。 </p></li><li><p>使用run()执行命令svn命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from pexpect import *</span><br><span class="line">run (&quot;svn ci -m &apos;automatic commit&apos; my_file.py&quot;)</span><br></pre></td></tr></table></figure><p>与 <code>os.system()</code> 不同的是，使用 <code>run()</code> 可以方便地同时获得命令的输出结果与命令的退出状态 。 </p></li><li><p>run()的返回值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from pexpect import *</span><br><span class="line">(command_output, exitstatus) = run (&apos;ls -l /bin&apos;, withexitstatus=1)</span><br></pre></td></tr></table></figure><p><code>command_out</code> 中保存的就是 /bin 目录下的内容。</p></li></ul></li></ol><p>更多关于pexpect的内容请看<a href="http://pexpect.readthedocs.io/en/stable/api/pexpect.html#run-function" target="_blank" rel="noopener">pexpect</a>.</p><ul><li><p>安装python pexpect模块</p><p><code>sudo pip install pexpect</code></p></li></ul><h2 id="程序编写"><a href="#程序编写" class="headerlink" title="程序编写"></a>程序编写</h2><p>还是一样的实现一个程序，其功能是ssh登录虚拟机，并在远程虚拟机用户目录下记录远程登录的日志文件，然后修改其<code>iptables</code>规则，禁止转发tcp 22号端口的报文。</p><p>完整程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import pexpect</span><br><span class="line"></span><br><span class="line">ip = &quot;192.168.1.75&quot;</span><br><span class="line">user = &quot;chl&quot;</span><br><span class="line">passwd = &quot;123456&quot;</span><br><span class="line">                                                                                                                                        </span><br><span class="line">ssh_newkey = &quot;Y|yes/no&quot;</span><br><span class="line">child = pexpect.spawn(&apos;ssh %s@%s&apos; % (user, ip))</span><br><span class="line">index = child.expect([pexpect.EOF, pexpect.TIMEOUT, ssh_newkey, &quot;password:&quot;])</span><br><span class="line">if index == 1:</span><br><span class="line">    print &quot;TimeoutError!&quot;</span><br><span class="line">if index == 2:</span><br><span class="line">    child.sendline(&quot;yes&quot;)</span><br><span class="line">    child.expect(&quot;password&quot;)</span><br><span class="line">    child.sendline(passwd)</span><br><span class="line">if index == 3:</span><br><span class="line">    child.sendline(passwd)</span><br><span class="line"></span><br><span class="line">child.expect(&quot;chl@&quot;)</span><br><span class="line">child.sendline(&quot;echo &apos;login +1&apos; &gt;&gt; ~/remote_login.log&quot;)</span><br><span class="line"></span><br><span class="line">child.expect(&quot;chl@&quot;)</span><br><span class="line">child.sendline(&quot;sudo iptables -A FORWARD -p tcp --dport 22 -j REJECT&quot;)</span><br><span class="line">child.expect(&quot;password&quot;)</span><br><span class="line">child.sendline(passwd)</span><br><span class="line"></span><br><span class="line">child.expect(&quot;chl@&quot;)</span><br><span class="line">child.sendline(&quot;exit&quot;)</span><br></pre></td></tr></table></figure><p><strong>注：</strong>需要注意的是python中正则表达式与Linux中的通配符是有区别的，不能直接用通配符来编写python正则表达式。</p><hr>]]></content>
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
            <tag> python </tag>
            
            <tag> Expect </tag>
            
            <tag> pexpect </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>远程免密码登录Openstack实例</title>
      <link href="/2018/07/07/%E8%BF%9C%E7%A8%8B%E5%85%8D%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95Openstack%E5%AE%9E%E4%BE%8B/"/>
      <url>/2018/07/07/%E8%BF%9C%E7%A8%8B%E5%85%8D%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95Openstack%E5%AE%9E%E4%BE%8B/</url>
      <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>一般情况下，可以通过<code>Openstack Dashboard</code>的控制台来访问用户创建的实例<code>Instance</code>，对于管理员来说，通过这种方法来访问会觉得很不方便，因为每次都需要打开浏览器来输入网址，每次点击都需要等待响应，登录到实例后控制台的响应也不是很及时且有卡顿。因此，本文介绍如何通过命名空间来实现免密码登录Openstack实例。</p><a id="more"></a><h1 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h1><p>在Linux中，网络命名空间可以被认为是隔离的拥有单独网络栈（网卡、路由转发表、iptables）的环境。网络命名空间经常用来隔离网络设备和服务，只有拥有同样网络命名空间的设备，才能看到彼此。openstack中就采用命名空间来实现不同网络的隔离。</p><ul><li><p>使用<code>ip netns</code>来查看已经存在的命名空间：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ip netns</span><br><span class="line">qrouter-e94975e8-4688-4858-8f64-86a18eea81ed</span><br><span class="line">qdhcp-34ba192f-ceea-4c86-addc-a5d14c6a34a8</span><br></pre></td></tr></table></figure><p><code>qdhcp</code>开头的名字空间是dhcp服务器使用的，<code>qrouter</code>开头的则是router服务使用的。 </p></li><li><p>查看openstack的网络：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ openstack network list</span><br><span class="line">+--------------------------------------+---------+--------------------------------------+</span><br><span class="line">| ID                                   | Name    | Subnets                              |</span><br><span class="line">+--------------------------------------+---------+--------------------------------------+</span><br><span class="line">| 34ba192f-ceea-4c86-addc-a5d14c6a34a8 | private | 74dbc6f4-ae59-4af5-b941-1f4d04918607 |</span><br><span class="line">| fc9b502a-d472-46f5-8570-b0d3915759cf | public  | de903618-fb31-412a-b46d-6ab593985b03 |</span><br><span class="line">+--------------------------------------+---------+--------------------------------------+</span><br></pre></td></tr></table></figure><p>可以看到<code>private</code>网络的dhcp服务器对应的命名空间<code>qdhcp-34ba192f-ceea-4c86-addc-a5d14c6a34a8</code>的名字中包含了<code>private</code>网络的ID。而本次测试的远程实例就是创建在private网络下的。</p></li><li><p>通过 <code>ip netns exec namespace_id command</code> 来在指定的网络名字空间中执行网络命令，记得加上<code>sudo</code>权限，例如 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ip netns exec qdhcp-34ba192f-ceea-4c86-addc-a5d14c6a34a8 ifconfig</span><br><span class="line">lo        Link encap:Local Loopback  </span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          inet6 addr: ::1/128 Scope:Host</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class="line">          RX packets:190 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:190 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1 </span><br><span class="line">          RX bytes:65824 (65.8 KB)  TX bytes:65824 (65.8 KB)</span><br><span class="line"></span><br><span class="line">tap4e2f68bb-84 Link encap:Ethernet  HWaddr fa:16:3e:32:19:6b  </span><br><span class="line">          inet addr:10.0.0.2  Bcast:10.0.0.63  Mask:255.255.255.192</span><br><span class="line">          inet6 addr: fe80::f816:3eff:fe32:196b/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1450  Metric:1</span><br><span class="line">          RX packets:110210 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:107493 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1 </span><br><span class="line">          RX bytes:21335986 (21.3 MB)  TX bytes:8426397 (8.4 MB)</span><br></pre></td></tr></table></figure></li><li><p>ssh远程登录实例：</p><p><code>sudo ip netns exec namespace_id ssh $username@ip</code></p><p>通过该命令来实现从控制节点通过ssh服务远程访问Openstack实例。</p></li></ul><h1 id="发送公共秘钥"><a href="#发送公共秘钥" class="headerlink" title="发送公共秘钥"></a>发送公共秘钥</h1><p>要实现免密码远程登录实例，首先需要将控制节点<code>root用户</code>的ssh的公共秘钥发送到远程实例，也就是<code>/root/.ssh/id_rsa.pub</code>文件中的内容，远程实例收到后会将公共密钥保存到登录用户的<code>.ssh/authorized_keys</code>文件中，这样下次登录远程实例时就不再需要密码。</p><ul><li><p>发送公共密钥：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ip netns exec qdhcp-34ba192f-ceea-4c86-addc-a5d14c6a34a8 ssh-copy-id -i /root/.ssh/id_rsa.pub openstack@10.0.0.9</span><br><span class="line"></span><br><span class="line">/usr/bin/ssh-copy-id: INFO: Source of key(s) to be installed: &quot;/root/.ssh/id_rsa.pub&quot;</span><br><span class="line">/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed</span><br><span class="line">/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys</span><br><span class="line">openstack@10.0.0.9&apos;s password: </span><br><span class="line"></span><br><span class="line">Number of key(s) added: 1</span><br><span class="line"></span><br><span class="line">Now try logging into the machine, with:   &quot;ssh &apos;openstack@10.0.0.9&apos;&quot;</span><br><span class="line">and check to make sure that only the key(s) you wanted were added.</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>发送的公共秘钥必须是控制节点<code>root</code>用户的，因为在进入命名空间执行命令时需要加上<code>sudo</code>权限，而<code>sudo</code>是用来以其他身份来执行命令的，预设的身份为<code>root</code>，这样在<code>ssh</code>登录远程实例时是以控制节点的<code>root</code>用户来登录远程实例的<code>openstack</code>用户，因此需要将控制节点<code>root</code>用户的公共密钥发送给远程实例，root用户的公共密钥的路径是<code>/root/.ssh/id_rsa.pub</code>。</p></li><li><p>查看远程实例的<code>authorized_keys</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ vi ~/.ssh/authorized_keys</span><br><span class="line">ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCjXQQUtIcLLcvBXVudZDBbQFK8BT/hB67oOrs792sfCuMhxvxvFRbma5UmnxwxOhXUIRjdz4u7tWhR3VVhqqnlHGDKOQVje/t2QtTlXXcBI3kGnc0Epem2NRMgRKp/h/Y1EOwtPNHRDVfr8C2znilXpWW1ueigHuJF4TWT7vEjgbApmWhopZcOXKbLkSu5dxLGUO3TzGqkASgpLG2XyuUJVqoREr5wbAZytq7R2p5KCxUZ6T7sDUQG+xmFPsfPg3MUHQmatTvtSf+mImotTkNSqOp2Itct9afX7SPkRncrXVWJ0qutbrRrkjRJm1l/sCjFBOD0x6txcFBX30nPvkDx root@controller</span><br></pre></td></tr></table></figure></li><li><p>查看控制节点<code>root</code>用户公共密钥：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># vi /root/.ssh/id_rsa.pub</span><br><span class="line">ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCjXQQUtIcLLcvBXVudZDBbQFK8BT/hB67oOrs792sfCuMhxvxvFRbma5UmnxwxOhXUIRjdz4u7tWhR3VVhqqnlHGDKOQVje/t2QtTlXXcBI3kGnc0Epem2NRMgRKp/h/Y1EOwtPNHRDVfr8C2znilXpWW1ueigHuJF4TWT7vEjgbApmWhopZcOXKbLkSu5dxLGUO3TzGqkASgpLG2XyuUJVqoREr5wbAZytq7R2p5KCxUZ6T7sDUQG+xmFPsfPg3MUHQmatTvtSf+mImotTkNSqOp2Itct9afX7SPkRncrXVWJ0qutbrRrkjRJm1l/sCjFBOD0x6txcFBX30nPvkDx root@controller</span><br></pre></td></tr></table></figure><p>可以看到，两者是一样的，说明控制节点的<code>root</code>用户已经被授权通过公共密钥来访问远程实例。</p></li></ul><h1 id="免密码登录"><a href="#免密码登录" class="headerlink" title="免密码登录"></a>免密码登录</h1><ul><li><p>免密码登录远程实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ip netns exec qdhcp-34ba192f-ceea-4c86-addc-a5d14c6a34a8 ssh openstack@10.0.0.9</span><br></pre></td></tr></table></figure><p>这样就通过<code>ssh</code>服务免密码远程登录<code>Openstack</code>实例，而不需要通过<code>Dashboard</code>的控制台来登录实例。</p></li></ul><hr>]]></content>
      
      <categories>
          
          <category> Openstack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Openstack </tag>
            
            <tag> Namespace </tag>
            
            <tag> SSH </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>NAT网关设计</title>
      <link href="/2018/05/21/NAT%E7%BD%91%E5%85%B3%E8%AE%BE%E8%AE%A1/"/>
      <url>/2018/05/21/NAT%E7%BD%91%E5%85%B3%E8%AE%BE%E8%AE%A1/</url>
      <content type="html"><![CDATA[<h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><p>本文的目的是将<code>Linux</code>配置成<code>NAT</code>网关，具备<code>NAT、DHCP、DNS</code>功能，实现内网访问外网的通信、实现外网对特定主机的访问、实现内网主机的IP地址动态分配以及域名解析的功能。</p><a id="more"></a><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><h2 id="实验环境介绍："><a href="#实验环境介绍：" class="headerlink" title="实验环境介绍："></a>实验环境介绍：</h2><ul><li><p>一台搭建了<code>KVM</code>环境的物理服务器，命名为<code>Server</code>，并在该服务器上创建两台虚拟机<code>VM</code>；</p></li><li><p>第一台虚拟机用作<strong>NAT网关</strong>，命名为<code>Gateway</code>，分配两张网卡，<code>eth0</code>连接内网，<code>eth1</code>连接外网；</p></li><li><p>第二台虚拟机作为<strong>内网主机</strong>，命名为<code>Host</code>，分配一张网卡<code>eth0</code>连接内网。</p></li><li><p>内网网段为：<code>10.0.0.0/24</code></p></li><li><p>外网网段为：<code>192.168.1.0/24</code></p><p><strong>注：</strong>本实验其实也可以在<code>VMware workstation</code>或者<code>virtualBox</code>环境下进行，但是由于博主的电脑配置不高，不想在个人电脑上搭建该环境，且身边的服务器刚好有空闲的资源，所以就在服务器上搭建了该环境，至于如何在服务器上搭建<code>KVM</code>环境可以参照我的另一篇博客的部分内容 <a href="https://cao0507.github.io/2017/12/03/KVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%83%A8%E7%BD%B2openstack%E7%9A%84%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/">快速链接</a>。</p></li></ul><h2 id="搭建实验环境："><a href="#搭建实验环境：" class="headerlink" title="搭建实验环境："></a>搭建实验环境：</h2><ul><li><p>创建内部网桥：服务器<code>Server</code>上创建一个虚拟网桥br-int，作为连接内网的交换机。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sudo brctl addbr br-int</span><br><span class="line"></span><br><span class="line">$ brctl show</span><br><span class="line">bridge namebridge idSTP enabledinterfaces</span><br><span class="line">br-int8000.000000000000no</span><br><span class="line"></span><br><span class="line">$ sudo ifconfig br-int up</span><br></pre></td></tr></table></figure><p><strong>注：</strong>在<code>VMware workstation</code>中搭建环境时需要在<strong>虚拟网络编辑器</strong>中将<strong>使用本地DHCP服务将IP分配给虚拟机</strong>选项取消勾选，因为我们需要实现NAT网关来给虚拟机分配IP。另外在创建虚拟网桥后一定要开启该网桥。</p></li><li><p>创建<strong>NAT网关</strong>虚拟机</p><p>其网络配置信息如下：</p><ul><li><p>eth0</p><p><img src="https://raw.githubusercontent.com/cao0507/My-Pictures-Repository/master/blog/Gateway_VM_nic0.png" alt="Gateway_NIC0"></p></li><li><p>eth1</p><p><img src="https://raw.githubusercontent.com/cao0507/My-Pictures-Repository/master/blog/Gateway_VM_nic1.png" alt="Gateway_NIC1">通过<code>ifconfig</code>查看网络信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ ifconfig</span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 52:54:00:1c:83:53  </span><br><span class="line">          inet6 addr: fe80::5054:ff:fe1c:8353/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          ...</span><br><span class="line"></span><br><span class="line">eth1      Link encap:Ethernet  HWaddr 52:54:00:de:e8:51  </span><br><span class="line">          inet addr:192.168.1.123  Bcast:192.168.1.255  Mask:255.255.255.0</span><br><span class="line">          inet6 addr: fe80::5054:ff:fede:e851/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          ...</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback  </span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          inet6 addr: ::1/128 Scope:Host</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class="line">          ...</span><br></pre></td></tr></table></figure><p>可见NAT网关的<code>eth0</code>网卡因为没有DHCP服务器所以没有分配到IP，但外网网卡<code>eth1</code>已经有一个外网IP。</p></li></ul></li><li><p>创建<strong>内部主机</strong>虚拟机</p><p>其网络配置信息如下：</p><ul><li><p>eth0</p><p><img src="https://raw.githubusercontent.com/cao0507/My-Pictures-Repository/master/blog/Host_VM_nic.png" alt="Host_NIC0">通过<code>ifconfig</code>查看网络信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ ifconfig</span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 52:54:00:1a:a1:78  </span><br><span class="line">          inet6 addr: fe80::5054:ff:fe1a:a178/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          ...</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback  </span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          inet6 addr: ::1/128 Scope:Host</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class="line">          ...</span><br></pre></td></tr></table></figure><p>可见其内网网卡<code>eth0</code>没有分配IP。</p><p>其实，在启动这两个虚拟机时，因为内部网络没有DHCP服务器，他们的内网网卡会一直等待DHCP服务器给它们分配IP，等待的时间大概是5分钟，最终还是没有获得IP。</p></li></ul></li><li><p>修改两个虚拟机的网络配置文件</p><ul><li><p><strong>NAT网关</strong>：<code>$ sudo vi /etc/network/interfaces</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">source /etc/network/interfaces.d/*</span><br><span class="line"></span><br><span class="line"># The loopback network interface</span><br><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line"></span><br><span class="line"># The primary network interface</span><br><span class="line">auto eth0</span><br><span class="line">iface eth0 inet static</span><br><span class="line">address 10.0.0.1</span><br><span class="line">netmask 255.255.255.0</span><br><span class="line">gateway 10.0.0.1</span><br><span class="line"></span><br><span class="line">auto eth1</span><br><span class="line">iface eth1 inet dhcp</span><br></pre></td></tr></table></figure><p>因为NAT网关的<code>eth0</code>将做内网的网关，故将其IP设置为静态IP：<code>10.0.0.1</code>，这样更容易识别，且不会因为重启而改变。</p></li><li><p><strong>内部主机</strong>：<code>$ sudo vi /etc/network/interfaces</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">source /etc/network/interfaces.d/*</span><br><span class="line"></span><br><span class="line"># The loopback network interface</span><br><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line"></span><br><span class="line"># The primary network interface</span><br><span class="line">auto eth0</span><br><span class="line">iface eth0 inet dhcp</span><br></pre></td></tr></table></figure></li></ul></li><li><p>在服务器Server上查看虚拟网桥的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ brctl show br-int</span><br><span class="line">bridge namebridge idSTP enabledinterfaces</span><br><span class="line">br-int8000.fe54001aa178novnet1</span><br><span class="line">           vnet3</span><br></pre></td></tr></table></figure><p>可以看到虚拟网桥<code>br-int</code>上面已经有两个网络接口，对应两个虚拟机的内部网卡。</p></li></ul><h1 id="NAT-功能实现"><a href="#NAT-功能实现" class="headerlink" title="NAT 功能实现"></a>NAT 功能实现</h1><p>NAT网关的功能是通过Linux中自带的iptables来实现，NAT功能包括SNAT和DNAT。SNAT是源地址转换，在内网主机访问外网时发挥作用，可以将内网主机的ip地址转换为网关的ip地址。DNAT是目的地址转换，在外网的主机通过NAT网关的ip和端口对内网主机发起访问时发挥作用，可以将NAT网关的ip地址与端口转换为对应内网主机的ip，从而实现从外网对内网中某一特定主机的访问。当然要将Linux虚拟机配置成NAT网关，首先得要开启Linux虚拟机的网络转发功能。下面将介绍NAT功能的实现过程：</p><ol><li><p>开启网络转发功能</p><ul><li><p>临时开启网络转发功能，需要切换到<code>root</code>用户，命令如下：</p><p><code># echo 1 &gt; /proc/sys/net/ipv4/ip_forward</code></p><p>这样在下次虚拟机重启后该功能会自动关闭，因此可以修改配置文件的方式来开启该功能并永久生效。</p></li><li><p>永久开启网络转发功能：</p><p><code># vi /etc/sysctl.conf</code></p><p>在文件里面添加一行<code>net.ipv4.ip_foward=1</code>，在下次重启之后就不会还原了。</p></li></ul></li><li><p>SNAT的实现</p><p>在<code>iptables</code>的<code>nat表</code>的<code>POSTROUTING规则链</code>中添加规则，使得从<code>10.0.0.0/24</code>网络发到NAT网关的数据包，从<code>eth1</code>转发出去，并将数据包的源ip地址修改为NAT网关的外网地址，命令如下 ：</p><p><code>sudo iptables -t nat -A POSTROUTING -s 10.0.0.0/24 -o eth1 -j SNAT --to-source 192.168.1.123</code></p><p><code>192.168.1.123</code>是NAT网关的外网网卡<code>eth1</code>的IP。</p></li><li><p>DNAT的实现</p><p>在<code>iptables</code>的<code>nat表</code>的<code>PREROUTING规则链</code>中添加规则，使得从外网发往NAT网关固定端口（如：8080）的<code>TCP</code>（这里也可以添加其他网络协议）数据包转发到内网的某固定主机上，命令如下：</p><p><code>sudo iptables -t nat -A PREROUTING -i eth1 -d 192.168.1.67 -p tcp --dport 8080 -j DNAT --to-destination 10.0.0.107:22</code></p><p><code>10.0.0.107</code>是内网某主机的IP，<strong>这里说明一下</strong>：实际实现的过程中，最好先实现DHCP与DNS的功能。</p></li><li><p>保存<code>iptables</code>规则</p><p><code>sudo iptables-save | sudo tee /etc/iptables.sav</code></p></li><li><p>编辑<code>/etc/rc.local</code>文件，将下面的一行添加到<code>&quot;exit 0&quot;</code>之前：</p><p><code>iptables-restore &lt; /etc/iptables.sav</code></p><p>这样每次重启机器时都会自动加载NAT相关的<code>iptables</code>规则。</p></li></ol><h1 id="DHCP与DNS功能实现"><a href="#DHCP与DNS功能实现" class="headerlink" title="DHCP与DNS功能实现"></a>DHCP与DNS功能实现</h1><p>实现DHCP服务器可以使用<code>isc-dhcp-server</code>工具包，实现DNS服务器可以使用<code>bind9</code>工具包，但是本实验考虑使用<code>DNSmasq</code>工具来同时实现DHCP服务器与DNS服务器的功能。<code>DNSmasq</code>是一个小巧且方便地用于配置DHCP和DNS的工具，适用于小型网络。作为域名解析服务器（DNS），<code>DNSmasq</code>可以通过缓存DNS请求来提高对访问过的网址的连接速度。作为DHCP服务器，<code>DNSmasq</code>可以用于为局域网电脑分配内网ip地址和提供路由。</p><ul><li><p>安装DNSmasq工具：</p><p><code>$ sudo apt-get install dnsmasq</code></p></li><li><p>编辑<code>DNSmasq</code>的配置文件<code>/etc/dnsmasq.conf</code>，添加下面两行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">interface=eth0</span><br><span class="line">dhcp-range=10.0.0.100,10.0.0.200,72h</span><br></pre></td></tr></table></figure><p>其中<code>interface</code>是用作内网网关的网卡，也就是NAT网关的<code>eth0</code>网卡；<code>dhcp-range</code>是动态分配的IP地址池；<code>72h</code>表示分配的IP的有效时间是72个小时，到时间后需要重新分配IP。</p></li><li><p>重启<code>DNSmasq</code>服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo /etc/init.d/dnsmasq restart</span><br><span class="line">[ ok ] Restarting dnsmasq (via systemctl): dnsmasq.service.</span><br></pre></td></tr></table></figure><p>到这里就配置内容就完成了。然后需要重启这两个虚拟机。</p></li></ul><h1 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h1><ul><li><p>DHCP服务</p><p>在完成DHCP服务器配置重启虚拟机后，会发现在启动过程中不再需要等待5分钟来获取IP了，进入<strong>内部主机</strong>查看网络信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ ifconfig</span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 52:54:00:1a:a1:78 </span><br><span class="line">          inet addr:10.0.0.176  Bcast:10.0.0.255  Mask:255.255.255.0</span><br><span class="line">          inet6 addr: fe80::5054:ff:fe1a:a178/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:17 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:21 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:36 txqueuelen:1000 </span><br><span class="line">          RX bytes:1642 (1.6 KB)  TX bytes:2182 (2.1 KB)</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback  </span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          inet6 addr: ::1/128 Scope:Host</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class="line">          RX packets:164 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:164 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1 </span><br><span class="line">          RX bytes:12200 (12.2 KB)  TX bytes:12200 (12.2 KB)</span><br></pre></td></tr></table></figure><p>可以看到eth0分配到了一个在DHCP地址池内的一个IP：<code>10.0.0.176</code>。</p></li><li><p>DNS与NAT服务</p><p>这里将同时对DNS服务与NAT服务进行测试</p><ul><li><p>内网到外网</p><p>由于我所在的网络所有的<code>ping</code>外网的报文都会被拦截，所以没有办法通过<code>ping</code>来测试网络的连通性，这里采用<code>wget</code>命令在内部主机测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ wget http://www.baidu.com</span><br><span class="line">--2018-07-08 16:30:37--  http://www.baidu.com/</span><br><span class="line">Resolving www.baidu.com (www.baidu.com)... 180.97.33.108, 180.97.33.107</span><br><span class="line">Connecting to www.baidu.com (www.baidu.com)|180.97.33.108|:80... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: 2381 (2.3K) [text/html]</span><br><span class="line">Saving to: ‘index.html’</span><br><span class="line"></span><br><span class="line">index.html               100%[================================&gt;]   2.33K  --.-KB/s    in 0s      </span><br><span class="line"></span><br><span class="line">2018-07-08 16:30:37 (61.1 MB/s) - ‘index.html’ saved [2381/2381]</span><br></pre></td></tr></table></figure><p>上面的测试说明内网主机到外网的连通性，并且也实现了域名解析的功能。</p></li><li><p>外网到内网</p><p>在博主的个人Windows电脑上去访问内网主机，以此来测试外网到内网的连通性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[c:\~]$ ssh openstack-image@192.168.1.152 8080</span><br><span class="line"></span><br><span class="line">Connecting to 192.168.1.152:8080...</span><br><span class="line">Connection established.</span><br><span class="line">To escape to local shell, press &apos;Ctrl+Alt+]&apos;.</span><br><span class="line"></span><br><span class="line">Welcome to Ubuntu 16.04.3 LTS (GNU/Linux 4.4.0-87-generic x86_64)</span><br><span class="line"></span><br><span class="line"> * Documentation:  https://help.ubuntu.com</span><br><span class="line"> * Management:     https://landscape.canonical.com</span><br><span class="line"> * Support:        https://ubuntu.com/advantage</span><br><span class="line"></span><br><span class="line">134 packages can be updated.</span><br><span class="line">55 updates are security updates.</span><br><span class="line"></span><br><span class="line">Last login: Sun Jul  8 16:13:54 2018</span><br><span class="line">openstack-image@ubuntu:~$ ifconfig</span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 52:54:00:d0:51:38  </span><br><span class="line">          inet addr:10.0.0.176  Bcast:10.0.0.255  Mask:255.255.255.0</span><br><span class="line">          inet6 addr: fe80::5054:ff:fed0:5138/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:96 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:125 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:516 txqueuelen:1000 </span><br><span class="line">          RX bytes:17842 (17.8 KB)  TX bytes:15515 (15.5 KB)</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback  </span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          inet6 addr: ::1/128 Scope:Host</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class="line">          RX packets:176 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:176 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1 </span><br><span class="line">          RX bytes:13392 (13.3 KB)  TX bytes:13392 (13.3 KB)</span><br></pre></td></tr></table></figure><p>可以访问，外网到内网也是连通的。到此，需要实现的功能都已经实现了。</p></li></ul></li></ul><hr>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> NAT </tag>
            
            <tag> DHCP </tag>
            
            <tag> DNS </tag>
            
            <tag> iptables </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>虚拟化技术与云计算平台报告</title>
      <link href="/2018/03/22/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E4%B8%8E%E4%BA%91%E8%AE%A1%E7%AE%97%E5%B9%B3%E5%8F%B0%E6%8A%A5%E5%91%8A/"/>
      <url>/2018/03/22/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E4%B8%8E%E4%BA%91%E8%AE%A1%E7%AE%97%E5%B9%B3%E5%8F%B0%E6%8A%A5%E5%91%8A/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从2006年谷歌首次提出“云计算”的概念到现在，云计算已经经历的十多年的发展，有众多厂商、组织和学者投入其中。一些云服务厂商有自己的云计算平台，但只是为客户提供云服务，外部开发者无法对这些厂商的云平台进行开发。另外也有一些组织机构或厂商开发的云计算平台是开源的，吸引大量开发者在这些开源平台上开展自己的工作。</p><a id="more"></a><p>目前，主流的开源云计算平台有很多种，本问将对这些平台进行调研以选择最适合于自己需求的平台。另外，虚拟化技术又是云计算的核心支撑技术，是将各种计算及存储资源充分整合和高效利用的关键技术，当前虚拟化技术也是多种多样，并且开源云计算平台往往又支持多种底层的虚拟化技术，因此也有必要对虚拟化技术进行调研，以选择最适合云平台和上层应用的虚拟化技术。综上，本报告的主要目标就是对多种虚拟化技术和多种开源云计算平台进行对比，以选出最满足需求的技术与平台。</p><p>本文将首先简单对比虚拟化与云计算。其后，由于虚拟化技术是云计算的基础，本报告将先对虚拟化技术展开论述，然后再对云计算平台进行论述。</p><h1 id="虚拟化与云计算"><a href="#虚拟化与云计算" class="headerlink" title="虚拟化与云计算"></a>虚拟化与云计算</h1><p>借助虚拟化技术，用户可以单个物理硬件系统为基础创建多个模拟环境或专用资源。并使用一款名为“Hypervisor”(虚拟机监控程序)的软件直接连接到硬件，从而将一个系统划分为不同的、单独安全环境，即虚拟机 (VM)。Hypervisor 能够将计算机资源与硬件分离并适当分配资源，而虚拟机则依赖这些功能运行。</p><p>云计算则由多种规则和方法组合而成，可以跨任何网络向用户按需提供计算、网络和存储基础架构资源、服务、平台和应用。这些基础架构资源、服务和应用来源于云。 简单来讲，云就是一系列管理及自动化软件编排而成的虚拟资源池，旨在帮助用户通过支持自动扩展和动态资源分配的自助服务门户，按需对这些资源进行访问。</p><p>下面对虚拟化与云计算做一个简单的对比：</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">虚拟化</th><th style="text-align:center">云</th></tr></thead><tbody><tr><td style="text-align:center">定义</td><td style="text-align:center">技术</td><td style="text-align:center">方法论</td></tr><tr><td style="text-align:center">目的</td><td style="text-align:center">从一个物理硬件系统创建多个虚拟环境</td><td style="text-align:center">汇聚并自动化分配虚拟资源以供按需使用</td></tr><tr><td style="text-align:center">用途</td><td style="text-align:center">针对具体用途为特定用户提供打包资源</td><td style="text-align:center">针对多种用途为用户群组提供不同资源</td></tr><tr><td style="text-align:center">使用寿命</td><td style="text-align:center">数年（长期）</td><td style="text-align:center">数小时至数月</td></tr><tr><td style="text-align:center">成本</td><td style="text-align:center">资本支出（CAPEX）高<br>运营支出（OPEX）低</td><td style="text-align:center">共有云：CAPEX高、OPEX低<br>私有云：CAPEX低、OPEX高</td></tr><tr><td style="text-align:center">可扩展性</td><td style="text-align:center">纵向扩展</td><td style="text-align:center">横向扩展</td></tr><tr><td style="text-align:center">工作负载</td><td style="text-align:center">有状态</td><td style="text-align:center">无状态</td></tr><tr><td style="text-align:center">租赁</td><td style="text-align:center">单一租户</td><td style="text-align:center">多个租户</td></tr></tbody></table><h1 id="虚拟化技术"><a href="#虚拟化技术" class="headerlink" title="虚拟化技术"></a>虚拟化技术</h1><p>按照虚拟化的对象分类，虚拟化可分为服务器虚拟化、操作系统虚拟化、存储虚拟化、网络虚拟化等。其中服务器虚拟化对CPU、内存、设备与I/O这三种硬件资源的虚拟化技术已经相当成熟，但对GPU的虚拟化却还有很大的提升空间。下面将分别介绍服务器虚拟化中CPU虚拟化及GPU虚拟化相关的技术，然后对现在主流的虚拟化平台做一些比较。</p><h2 id="一、CPU虚拟化"><a href="#一、CPU虚拟化" class="headerlink" title="一、CPU虚拟化"></a>一、CPU虚拟化</h2><p>目前，为了解决x86体系结构下的CPU虚拟化问题，业界提出了全虚拟化和半虚拟化两种不同的软件方案。除了通过软件的方式实现CPU虚拟化外，业界还提出了在硬件层添加支持功能的硬件辅助虚拟化方案来处理那些敏感的高级别指令。</p><p>全虚拟化在宿主机底层物理硬件与VM之间增加一个软件层，即虚拟机监控器（VMM或hypervisor），此时，VMM充当主机操作系统，用来管理不同的虚拟机，如图1所示。它隐藏了特定计算平台的实际物理特性，为用户提供抽象的、统一的、模拟的计算环境（称为虚拟机）。在VMM平台上，可以模拟出多套虚拟机，实现了在单机上运行多个不同类型操作系统的虚拟机。全虚拟化的优点是不需要修改客户机操作系统，因此支持多种操作系统，缺点是VMM层工作负荷较大，并占用一定的宿主机资源，性能不如裸机。主要代表有VMware vSphere，Microsoft公司的Virtual PC、Redhat公司的RED HAT ENTERPRISE VIRTUALIZATION等。 </p><p><img src="https://raw.githubusercontent.com/cao0507/Pictures/master/blog/%E5%85%A8%E8%99%9A%E6%8B%9F%E5%8C%96%E6%9E%B6%E6%9E%84.png" alt="全虚拟化架构"></p><p>半虚拟化与全虚拟化类似，不同之处是需要修改客户机操作系统的核心代码，即增加一个专门的虚拟化应用程序接口，优化客户操作系统发出的指令，与VMM能够协同工作，以减轻VMM和宿主机的负担，进一步提升了虚拟机的性能，如图2所示。缺点是需要修改客户操作系统，影响了技术的普及。主要代表有使用开源虚拟化技术的Citrix的Xenserver、Microsoft的Hyper-V 。</p><p><img src="https://raw.githubusercontent.com/cao0507/Pictures/master/blog/%E5%8D%8A%E8%99%9A%E6%8B%9F%E5%8C%96%E6%9E%B6%E6%9E%84.png" alt="半虚拟化架构"></p><p>为了更好地实现全、半虚拟化技术，Intel与AMD对传统X86架构进行改进，分别设计了Intel-VT和AMD-V CPU硬件辅助虚拟化技术。将原来的特权等级Ring 0、1、2、3 定义为Non-Root mode，新增了一个Root mode 特权等级（或称为Ring -1），这种情况下，OS 即可运行在原来Ring0 的等级，而VMM 则调整到更底层的Root Mode 等级，其架构如图3。硬件辅助虚拟化有效地解决了虚拟机效率低的问题，它使虚拟机可以运行ring 0 的指令，不用再进行操作系统的ring 切换，提高了虚拟机的整体效率。 现在主流的半、全虚拟化产品都支持硬件辅助虚拟化，代表有Oracle公司的VirtualBox、RHEV、VMware vSphere和Xneserver。</p><p><img src="https://raw.githubusercontent.com/cao0507/Pictures/master/blog/%E7%A1%AC%E4%BB%B6%E8%BE%85%E5%8A%A9%E8%99%9A%E6%8B%9F%E5%8C%96%E6%9E%B6%E6%9E%84.png" alt="硬件辅助虚拟化"></p><h2 id="二、GPU虚拟化"><a href="#二、GPU虚拟化" class="headerlink" title="二、GPU虚拟化"></a>二、GPU虚拟化</h2><p>GPU虚拟化相关技术还垄断在少数厂商手中，并没有像CPU、内存、存储一样在开源社区推广普及。下面将介绍三大显卡厂商GPU虚拟化的发展。</p><p>NVIDIA，早在2013年，NVIDIA就推出了行业内第一款GPU虚拟化显卡GRID K1/K2，同期联合Citrix推出了商用的vGPU虚拟桌面解决方案，这比AMD提前了近3年。GPU虚拟化技术的出现，给一直被诟病性能不足的桌面虚拟化带来了转机。在2016年，NVIDIA推出第二款GPU虚拟化显卡，Maxwell架构的Tesla M6/M10/M60，新版的GRID将使用授权分为 3 个不同版本，依据版本不同收取额外软件授权使用费。 在2017年8月份NVIDIA推出了最新版GRID 5.0，虚拟化显卡新增Pascal架构的Tesla P4/P6/P40/P100，其中Quadro Virtual Datacenter Workstation版的授权支持vGPU在图形渲染模式和高性能计算模式之间切换，这是硬件厂商首次在vGPU层面将图形渲染和高性能计算进行了统一，又一次引领了行业趋势和市场需求。NVIDIA的虚拟化显卡只是硬件，还需要相应的服务器虚拟化系统的支持，这和Intel的CPU需要操作系统Windows和Linux来配合一样。现在只有Xen和ESXi能够支持GRID virtual GPU solution，被大量第三方厂商采用的KVM虚拟化平台还没有出现在GRID的支持列表中，因此可以说GPU另外一只脚还没能踏进云计算时代。2017年7月份NVIDIA和Nutanix宣布将合作在年底推出AHV版本的GRID，这算是KVM虚拟化走出了第 一步。在解决GPU虚拟化后，如何将虚拟机的画面传送到客户端，这是KVM虚拟化可以商用的第二步。KVM上默认配置的Spice协议对3D的支持并不好，Nutanix以及其他KVM方案解决商还需自行开发出可用的桌面传输协议，这才算是彻底完成了GRID在KVM上的应用。</p><p>AMD，AMD在NVIDIA推出GRID K1/K2 的两年半后才推出了自己的GPU虚拟化产品MxGPU，算是姗姗来迟。共有三款FirePro S系列的GPU支持MxGPU，一块GPU最多可以支持 32 个用户。当MxGPU上的虚拟机比较少时，能够达到图形工作站的性能。随着虚拟机数量增多，每个虚拟机获得的GPU性能逐步降低。有别于NVIDIA GRID通过软件实现的显卡虚拟化方式，AMD MxGPU是“全球首款基于硬件的虚拟化GPU解决方案”。MxGPU每个虚拟机能分得一定数量的独享流处理器和显存空间，这样可以避免不同虚拟机对GPU资源的抢夺，造成用户噪音。这种噪音问题直到今年8月底推出NVIDIA GRID 5. 0 才得到解决。MxGPU在定价上采用的是更符合买方逻辑的营销方法，只向用户收取需付硬件的购买费用。不过遗憾的是，目前只有VMware的ESXi支持MxGPU，Xen暂时只有技术验证版。没能同时支持两种主流化的虚拟化系统，一定程度上阻碍了MxGPU在市场的普及速度。Citrix的用户还是可以用过vSphere+XenDesktop的方案用上MxGPU，相比使用免费的XenServer，要多支付vSphere的费用。</p><p>Intel，Intel官方将不同的Intel GPU虚拟化技术分别命名为Intel GVT-s，Intel GVT-d和Intel GVT-g，分布对应API转发，直通，完全虚拟化。Intel GVT-g和NVIDIA vGPU类似，支持Xen/KVM平台，每个GPU最多能分享给7个用户同时使用。其中XenGT在 2016 年最早实现了业界的vGPU在线迁移，NVIDIA GRID直到这个季度才和Citrix合作完成了vGPU在线迁移。 2016 年的 2017 年2月份，Linux 4.10中加入Intel GVT-g for KVM。这是三大GPU厂商中，第一个支持KVM平台的完全虚拟化方案，意味着第三方采用KVM的云计算厂商终于有了一个可用的vGPU方案。不过Intel GPU虚拟化，由于核显性能的原因，只能满足图像密集型的用户体验，不能像GRID vGPU和MxGPU一样满足图形渲染的重度使用场景。Intel GPU虽然支持了大多数虚拟化桌面厂商使用的Xen/KVM两大类服务器虚拟化系统，可是硬件却和VDI高密度的使用场景不太搭。首先Intel的完全虚拟化只支持Broadwell架构以后的核芯显卡，作为VDI服务器中常用的Xeon E5/E7 v4 系列，以及第 一个的Xeon Scalable处理器，都没有核芯显卡。这在很大程度上限定了Intel GPU虚拟化在VDI的使用规模，有种落入有枪无弹的尴尬境地。</p><h2 id="三、虚拟化平台比较"><a href="#三、虚拟化平台比较" class="headerlink" title="三、虚拟化平台比较"></a>三、虚拟化平台比较</h2><p>服务器虚拟化技术日益成熟，并具有广泛的应用前景，目前有很多厂商进行虚拟化技术产品的开发和生产，包括：VMware、Microsoft、Citrix、IBM和RedHat等，其各自产品都有不同的特点，产品功能日益强大。下面将比较一下四种主流服务器虚拟化平台，如下表 ：</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">VMware</th><th style="text-align:center">Xen</th><th style="text-align:center">KVM</th><th style="text-align:center">Hyper-V</th></tr></thead><tbody><tr><td style="text-align:center">厂商</td><td style="text-align:center">VMware</td><td style="text-align:center">Citrix</td><td style="text-align:center">Red Hat</td><td style="text-align:center">Microsoft</td></tr><tr><td style="text-align:center">是否免费</td><td style="text-align:center">付费</td><td style="text-align:center">开源免费</td><td style="text-align:center">开源免费</td><td style="text-align:center">付费</td></tr><tr><td style="text-align:center">宿主机系统</td><td style="text-align:center">Windows<br>Linux</td><td style="text-align:center">NetBSD<br>Linux<br>Solaris</td><td style="text-align:center">Linux</td><td style="text-align:center">Windows server 2008及以上系统</td></tr><tr><td style="text-align:center">客户机系统</td><td style="text-align:center">Windows 2003、Windows 2008、RedHat、Debian、Ubuntu、Centos</td><td style="text-align:center">Xen-PV：纯Linux；Xen-HVM：支持Windows、Linux</td><td style="text-align:center">Linux、Windows</td><td style="text-align:center">Windows系列、Linux</td></tr><tr><td style="text-align:center">支持技术</td><td style="text-align:center">硬件辅助虚拟化（全虚拟化）</td><td style="text-align:center">硬件辅助虚拟化（HVM全虚拟化、PV半虚拟化）</td><td style="text-align:center">硬件辅助虚拟化（全虚拟化）</td><td style="text-align:center">硬件辅助虚拟化（半虚拟化）</td></tr><tr><td style="text-align:center">支持的vGPU产品</td><td style="text-align:center">NVIDIA GRID<br>AMD MxGPU</td><td style="text-align:center">NVIDIA GRID<br>AMD MxGPU（技术验证版）</td><td style="text-align:center">Intel GVT-g for KVM</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">优点</td><td style="text-align:center">相对成熟的商业软件，市场占有率较大</td><td style="text-align:center">性能较好，支持半虚拟化</td><td style="text-align:center">是内核本身的一部分，因此可以利用内核的优化和改进；高性能，稳定，无需修改客户机系统</td><td style="text-align:center">对Windows的支持较好</td></tr><tr><td style="text-align:center">缺点</td><td style="text-align:center">不开源，费用较高</td><td style="text-align:center">操作复杂，维护成本较高，目前已被RedHat抛弃</td><td style="text-align:center">虚拟机性能比Xen略低</td><td style="text-align:center">对Linux的支持较差，性能损失大</td></tr></tbody></table><p>开源云计算平台Openstack对这四种虚拟化平台都有支持，默认使用的是KVM，Openstack与KVM结合的方案也已经相当成熟。另外，考虑到KVM是开源免费的虚拟化技术；宿主机系统支持绝大多数Linux系统，对于使用Linux系统的服务器都有很好的支持；而客户机操作系统不仅支持Linux，还支持Windows，可以满足绝大多数用户的需求，因此选择KVM作为Openstack底层的虚拟化技术的理由是很充分的。不过，KVM对于虚拟GPU的支持不是很好，只有Intel GVT-g for KVM可以支持KVM平台的全虚拟化方案，但是Intel GPU虚拟化由于核显性能的原因，只能满足图像密集型的用户体验，不能满足图形渲染等重度使用的场景。</p><h1 id="云计算平台"><a href="#云计算平台" class="headerlink" title="云计算平台"></a>云计算平台</h1><p>目前已经有多个云计算平台的开源实现，主要的开源云计算项目有Openstack、Eucalyptus、CloudStack和OpenNebula等，现比较如下：</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">Openstack</th><th style="text-align:center">Eucalyptus</th><th style="text-align:center">CloudStack</th><th style="text-align:center">OpenNebula</th></tr></thead><tbody><tr><td style="text-align:center">发布时间</td><td style="text-align:center">2010年7月</td><td style="text-align:center">2008年5月</td><td style="text-align:center">2010年5月</td><td style="text-align:center">2008年7月</td></tr><tr><td style="text-align:center">最新版本</td><td style="text-align:center">Queens</td><td style="text-align:center">4.4</td><td style="text-align:center">4.11</td><td style="text-align:center">5.4</td></tr><tr><td style="text-align:center">授权协议</td><td style="text-align:center">Apache v2.0</td><td style="text-align:center">GPL v3.0</td><td style="text-align:center">Apache v2.0</td><td style="text-align:center">Apache v2.0</td></tr><tr><td style="text-align:center">基本架构</td><td style="text-align:center">Nova、Glance、Neutron、Keystone、Horizon、swift、Tacker等</td><td style="text-align:center">Cloud Controller、Cluster Controller、Node Controller、Walrus、 Storage Controller</td><td style="text-align:center">主要包括管理服务、云基础设施和网络三大部分</td><td style="text-align:center">主要包括接口与API、用户与组、主机、网络、存储、集群6个部分</td></tr><tr><td style="text-align:center">虚拟化技术支持</td><td style="text-align:center">KVM、LXC、QEMU、UML、Vmware ESX/ESXi、Xen、Hyper-V</td><td style="text-align:center">Xen、KVM、ESXi</td><td style="text-align:center">KVM、Xen、ESXi、OVM、Baremetal</td><td style="text-align:center">Xen、KVM、Vmware</td></tr><tr><td style="text-align:center">用户界面</td><td style="text-align:center">Dashboard，较简单</td><td style="text-align:center">web界面</td><td style="text-align:center">Web Console，功能较完善</td><td style="text-align:center">web界面</td></tr><tr><td style="text-align:center">社区活跃程度</td><td style="text-align:center">人数多，活跃用户数最多</td><td style="text-align:center">人数多，但活跃用户数较少</td><td style="text-align:center">人数少，但活跃用户数较多</td><td style="text-align:center">人数较少，活跃用户数也少</td></tr><tr><td style="text-align:center">兼容云平台</td><td style="text-align:center">Amazon EC2，S3</td><td style="text-align:center">Amazon EC2，S3</td><td style="text-align:center">Amazon EC2，S3</td><td style="text-align:center">Amazon EC2，S3</td></tr><tr><td style="text-align:center">开发主导</td><td style="text-align:center">开源社区</td><td style="text-align:center">Eucalyptus System Inc</td><td style="text-align:center">Citrix公司</td><td style="text-align:center">开源社区</td></tr><tr><td style="text-align:center">主要支持厂商</td><td style="text-align:center">160家左右，包括NASA、Rackspace、HP、Dell、UnitedStack等</td><td style="text-align:center">亚马逊、戴尔、惠普、Intel、Redhat、Vmware等</td><td style="text-align:center">不到60家，包括诺基亚、日本电话电报公司、阿尔卡特、迪士尼等</td><td style="text-align:center">IBM、Akamai、Blackberry、Fuze、Telefonica、Indigital</td></tr><tr><td style="text-align:center">官方文档</td><td style="text-align:center">非常详细</td><td style="text-align:center">不够详细</td><td style="text-align:center">详细</td><td style="text-align:center">详细</td></tr><tr><td style="text-align:center">检测和审计</td><td style="text-align:center">Telemetry Service</td><td style="text-align:center">Accounting system</td><td style="text-align:center">Event/Audit logs</td><td style="text-align:center">Accounting system、periodically-Monitoring</td></tr><tr><td style="text-align:center">数据库</td><td style="text-align:center">PostareSQL、MySQL、SQLite</td><td style="text-align:center">HyperSQL Database</td><td style="text-align:center">MySQL</td><td style="text-align:center">SQLite、MySQL</td></tr><tr><td style="text-align:center">部署</td><td style="text-align:center">私有云、共有云、混合云</td><td style="text-align:center">私有云、混合云</td><td style="text-align:center">私有云、共有云、混合云</td><td style="text-align:center">私有云、共有云、混合云</td></tr><tr><td style="text-align:center">操作系统</td><td style="text-align:center">Debian 7.0、openSUSE、SUSE、Red Hat、CentOS、Fedora、Ubuntu</td><td style="text-align:center">CentOS、RHEL</td><td style="text-align:center">CentOS、RHEL6.3+、Ubuntu</td><td style="text-align:center">Red Hat、Ubuntu、SUSE、CentOS、Debian</td></tr><tr><td style="text-align:center">开发语言</td><td style="text-align:center">Python</td><td style="text-align:center">Java、C/C++</td><td style="text-align:center">Java</td><td style="text-align:center">C、Ruby、shell</td></tr><tr><td style="text-align:center">开源市场部署比例</td><td style="text-align:center">69%</td><td style="text-align:center">3%</td><td style="text-align:center">14%</td><td style="text-align:center">无统计数据</td></tr></tbody></table><p>这四种主流的开源云计算平台都经过了近十年的发展，更新迭代了很多版本，能够从众多云计算平台的竞争中存活下来，都有相应的支持厂商和用户，说明它们各有各的特点，如在开发语言上就各有特色，Openstack使用的是Python语言，Eucalyptus使用Java、C/C++，CloudStack仅使用Java，而OpenNebula却显得比较奇怪，使用的是C语言、Ruby和shell，多种语言混杂而成。但不同平台之间还是有较大差距，从结果来看，在开源市场的部署比例，Openstack 69%的比例占据了绝对统治地位，Openstack能占据这样的地位有多方面的原因，如Openstack支持绝大多数的虚拟化技术，支持的操作系统也很多，使得Openstack具有广阔的应用范围；Openstack的官方文档非常详细，也降低了其学习成本；Openstack具有一个充满活力的开源社区，开发者不断为Openstack的发展作出贡献；OpenStack的支持厂商有160家左右，有如此多的厂商支持，给OpenStack的发展提供了根本保障。综合以上多方面的原因，本项目采用Openstack作为底层的云计算平台为上层提供基础设施资源也是理所当然的。另外，在2018年2月28日发布的Openstack Queens最新版本中，新引入的Marquee功能正是为了提供对vGPU的内置支持能力，这意味着用户能够将GPU添加至虚拟机中，为本项目的上层应用，如深度学习等需要强大GPU运算能力的应用提供了支持。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过以上的分析，能够清楚的了解各种虚拟化技术及各种云计算平台的差异，对于要选择满足自己需求的技术与平台会有一些帮助。</p><hr>]]></content>
      
      <categories>
          
          <category> 云计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云计算 </tag>
            
            <tag> 虚拟化 </tag>
            
            <tag> Openstack </tag>
            
            <tag> KVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Openstack环境下手动安装Mistral</title>
      <link href="/2017/12/23/Openstack%E7%8E%AF%E5%A2%83%E4%B8%8B%E6%89%8B%E5%8A%A8%E5%AE%89%E8%A3%85Mistral/"/>
      <url>/2017/12/23/Openstack%E7%8E%AF%E5%A2%83%E4%B8%8B%E6%89%8B%E5%8A%A8%E5%AE%89%E8%A3%85Mistral/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在openstack平台中能够成功安装Tacker，但是安装的Tacker并不能用，因为在tacker中创建VIM时需要调用Mistral工作流组件。因此本文就来介绍在openstack环境中手动安装Mistral的过程。</p><a id="more"></a><p><strong>注：</strong> 安装的openstack是在Ubuntu 16.04系统下的Ocata版本；本文中涉及的密码都统一设置成 <em>“openstack”</em>。</p><p>参考<a href="https://docs.openstack.org/mistral/latest/install/installation_guide.html" target="_blank" rel="noopener"><em>官方文档</em></a></p><h1 id="一、安装必要组件"><a href="#一、安装必要组件" class="headerlink" title="一、安装必要组件"></a>一、安装必要组件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ apt-get install python-dev python-setuptools python-pip libffi-dev \</span><br><span class="line">  libxslt1-dev libxml2-dev libyaml-dev libssl-dev</span><br></pre></td></tr></table></figure><h1 id="二、安装Mistral-server"><a href="#二、安装Mistral-server" class="headerlink" title="二、安装Mistral server"></a>二、安装Mistral server</h1><h2 id="1、下载Mistral源码，并进入下载目录"><a href="#1、下载Mistral源码，并进入下载目录" class="headerlink" title="1、下载Mistral源码，并进入下载目录"></a>1、下载Mistral源码，并进入下载目录</h2><pre><code>$ git clone https://github.com/openstack/mistral.git$ cd mistral</code></pre><h2 id="2、安装Mistral环境依赖包"><a href="#2、安装Mistral环境依赖包" class="headerlink" title="2、安装Mistral环境依赖包"></a>2、安装Mistral环境依赖包</h2><pre><code>$ pip install -r requirements.txt</code></pre><h2 id="3、安装Mistral"><a href="#3、安装Mistral" class="headerlink" title="3、安装Mistral"></a>3、安装Mistral</h2><pre><code>$ python setup.py install</code></pre><h2 id="4、生成配置文件"><a href="#4、生成配置文件" class="headerlink" title="4、生成配置文件"></a>4、生成配置文件</h2><pre><code>$ oslo-config-generator --config-file tools/config/config-generator.mistral.conf --output-file etc/mistral.conf</code></pre><h2 id="5、创建Mistral日志文件和配置文件夹"><a href="#5、创建Mistral日志文件和配置文件夹" class="headerlink" title="5、创建Mistral日志文件和配置文件夹"></a>5、创建Mistral日志文件和配置文件夹</h2><pre><code># mkdir -p /etc/mistral /var/log/mistral</code></pre><h2 id="6、复制配置文件到配置文件夹"><a href="#6、复制配置文件到配置文件夹" class="headerlink" title="6、复制配置文件到配置文件夹"></a>6、复制配置文件到配置文件夹</h2><pre><code># cp etc/* /etc/mistral/</code></pre><h2 id="7、修改配置文件"><a href="#7、修改配置文件" class="headerlink" title="7、修改配置文件"></a>7、修改配置文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># vi /etc/mistral/mistral.conf </span><br><span class="line"></span><br><span class="line">[keystone_authtoken]</span><br><span class="line">auth_uri = http://controller:5000</span><br><span class="line">auth_version = 3</span><br><span class="line">identity_uri = http://controller:35357/</span><br><span class="line">admin_user = admin</span><br><span class="line">admin_password = openstack</span><br><span class="line">admin_tenant_name = admin</span><br><span class="line"></span><br><span class="line">[database]</span><br><span class="line">connection = mysql+pymysql://mistral:openstack@controller/mistral </span><br><span class="line"></span><br><span class="line">[DEFAULT]</span><br><span class="line">transport_url = rabbit://openstack:openstack@controller</span><br></pre></td></tr></table></figure><h2 id="8、创建数据库"><a href="#8、创建数据库" class="headerlink" title="8、创建数据库"></a>8、创建数据库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># mysql</span><br><span class="line">MariaDB [(none)]&gt; CREATE DATABASE mistral;</span><br><span class="line">MariaDB [mistral]&gt; GRANT ALL PRIVILEGES ON mistral.* TO &apos;mistral&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;openstack&apos;;</span><br><span class="line">MariaDB [mistral]&gt; GRANT ALL PRIVILEGES ON mistral.* TO &apos;mistral&apos;@&apos;%&apos; IDENTIFIED BY &apos;openstack&apos;;</span><br><span class="line">MariaDB [mistral]&gt; flush privileges;</span><br><span class="line">MariaDB [mistral]&gt; exit;</span><br></pre></td></tr></table></figure><h2 id="9、创建服务和endpoint"><a href="#9、创建服务和endpoint" class="headerlink" title="9、创建服务和endpoint"></a>9、创建服务和endpoint</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ openstack service create --name mistral --description &quot;Openstack Workflow service&quot; workflow</span><br><span class="line">$ openstack endpoint create --region RegionOne workflow public http://controller:8989/v2</span><br><span class="line">$ openstack endpoint create --region RegionOne workflow internal http://controller:8989/v2</span><br><span class="line">$ openstack endpoint create --region RegionOne workflow admin http://controller:8989/v2</span><br></pre></td></tr></table></figure><h2 id="10、初始化数据库信息"><a href="#10、初始化数据库信息" class="headerlink" title="10、初始化数据库信息"></a>10、初始化数据库信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">root@controller:/home/openstack# mistral-db-manage --config-file /etc/mistral/mistral.conf upgrade head</span><br><span class="line"></span><br><span class="line">INFO  [alembic.runtime.migration] Context impl MySQLImpl.</span><br><span class="line">INFO  [alembic.runtime.migration] Will assume non-transactional DDL.</span><br><span class="line">INFO  [alembic.runtime.migration] Running upgrade  -&gt; 001, Kilo release</span><br><span class="line">INFO  [alembic.runtime.migration] Running upgrade 001 -&gt; 002, Kilo</span><br><span class="line">INFO  [alembic.runtime.migration] Running upgrade 002 -&gt; 003, cron_trigger_constraints</span><br><span class="line">INFO  [alembic.runtime.migration] Running upgrade 003 -&gt; 004, add description for execution</span><br><span class="line">INFO  [alembic.runtime.migration] Running upgrade 004 -&gt; 005, Increase executions_v2 column size from JsonDictType to JsonLongDictType</span><br><span class="line">INFO  [alembic.runtime.migration] Running upgrade 005 -&gt; 006, add a Boolean column &apos;processed&apos; to the table  delayed_calls_v2</span><br><span class="line">INFO  [alembic.runtime.migration] Running upgrade 006 -&gt; 007, Move system flag to base definition</span><br><span class="line">INFO  [alembic.runtime.migration] Running upgrade 007 -&gt; 008, Increase size of state_info column from String to Text</span><br><span class="line">INFO  [alembic.runtime.migration] Running upgrade 008 -&gt; 009, Add database indices</span><br><span class="line">INFO  [alembic.runtime.migration] Running upgrade 009 -&gt; 010, add_resource_members_v2_table</span><br><span class="line">INFO  [alembic.runtime.migration] Running upgrade 010 -&gt; 011, add workflow id for execution</span><br><span class="line">INFO  [alembic.runtime.migration] Running upgrade 011 -&gt; 012, add event triggers table</span><br><span class="line">INFO  [alembic.runtime.migration] Running upgrade 012 -&gt; 013, split_execution_table_increase_names</span><br><span class="line">INFO  [alembic.runtime.migration] Running upgrade 013 -&gt; 014, fix_past_scripts_discrepancies</span><br><span class="line">INFO  [alembic.runtime.migration] Running upgrade 014 -&gt; 015, add_unique_keys_for_non_locking_model</span><br><span class="line">INFO  [alembic.runtime.migration] Running upgrade 015 -&gt; 016, Increase size of task_executions_v2.unique_key</span><br><span class="line">INFO  [alembic.runtime.migration] Running upgrade 016 -&gt; 017, Add named lock table</span><br><span class="line">INFO  [alembic.runtime.migration] Running upgrade 017 -&gt; 018, increate_task_execution_unique_key_size</span><br><span class="line">INFO  [alembic.runtime.migration] Running upgrade 018 -&gt; 019, Change scheduler schema.</span><br><span class="line">INFO  [alembic.runtime.migration] Running upgrade 019 -&gt; 020, add type to task execution</span><br><span class="line">INFO  [alembic.runtime.migration] Running upgrade 020 -&gt; 021, Increase environments_v2 column size from JsonDictType to JsonLongDictType</span><br></pre></td></tr></table></figure><h2 id="11、添加自带的action"><a href="#11、添加自带的action" class="headerlink" title="11、添加自带的action"></a>11、添加自带的action</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">root@controller:/home/openstack# mistral-db-manage --config-file /etc/mistral/mistral.conf populate</span><br><span class="line">*输出结果可能为：*</span><br><span class="line">No handlers could be found for logger &quot;mistral.actions.openstack.action_generator.base&quot;</span><br><span class="line">*也可能会出错：*</span><br><span class="line">……</span><br><span class="line">2017-12-22 22:21:24.486 16802 INFO mistral.actions.openstack.action_generator.base [-] Processing OpenStack action mapping from file: /usr/local/lib/python2.7/dist-packages/mistral/actions/openstack/mapping.json</span><br><span class="line">2017-12-22 22:21:24.551 16802 INFO mistral.actions.openstack.action_generator.base [-] Processing OpenStack action mapping from file: /usr/local/lib/python2.7/dist-packages/mistral/actions/openstack/mapping.json</span><br><span class="line">2017-12-22 22:21:24.761 16802 INFO mistral.actions.openstack.action_generator.base [-] Processing OpenStack action mapping from file: /usr/local/lib/python2.7/dist-packages/mistral/actions/openstack/mapping.json</span><br><span class="line">2017-12-22 22:21:24.878 16802 INFO mistral.actions.openstack.action_generator.base [-] Processing OpenStack action mapping from file: /usr/local/lib/python2.7/dist-packages/mistral/actions/openstack/mapping.json</span><br><span class="line">2017-12-22 22:21:24.883 16802 WARNING oslo_config.cfg [-] Option &quot;auth_uri&quot; from group &quot;keystone_authtoken&quot; is deprecated for removal (The auth_uri option is deprecated in favor of www_authenticate_uri and will be removed in the S  release.).  Its value may be silently ignored in the future.</span><br><span class="line">^C2017-12-22 22:21:25.382 16802 CRITICAL Mistral [-] Unhandled error: KeyboardInterrupt</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral Traceback (most recent call last):</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;/usr/local/bin/mistral-db-manage&quot;, line 10, in &lt;module&gt;</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     sys.exit(main())</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;/usr/local/lib/python2.7/dist-packages/mistral/db/sqlalchemy/migration/cli.py&quot;, line 137, in main</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     CONF.command.func(config, CONF.command.name)</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;/usr/local/lib/python2.7/dist-packages/mistral/db/sqlalchemy/migration/cli.py&quot;, line 75, in do_populate</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     action_manager.sync_db()</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;/usr/local/lib/python2.7/dist-packages/mistral/services/action_manager.py&quot;, line 80, in sync_db</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     register_action_classes()</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;/usr/local/lib/python2.7/dist-packages/mistral/services/action_manager.py&quot;, line 126, in register_action_classes</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     _register_dynamic_action_classes()</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;/usr/local/lib/python2.7/dist-packages/mistral/services/action_manager.py&quot;, line 86, in _register_dynamic_action_classes</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     actions = generator.create_actions()</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;/usr/local/lib/python2.7/dist-packages/mistral/actions/openstack/action_generator/base.py&quot;, line 143, in create_actions</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     client_method = class_.get_fake_client_method()</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;/usr/local/lib/python2.7/dist-packages/mistral/actions/openstack/base.py&quot;, line 75, in get_fake_client_method</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     return cls._get_client_method(cls._get_fake_client())</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;/usr/local/lib/python2.7/dist-packages/mistral/actions/openstack/actions.py&quot;, line 380, in _get_fake_client</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     return cls._get_client_class()(session=sess)</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;/usr/local/lib/python2.7/dist-packages/ironic_inspector_client/v1.py&quot;, line 88, in __init__</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     super(ClientV1, self).__init__(**kwargs)</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;/usr/local/lib/python2.7/dist-packages/ironic_inspector_client/common/http.py&quot;, line 134, in __init__</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     region_name=region_name)</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;/usr/lib/python2.7/dist-packages/keystoneauth1/session.py&quot;, line 856, in get_endpoint</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     return auth.get_endpoint(self, **kwargs)</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;/usr/lib/python2.7/dist-packages/keystoneauth1/identity/base.py&quot;, line 212, in get_endpoint</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     service_catalog = self.get_access(session).service_catalog</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;/usr/lib/python2.7/dist-packages/keystoneauth1/identity/base.py&quot;, line 136, in get_access</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     self.auth_ref = self.get_auth_ref(session)</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;/usr/lib/python2.7/dist-packages/keystoneauth1/identity/generic/base.py&quot;, line 198, in get_auth_ref</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     return self._plugin.get_auth_ref(session, **kwargs)</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;/usr/lib/python2.7/dist-packages/keystoneauth1/identity/v3/base.py&quot;, line 167, in get_auth_ref</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     authenticated=False, log=False, **rkwargs)</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;/usr/lib/python2.7/dist-packages/keystoneauth1/session.py&quot;, line 766, in post</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     return self.request(url, &apos;POST&apos;, **kwargs)</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;/usr/lib/python2.7/dist-packages/positional/__init__.py&quot;, line 101, in inner</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     return wrapped(*args, **kwargs)</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;/usr/lib/python2.7/dist-packages/keystoneauth1/session.py&quot;, line 616, in request</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     resp = send(**kwargs)</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;/usr/lib/python2.7/dist-packages/keystoneauth1/session.py&quot;, line 674, in _send_request</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     resp = self.session.request(method, url, **kwargs)</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;/usr/local/lib/python2.7/dist-packages/requests/sessions.py&quot;, line 508, in request</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     resp = self.send(prep, **send_kwargs)</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;/usr/local/lib/python2.7/dist-packages/requests/sessions.py&quot;, line 618, in send</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     r = adapter.send(request, **kwargs)</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;/usr/local/lib/python2.7/dist-packages/requests/adapters.py&quot;, line 440, in send</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     timeout=timeout</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;/usr/local/lib/python2.7/dist-packages/urllib3/connectionpool.py&quot;, line 601, in urlopen</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     chunked=chunked)</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;/usr/local/lib/python2.7/dist-packages/urllib3/connectionpool.py&quot;, line 380, in _make_request</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     httplib_response = conn.getresponse(buffering=True)</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;/usr/lib/python2.7/httplib.py&quot;, line 1136, in getresponse</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     response.begin()</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;/usr/lib/python2.7/httplib.py&quot;, line 453, in begin</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     version, status, reason = self._read_status()</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;/usr/lib/python2.7/httplib.py&quot;, line 409, in _read_status</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     line = self.fp.readline(_MAXLINE + 1)</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;/usr/lib/python2.7/socket.py&quot;, line 480, in readline</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     data = self._sock.recv(self._rbufsize)</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral KeyboardInterrupt</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral</span><br></pre></td></tr></table></figure><p>纠结了很久后发现这些都不用太在意，直接跳过，哈哈！</p><h1 id="三、安装Mistral-client"><a href="#三、安装Mistral-client" class="headerlink" title="三、安装Mistral client"></a>三、安装Mistral client</h1><h2 id="1、下载Mistral-client源码"><a href="#1、下载Mistral-client源码" class="headerlink" title="1、下载Mistral-client源码"></a>1、下载Mistral-client源码</h2><pre><code>$ git clone git://git.openstack.org/openstack/python-mistralclient.git -b stable/ocata$ cd python-mistralclient</code></pre><h2 id="2、安装Mistral-client模块"><a href="#2、安装Mistral-client模块" class="headerlink" title="2、安装Mistral-client模块"></a>2、安装Mistral-client模块</h2><pre><code>$ pip install -r requirements.txt$ python setup.py install</code></pre><h1 id="四、安装Mistral-horizon"><a href="#四、安装Mistral-horizon" class="headerlink" title="四、安装Mistral horizon"></a>四、安装Mistral horizon</h1><h2 id="1、下载Mistral-horizon源码"><a href="#1、下载Mistral-horizon源码" class="headerlink" title="1、下载Mistral-horizon源码"></a>1、下载Mistral-horizon源码</h2><pre><code>$ git clone https://git.openstack.org/openstack/mistral-dashboard.git -b stable/ocata$ cd mistral-dashboard/</code></pre><h2 id="2、安装Mistral-horizon模块"><a href="#2、安装Mistral-horizon模块" class="headerlink" title="2、安装Mistral-horizon模块"></a>2、安装Mistral-horizon模块</h2><pre><code>$ pip install -r requirements.txt$ python setup.py install</code></pre><h2 id="3、复制一个文件"><a href="#3、复制一个文件" class="headerlink" title="3、复制一个文件"></a>3、复制一个文件</h2><pre><code># cp -b mistraldashboard/enabled/_50_mistral.py /usr/share/openstack-dashboard/openstack_dashboard/enabled/_50_mistral.py</code></pre><h2 id="4、重启apache2服务"><a href="#4、重启apache2服务" class="headerlink" title="4、重启apache2服务"></a>4、重启apache2服务</h2><pre><code># service apache2 restart</code></pre><p>安装好Mistral-horizon后，admin用户登录dashboard界面就可以看到Mistral相关的workflow，如图：<br><img src="https://raw.githubusercontent.com/cao0507/Pictures/master/blog/mistral%20horizon.png" alt="Mistral-horizon界面"></p><h1 id="五、运行Mistral-server"><a href="#五、运行Mistral-server" class="headerlink" title="五、运行Mistral server"></a>五、运行Mistral server</h1><p>运行下面的第一条命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">root@controller:/home/openstack/mistral# python mistral/cmd/launch.py --server all --config-file /etc/mistral/mistral.conf</span><br><span class="line"></span><br><span class="line">|\\    //|           ||                       ||</span><br><span class="line">||\\  //||      __   ||      __      __       ||</span><br><span class="line">|| \\// || ||  //  ||||||  ||  \\  //  \\     ||</span><br><span class="line">||  \/  ||     \\    ||    ||     ||    \\    ||</span><br><span class="line">||      || ||   \\   ||    ||     ||    /\\   ||</span><br><span class="line">||      || || __//   ||_// ||      \\__// \\_ ||</span><br><span class="line">Mistral Workflow Service, version 6.0.0</span><br><span class="line"></span><br><span class="line">Launching server components [engine,event-engine,api,executor]...</span><br><span class="line">2017-12-22 22:42:58.373 16966 INFO mistral.event_engine.default_event_engine [-] Starting event notification task...</span><br><span class="line">2017-12-22 22:42:58.571 16966 INFO mistral.event_engine.default_event_engine [-] Found 0 event triggers.</span><br><span class="line">/usr/local/lib/python2.7/dist-packages/oslo_messaging/server.py:341: FutureWarning: blocking executor is deprecated. Executor default will be removed. Use explicitly threading or eventlet instead in version &apos;pike&apos; and will be removed in version &apos;rocky&apos;</span><br><span class="line">  category=FutureWarning)</span><br><span class="line">2017-12-22 22:42:58.913 16966 WARNING oslo_config.cfg [req-46885c1b-de53-4bba-958d-97484cd17783 - - - - -] Option &quot;auth_uri&quot; from group &quot;keystone_authtoken&quot; is deprecated for removal (The auth_uri option is deprecated in favor of www_authenticate_uri and will be removed in the S  release.).  Its value may be silently ignored in the future.</span><br><span class="line">2017-12-22 22:42:58.915 16966 WARNING oslo_config.cfg [req-46885c1b-de53-4bba-958d-97484cd17783 - - - - -] Option &quot;auth_uri&quot; from group &quot;keystone_authtoken&quot; is deprecated. Use option &quot;www_authenticate_uri&quot; from group &quot;keystone_authtoken&quot;.</span><br><span class="line">2017-12-22 22:42:58.925 16966 WARNING keystonemiddleware.auth_token [req-46885c1b-de53-4bba-958d-97484cd17783 - - - - -] AuthToken middleware is set with keystone_authtoken.service_token_roles_required set to False. This is backwards compatible but deprecated behaviour. Please set this to True.</span><br><span class="line">2017-12-22 22:42:58.926 16966 WARNING keystonemiddleware.auth_token [req-46885c1b-de53-4bba-958d-97484cd17783 - - - - -] Use of the auth_admin_prefix, auth_host, auth_port, auth_protocol, identity_uri, admin_token, admin_user, admin_password, and admin_tenant_name configuration options was deprecated in the Mitaka release in favor of an auth_plugin and its related options. This class may be removed in a future release.</span><br><span class="line">2017-12-22 22:42:58.931 16966 INFO oslo.service.wsgi [req-46885c1b-de53-4bba-958d-97484cd17783 - - - - -] mistral_api listening on 0.0.0.0:8989</span><br><span class="line">2017-12-22 22:42:58.932 16966 INFO oslo_service.service [req-46885c1b-de53-4bba-958d-97484cd17783 - - - - -] Starting 4 workers</span><br><span class="line">API server started.</span><br><span class="line">API server started.</span><br><span class="line">API server started.</span><br><span class="line">API server started.</span><br><span class="line">Event engine server started.</span><br><span class="line">Executor server started.</span><br><span class="line">Engine server started.</span><br></pre></td></tr></table></figure></p><h1 id="六、测试一下Mistral是否可用"><a href="#六、测试一下Mistral是否可用" class="headerlink" title="六、测试一下Mistral是否可用"></a>六、测试一下Mistral是否可用</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">openstack@controller:~/mistral/etc$ mistral workbook-list</span><br><span class="line">+--------+--------+------------+------------+</span><br><span class="line">| Name   | Tags   | Created at | Updated at |</span><br><span class="line">+--------+--------+------------+------------+</span><br><span class="line">| &lt;none&gt; | &lt;none&gt; | &lt;none&gt;     | &lt;none&gt;     |</span><br><span class="line">+--------+--------+------------+------------+</span><br><span class="line"></span><br><span class="line">openstack@controller:~/mistral/etc$ mistral action-list</span><br><span class="line">+--------+--------+-----------+--------+-------------+--------+------------+------------+</span><br><span class="line">| ID     | Name   | Is system | Input  | Description | Tags   | Created at | Updated at |</span><br><span class="line">+--------+--------+-----------+--------+-------------+--------+------------+------------+</span><br><span class="line">| &lt;none&gt; | &lt;none&gt; | &lt;none&gt;    | &lt;none&gt; | &lt;none&gt;      | &lt;none&gt; | &lt;none&gt;     | &lt;none&gt;     |</span><br><span class="line">+--------+--------+-----------+--------+-------------+--------+------------+------------+</span><br></pre></td></tr></table></figure><p>OK，成功了，开心！！！</p><hr>]]></content>
      
      <categories>
          
          <category> Openstack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Openstack </tag>
            
            <tag> Tacker </tag>
            
            <tag> Mistral </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Openstack环境下手动安装Tacker</title>
      <link href="/2017/12/23/Openstack%E7%8E%AF%E5%A2%83%E4%B8%8B%E6%89%8B%E5%8A%A8%E5%AE%89%E8%A3%85Tacker/"/>
      <url>/2017/12/23/Openstack%E7%8E%AF%E5%A2%83%E4%B8%8B%E6%89%8B%E5%8A%A8%E5%AE%89%E8%A3%85Tacker/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本文参考官方文档，在现有的openstack平台上，手动安装Tacker。基础的openstack平台包含了最核心的keystone、glance、nova、neutron、horizon这5个组件，但是Tacker还需要预先安装好Mistral和Barbican这两个组件，在安装好这两个组件后就可以开始按照以下步骤安装Tacker了。<br><a id="more"></a><br>参考：<a href="https://docs.openstack.org/tacker/latest/install/manual_installation.html" target="_blank" rel="noopener"><em>官方文档链接</em></a></p><p><strong>注：</strong> 本文涉及到的密码都统一设置成<em>openstack</em>。</p><h1 id="一、安装Tacker-server"><a href="#一、安装Tacker-server" class="headerlink" title="一、安装Tacker server"></a>一、安装Tacker server</h1><h2 id="1、创建数据库"><a href="#1、创建数据库" class="headerlink" title="1、创建数据库"></a>1、创建数据库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># mysql</span><br><span class="line">MariaDB [(none)]&gt; CREATE DATABASE tacker;</span><br><span class="line">MariaDB [tacker]&gt; GRANT ALL PRIVILEGES ON tacker.* TO &apos;tacker&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;openstack&apos;;</span><br><span class="line">MariaDB [tacker]&gt; GRANT ALL PRIVILEGES ON tacker.* TO &apos;tacker&apos;@&apos;%&apos; IDENTIFIED BY &apos;openstack&apos;;</span><br><span class="line">MariaDB [tacker]&gt; exit;</span><br></pre></td></tr></table></figure><h2 id="2、创建user、role、endpoints"><a href="#2、创建user、role、endpoints" class="headerlink" title="2、创建user、role、endpoints"></a>2、创建user、role、endpoints</h2><h3 id="1-获得admin凭证"><a href="#1-获得admin凭证" class="headerlink" title="1)获得admin凭证"></a>1)获得admin凭证</h3><pre><code># . admin-openrc</code></pre><h3 id="2-创建tacker用户，密码为openstack"><a href="#2-创建tacker用户，密码为openstack" class="headerlink" title="2)创建tacker用户，密码为openstack"></a>2)创建tacker用户，密码为openstack</h3><pre><code># openstack user create --domain default --password openstack tacker</code></pre><h3 id="3-给tacker用户赋予admin权限"><a href="#3-给tacker用户赋予admin权限" class="headerlink" title="3)给tacker用户赋予admin权限"></a>3)给tacker用户赋予admin权限</h3><pre><code># openstack role add --project service --user tacker admin</code></pre><h3 id="4-创建tacker服务"><a href="#4-创建tacker服务" class="headerlink" title="4)创建tacker服务"></a>4)创建tacker服务</h3><pre><code># openstack service create --name tacker \    --description &quot;Tacker Project&quot; nfv-orchestration</code></pre><h3 id="5-创建endpoints"><a href="#5-创建endpoints" class="headerlink" title="5)创建endpoints"></a>5)创建endpoints</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># openstack endpoint create --region RegionOne nfv-orchestration \</span><br><span class="line">           public http://controller:9890/</span><br><span class="line"># openstack endpoint create --region RegionOne nfv-orchestration \</span><br><span class="line">           internal http://controller:9890/</span><br><span class="line"># openstack endpoint create --region RegionOne nfv-orchestration \</span><br><span class="line">           admin http://controller:9890/</span><br></pre></td></tr></table></figure><h2 id="3、下载Tacker源码"><a href="#3、下载Tacker源码" class="headerlink" title="3、下载Tacker源码"></a>3、下载Tacker源码</h2><pre><code># git clone https://github.com/openstack/tacker -b stable/ocata</code></pre><h2 id="4、安装Tacker环境依赖包"><a href="#4、安装Tacker环境依赖包" class="headerlink" title="4、安装Tacker环境依赖包"></a>4、安装Tacker环境依赖包</h2><pre><code># cd tacker# pip install -r requirements.txt</code></pre><h2 id="5、安装Tacker"><a href="#5、安装Tacker" class="headerlink" title="5、安装Tacker"></a>5、安装Tacker</h2><pre><code># python setup.py install</code></pre><h2 id="6、创建Tacker日志文件夹"><a href="#6、创建Tacker日志文件夹" class="headerlink" title="6、创建Tacker日志文件夹"></a>6、创建Tacker日志文件夹</h2><pre><code># mkdir -p /var/log/tacker</code></pre><h2 id="7、生成配置文件"><a href="#7、生成配置文件" class="headerlink" title="7、生成配置文件"></a>7、生成配置文件</h2><pre><code># ./tools/generate_config_file_sample.sh这时生成的配置文件在etc/tacker/tacker.conf.sample，需要将其重命名为tacker.conf# mv etc/tacker/tacker.conf.sample  etc/tacker/tacker.conf</code></pre><h2 id="8、修改配置文件"><a href="#8、修改配置文件" class="headerlink" title="8、修改配置文件"></a>8、修改配置文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"># vi etc/tacker/tacker.conf</span><br><span class="line"></span><br><span class="line">[DEFAULT]</span><br><span class="line">auth_strategy = keystone</span><br><span class="line">policy_file = /usr/local/etc/tacker/policy.json</span><br><span class="line">debug = True</span><br><span class="line">use_syslog = False</span><br><span class="line">bind_host = 10.0.0.11</span><br><span class="line">bind_port = 9890</span><br><span class="line">service_plugins = nfvo,vnfm</span><br><span class="line"></span><br><span class="line">state_path = /var/lib/tacker</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">[nfvo]</span><br><span class="line">vim_drivers = openstack</span><br><span class="line"></span><br><span class="line">[keystone_authtoken]</span><br><span class="line">memcached_servers = 11211</span><br><span class="line">region_name = RegionOne</span><br><span class="line">auth_type = password</span><br><span class="line">project_domain_name = Default</span><br><span class="line">user_domain_name = Default</span><br><span class="line">username = tacker</span><br><span class="line">project_name = service</span><br><span class="line">password = openstack</span><br><span class="line">auth_url = http://controller:35357</span><br><span class="line">auth_uri = http://controller:5000</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">[agent]</span><br><span class="line">root_helper = sudo /usr/local/bin/tacker-rootwrap /usr/local/etc/tacker/rootwrap.conf</span><br><span class="line"></span><br><span class="line">[database]</span><br><span class="line">connection = mysql://tacker:openstack@controller:3306/tacker?charset=utf8</span><br><span class="line"></span><br><span class="line">[tacker]</span><br><span class="line">monitor_driver = ping,http_ping</span><br></pre></td></tr></table></figure><h2 id="9、复制配置文件到配置文件夹"><a href="#9、复制配置文件到配置文件夹" class="headerlink" title="9、复制配置文件到配置文件夹"></a>9、复制配置文件到配置文件夹</h2><pre><code># cp etc/tacker/tacker.conf  /usr/local/etc/tacker/</code></pre><h2 id="10、初始化数据库信息"><a href="#10、初始化数据库信息" class="headerlink" title="10、初始化数据库信息"></a>10、初始化数据库信息</h2><pre><code># /usr/local/bin/tacker-db-manage --config-file /usr/local/etc/tacker/tacker.conf upgrade head</code></pre><h1 id="二、安装Tacker-client"><a href="#二、安装Tacker-client" class="headerlink" title="二、安装Tacker client"></a>二、安装Tacker client</h1><h2 id="1、下载Tacker-client源码"><a href="#1、下载Tacker-client源码" class="headerlink" title="1、下载Tacker-client源码"></a>1、下载Tacker-client源码</h2><pre><code># git clone https://github.com/openstack/python-tackerclient -b stable/ocata</code></pre><h2 id="2、安装Tacker-client模块"><a href="#2、安装Tacker-client模块" class="headerlink" title="2、安装Tacker-client模块"></a>2、安装Tacker-client模块</h2><pre><code># cd python-tackerclient# python setup.py install</code></pre><h1 id="三、安装Tacker-horizon"><a href="#三、安装Tacker-horizon" class="headerlink" title="三、安装Tacker horizon"></a>三、安装Tacker horizon</h1><h2 id="1、下载Tacker-horizon源码"><a href="#1、下载Tacker-horizon源码" class="headerlink" title="1、下载Tacker-horizon源码"></a>1、下载Tacker-horizon源码</h2><pre><code># git clone https://github.com/openstack/tacker-horizon -b stable/ocata</code></pre><h2 id="2、安装Tacker-horizon模块"><a href="#2、安装Tacker-horizon模块" class="headerlink" title="2、安装Tacker-horizon模块"></a>2、安装Tacker-horizon模块</h2><pre><code># cd tacker-horizon# python setup.py install</code></pre><p>安装好tacker-horizon后，admin用户登录dashboard界面就可以看到Tacker相关的VNFM和NFVO，如图：<br><img src="https://raw.githubusercontent.com/cao0507/Pictures/master/blog/tacker%20horizon.png" alt="tacker-horizon"></p><h1 id="四、开启Tacker-server"><a href="#四、开启Tacker-server" class="headerlink" title="四、开启Tacker server"></a>四、开启Tacker server</h1><p>打开一个新的终端，开启Tacker-server，因为Tacker-server的程序会独占这个终端。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo python /usr/local/bin/tacker-server \</span><br><span class="line">    --config-file /usr/local/etc/tacker/tacker.conf \</span><br><span class="line">    --log-file /var/log/tacker/tacker.log</span><br></pre></td></tr></table></figure></p><hr><p><strong>需注意的一个问题：</strong></p><p>在安装完Tacker而没有装Mistral时创建VIM的结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@controller:/home/openstack# tacker vim-register --is-default --config-file config.yaml test_vim</span><br><span class="line">The resource could not be found.</span><br><span class="line"></span><br><span class="line">或者是这种错误：Expecting to find domain in project. The server could not comply with the request since it is either malformed or otherwise incorrect. The client is assumed to be in error.</span><br></pre></td></tr></table></figure></p><p>经过查阅资料，知道这个问题是因为Tacker在创建VIM时要调用Mistral而造成的。所以在使用tacker之前需要先安装好Mistral（可以在安装tacker前安装Mistral，也可以在tacker安装之后安装Mistral，后续还需继续了解）。</p><hr>]]></content>
      
      <categories>
          
          <category> Openstack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Openstack </tag>
            
            <tag> Tacker </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>KVM虚拟机部署openstack的网络配置</title>
      <link href="/2017/12/03/KVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%83%A8%E7%BD%B2openstack%E7%9A%84%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"/>
      <url>/2017/12/03/KVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%83%A8%E7%BD%B2openstack%E7%9A%84%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>这篇文章记录的是按照官方文档在<strong>KVM环境</strong>下部署<strong>双节点openstack</strong>过程中，前期准备KVM环境和网络配置相关的内容，在完成这篇博客涉及到的工作之后就可以按照官方文档手动安装openstack了。本文涉及的主要工作，首先是在服务器的<strong>ubuntu 16.04 desktop版</strong>系统上搭建kvm环境，然后在服务器上安装VNC远程桌面，最后在KVM环境中开启两台虚拟机，分别两张网卡，第一张网卡使用<strong>桥接模式</strong>，第二张网卡使用<strong>NAT模式</strong>。下面开始介绍一下这个过程。</p><a id="more"></a><h1 id="服务器搭建KVM环境"><a href="#服务器搭建KVM环境" class="headerlink" title="服务器搭建KVM环境"></a>服务器搭建KVM环境</h1><h2 id="查看CPU是否支持KVM"><a href="#查看CPU是否支持KVM" class="headerlink" title="查看CPU是否支持KVM"></a>查看CPU是否支持KVM</h2><p><code>$ egrep -c &quot;(svm|vmx)&quot; /proc/cpuinfo</code></p><p>输出结果大于0证明CPU支持KVM虚拟化 </p><p><img src="https://raw.githubusercontent.com/cao0507/Pictures/master/blog/infocpu.png" alt="虚拟CPU个数"></p><h2 id="安装KVM及相关依赖包"><a href="#安装KVM及相关依赖包" class="headerlink" title="安装KVM及相关依赖包"></a>安装KVM及相关依赖包</h2><p><code>$ sudo apt-get install qemu-kvm qemu virt-manager virt-viewer libvirt-bin bridge-utils</code></p><h2 id="启用桥接网络"><a href="#启用桥接网络" class="headerlink" title="启用桥接网络"></a>启用桥接网络</h2><p>在服务器上启用桥接网络需要配置一个桥接设备br0，配置br0有两种方式，通过手动配置和通过修改文件配置。 </p><h3 id="通过手动配置"><a href="#通过手动配置" class="headerlink" title="通过手动配置"></a>通过手动配置</h3><ul><li><p>创建br0网桥</p><p> <code># brctl addbr br0</code></p></li><li><p>将eth0网卡添加到br0上，此时可能会断网</p><p><code># brctl addif br0 eth0</code></p></li><li><p>删除eth0上的IP地址</p><p><code># ip addr del dev eth0 192.168.1.25/24</code></p></li><li><p>配置br0的IP地址并启动br0网桥设备</p><p><code># ifconfig br0 192.168.1.25/24 up</code></p></li><li><p>重新加入默认网关</p><p><code># route add default gw 192.168.1.1</code></p></li><li><p>查看配置是否生效 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># route     //查看默认网关，输出结果如下</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination             Gateway             Genmask         Flags     Metric      Ref    Use     Iface</span><br><span class="line">default              192.168.1.1             0.0.0.0          UG        0          0      0        br0</span><br><span class="line">192.168.1.0             *                 255.255.255.0       U         0          0      0        br0</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># ifconfig     //查看eth0和br0的IP信息，输出结果如下，可以发现现在br0有IP而eth0没有IP了</span><br><span class="line">br0       Link encap:Ethernet  HWaddr 00:e0:81:e2:3c:3d  </span><br><span class="line">          inet addr:192.168.1.25  Bcast:192.168.1.255  Mask:255.255.255.0</span><br><span class="line">          inet6 addr: fe80::2e0:81ff:fee2:3c3d/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:1316822 errors:0 dropped:5787 overruns:0 frame:0</span><br><span class="line">          TX packets:365475 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000</span><br><span class="line">          RX bytes:581279124 (581.2 MB)  TX bytes:562586852 (562.5 MB)</span><br><span class="line"> </span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 00:e0:81:e2:3c:3d  </span><br><span class="line">          inet6 addr: fe80::2e0:81ff:fee2:3c3d/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:6671034 errors:0 dropped:9627 overruns:0 frame:0</span><br><span class="line">          TX packets:840972 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000</span><br><span class="line">          RX bytes:1346523816 (1.3 GB)  TX bytes:614510541 (614.5 MB)</span><br><span class="line">          Memory:dfb80000-dfbfffff</span><br><span class="line"> </span><br><span class="line">lo        Link encap:Local Loopback  </span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          inet6 addr: ::1/128 Scope:Host</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class="line">          RX packets:1450290 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:1450290 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000</span><br><span class="line">          RX bytes:24027042487 (24.0 GB)  TX bytes:24027042487 (24.0 GB)</span><br></pre></td></tr></table></figure></li></ul><p>这就是通过手动来配置桥接设备br0的方法，这种方法在配置好之后马上就生效了，但是在系统重启之后这些配置信息都会被清除，要想使配置永久生效则需要修改网络配置文件，也就是下面的方法。 </p><h3 id="通过修改文件配置"><a href="#通过修改文件配置" class="headerlink" title="通过修改文件配置"></a>通过修改文件配置</h3><ul><li><p>修改前先将网络配置文件进行备份</p><p><code># cp  /etc/network/interfaces  /etc/network/interfaces.bak</code></p></li><li><p>修改网络配置文件<code>/etc/network/interfaces</code></p><p><code># vi  /etc/network/interfaces    //修改结果如下</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line"> </span><br><span class="line"># Enabing Bridge networking br0 interface</span><br><span class="line">auto br0</span><br><span class="line">iface br0 inet static</span><br><span class="line">address 192.168.1.25</span><br><span class="line">network 192.168.1.0</span><br><span class="line">netmask 255.255.255.0</span><br><span class="line">broadcast 192.168.1.255</span><br><span class="line">gateway 192.168.1.1</span><br><span class="line">dns-nameservers 223.5.5.5</span><br><span class="line">bridge_ports eth0</span><br><span class="line">bridge_stp off</span><br></pre></td></tr></table></figure></li></ul><p>保存后退出，关机重启中配置文件就生效了。这种方法只需要修改配置文件然后重启就可以，比较简单，而且是永久生效，比较符合我们的需求，因为我们的虚拟机通过桥接模式连接外网的话都是连接到br0上的。 </p><h2 id="修改virbr0的网段"><a href="#修改virbr0的网段" class="headerlink" title="修改virbr0的网段"></a>修改virbr0的网段</h2><p>在服务器上安装好虚拟化软件后，KVM会自动生成一个<code>virbr0</code>的桥接设备，它的作用是为连接其上的虚拟网卡提供NAT访问外网的功能，并提供DHCP服务。<code>virbr0</code>默认分配的IP是<code>192.168.122.1</code>，使用 <code>ifconfig</code> 命令查看得<code>virbr0</code>的信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$  ifconfig</span><br><span class="line">……</span><br><span class="line"> </span><br><span class="line">virbr0    Link encap:Ethernet  HWaddr 52:54:00:f8:70:e3  </span><br><span class="line">          inet addr:192.168.122.1  Bcast:192.168.122.255  Mask:255.255.255.0</span><br><span class="line">          UP BROADCAST MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:0 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000</span><br><span class="line">          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)</span><br></pre></td></tr></table></figure><p> 在这种情况下，连接到virbr0上的虚拟机的虚拟网卡也是在192.168.122.0网段上的，如果让连接到virbr0上的虚拟网卡在自定义的网段上就需要修改virbr0的网段，修改方法如下： </p><p><code># virsh  net-edit  default</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;network&gt;</span><br><span class="line">  &lt;name&gt;default&lt;/name&gt;</span><br><span class="line">  &lt;uuid&gt;91cc230a-bf53-487c-b296-10323705d7e8&lt;/uuid&gt;</span><br><span class="line">  &lt;forward mode=&apos;nat&apos;/&gt;</span><br><span class="line">  &lt;bridge name=&apos;virbr0&apos; stp=&apos;on&apos; delay=&apos;0&apos;/&gt;</span><br><span class="line">  &lt;mac address=&apos;52:54:00:f8:70:e3&apos;/&gt;</span><br><span class="line">  &lt;ip address=&apos;10.0.0.1&apos; netmask=&apos;255.255.255.0&apos;&gt;</span><br><span class="line">    &lt;dhcp&gt;</span><br><span class="line">      &lt;range start=&apos;10.0.0.2&apos; end=&apos;10.0.0.254&apos;/&gt;</span><br><span class="line">    &lt;/dhcp&gt;</span><br><span class="line">  &lt;/ip&gt;</span><br><span class="line">&lt;/network&gt;</span><br></pre></td></tr></table></figure><p>这样就将<code>virbr0</code>的网段改成<code>10.0.0.0/24</code>，连接到<code>virbr0</code>的虚拟网卡的IP将会在<code>10.0.0.2/24 - 10.0.0.254/24</code>范围内自动分配一个。如果有需要可以自己手动给虚拟网卡配置IP并写到配置文件中去。 </p><h1 id="服务器安装VNC远程桌面"><a href="#服务器安装VNC远程桌面" class="headerlink" title="服务器安装VNC远程桌面"></a>服务器安装VNC远程桌面</h1><p>因为服务器上安装的<code>Ubuntu 16.04 LTS  desktop</code>版的系统，在后续的工作中需要远程登录到服务器，虽然可以通过SSH远程管理服务器，但是可视化的界面往往会给新手用户提供很大的便利，所以可以在服务器上安装VNC。开始在服务器上安装VNC试过很多方法，VNC服务器端也有多种选择，如<code>VNC4server</code>、<code>tigervncserver</code>，感觉很麻烦，而且还不一定能安装成功，我安装的VNC服务器端是<code>x11VNC</code>，按照步骤可以很顺利地完成安装，步骤如下： </p><h2 id="安装x11VNC软件包"><a href="#安装x11VNC软件包" class="headerlink" title="安装x11VNC软件包"></a>安装x11VNC软件包</h2><p><code>$ sudo  apt-get  install  x11vnc</code></p><h2 id="配置访问密码"><a href="#配置访问密码" class="headerlink" title="配置访问密码"></a>配置访问密码</h2><p><code>$ sudo  x11vnc  -storepasswd  /etc/x11vnc.pass</code></p><h2 id="创建服务"><a href="#创建服务" class="headerlink" title="创建服务"></a>创建服务</h2><p><code># vi  /lib/systemd/system/x11vnc.service      //粘贴一下代码，最后:wq 保存，请使用root用户，否则没有权限</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Start x11vnc at startup.</span><br><span class="line">After=multi-user.target</span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">ExecStart=/usr/bin/x11vnc -auth guess -forever -loop -noxdamage -repeat -rfbauth /etc/x11vnc.pass -rfbport 5900 -shared</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><h2 id="配置防火墙，配置和启动服务"><a href="#配置防火墙，配置和启动服务" class="headerlink" title="配置防火墙，配置和启动服务"></a>配置防火墙，配置和启动服务</h2><p><code># ufw allow 5900</code></p><p><code># systemctl enable x11vnc.service</code></p><p><code># systemctl daemon-reload</code></p><p><code># systemctl start x11vnc.service</code></p><p>完成这四个步骤然后重启就可以了。（这个VNC的安装过程可以参考<a href="http://blog.csdn.net/longhr/article/details/51657610）" target="_blank" rel="noopener">http://blog.csdn.net/longhr/article/details/51657610）</a> </p><p>最后在你自己的电脑需要有一个vnc viewer的软件，可以在这里下载（链接：<a href="https://pan.baidu.com/s/1o8kPqXG" target="_blank" rel="noopener">https://pan.baidu.com/s/1o8kPqXG</a> 密码：v5r2） </p><h1 id="创建VM并配置相关信息"><a href="#创建VM并配置相关信息" class="headerlink" title="创建VM并配置相关信息"></a>创建VM并配置相关信息</h1><p>在安装好VNC后就可以登录服务器的远程桌面，打开一个terminal，在terminal中输入下面的命令可以打开Virtual Machine  Manager（注意，使用SSH远程登录服务器是无法打开virt-manager的界面的，一定要在登录了远程桌面后才能打开界面）</p><p><img src="https://img-blog.csdn.net/20171201233200479" alt="VMM"></p><p>使用Virtual Machine Manager的界面可以很方便的创建虚拟机，当然也可以在命令行中使用命令创建虚拟机，这个我就不在这里说了。 </p><h2 id="按照Openstack官网安装文档的主机网络配置两台虚拟机Controller和Compute"><a href="#按照Openstack官网安装文档的主机网络配置两台虚拟机Controller和Compute" class="headerlink" title="按照Openstack官网安装文档的主机网络配置两台虚拟机Controller和Compute"></a>按照Openstack官网安装文档的主机网络配置两台虚拟机Controller和Compute</h2><p><img src="https://raw.githubusercontent.com/cao0507/Pictures/master/blog/openstack%20network.png" alt="openstack network"></p><p>控制节点和计算节点这两个虚拟机分别两张网卡，一张配置为桥接模式，另一张配置为NAT模式。创建虚拟机时默认是添加一张网卡的，后面可以在虚拟机的硬件信息中添加。两张虚拟网卡的配置信息如图： </p><p><img src="https://raw.githubusercontent.com/cao0507/Pictures/master/blog/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E7%BD%91%E5%8D%A1.png" alt="compute1"></p><p>上图显示的是桥接模式网卡的配置信息，Network source选择为<code>Bridge br0：Host device eth0</code> </p><p><img src="https://raw.githubusercontent.com/cao0507/Pictures/master/blog/NAT%E7%BD%91%E5%8D%A1.png" alt="NAT"></p><p>上图显示的是NAT模式网卡的配置信息，Network source选择为<code>Virtual network ‘default’：NAT</code> </p><p>这样按照官方文档部署双节点Openstack的前期准备工作就已经做完，后面就可以按照官方文档开始安装openstack了，祝你成功。附上官方文档链接<a href="https://docs.openstack.org/ocata/zh_CN/install-guide-ubuntu/index.html" target="_blank" rel="noopener">https://docs.openstack.org/ocata/zh_CN/install-guide-ubuntu/index.html</a> （注：这个是在ubuntu系统下安装Ocata版本Openstack中文文档） </p><hr>]]></content>
      
      <categories>
          
          <category> KVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Openstack </tag>
            
            <tag> KVM </tag>
            
            <tag> vnc </tag>
            
            <tag> ubuntu </tag>
            
            <tag> Virtual Machine </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
