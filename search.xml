<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>自动化脚本与程序实现</title>
      <link href="/2018/07/09/%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC%E4%B8%8E%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/07/09/%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC%E4%B8%8E%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>最近的项目中有远程登录虚拟机并执行相关命令的需求，所以尝试了远程免密码登录虚拟机（在另一篇博客中有介绍<a href="https://cao0507.github.io/2018/07/07/远程免密码登录Openstack实例/">链接</a>)。但是发现这还不够，因为登录远程虚拟机后执行的脚本可能会有需要交互的操作，比如<code>sudo</code>命令需要输入密码，所以就想实现一个完全自动化的脚本，包括登录时的密码自动输入以及登录后执行命令的自动交互。查阅相关资料后学习到，在Linux中可以用<code>expect</code>来实现自动化的交互，且在python中也有相应的一个模块pexpect具有此功能。本文将先介绍<strong>shell自动化交互脚本</strong>的实现，然后介绍其<strong>python程序实现</strong>。</p><a id="more"></a><h1 id="shell脚本"><a href="#shell脚本" class="headerlink" title="shell脚本"></a>shell脚本</h1><h2 id="Expect介绍"><a href="#Expect介绍" class="headerlink" title="Expect介绍"></a>Expect介绍</h2><ol><li><p>简要介绍：</p><p>Expect 是由Don Libes基于<code>Tcl（Tool Command Language）</code>语言开发的，主要应用于自动化交互式操作的场景，借助expect处理交互的命令，可以将交互过程如：ssh登录，ftp登录等写在一个脚本上，使之自动化完成。尤其适用于需要对多台服务器执行相同操作的环境中，可以大大提高系统管理人员的工作效率 。</p></li><li><p>主要命令：</p><ul><li><p><strong>spawn</strong>：启动新的进程</p><p><code>spawn</code>命令会<code>fork</code>一个子进程去执行<code>command</code>命令，然后在此子进程中执行后面的命令；<code>spawn</code>后的<code>send</code>和<code>expect</code>命令都是和<code>spawn</code>打开的进程进行交互的。如果没有<code>spawn</code>语句，整个<code>Expect</code>就无法进行下去，当然，如果真的不要<code>spawn</code>过程也没有关系，虽然这样就没有办法单独执行，但是这个脚本可以与任何调用它的进程进行交互。 </p><p><strong>使用方法：</strong>ssh自动登录脚本中，通过<code>spawn ssh user_name@ip_addr</code>，<code>fork</code>一个子进程执行ssh登录命令；连接远程ftp服务器，<code>spawn ftp ftp.server.com</code>。</p></li><li><p><strong>expect</strong>：从进程接收字符串</p><p><code>expect</code>命令是Expect解释器的关键命令，它的一般用法为 <code>expect “string”</code>，即期望获取到<code>string</code>字符串，可在在<code>string</code>字符串里使用 * 等通配符。</p><p><strong>使用方法：</strong>在执行<code>spawn</code>命令ssh登录时，子进程会要求输入密码，因此可以使用<code>expect</code>命令检查子进程中的输出中是否包含<code>“password”</code>子字符串，命令为<code>expect &quot;password&quot;</code>。</p></li><li><p><strong>send</strong>：用于向进程发送字符串</p><p>send命令的一般用法为 send “string”，它们会我们平常输入命令一样向命令行输入一条信息，当然不要忘了在string后面添加上 \r 表示输入回车 。</p><p><strong>使用方法：</strong>在使用expect命令接收到字符串“password”后，就需要使用send命令来发送“PASSWORD”。</p></li><li><p><strong>interact</strong>：允许用户交互</p><p><code>interact</code>命令很简单，执行到此命令时，脚本<code>fork</code>的子进程会将操作权交给用户，允许用户与当前shell进行交互，让人在适当的时候干预这个过程了 。</p><p><strong>使用方法：</strong>直接在脚本适当的位置加入一行<code>interact</code>。</p></li></ul></li><li><p>安装方法：</p><p><code>$ sudo apt-get install expect</code></p></li></ol><h2 id="脚本编写"><a href="#脚本编写" class="headerlink" title="脚本编写"></a>脚本编写</h2><p>我需要实现一个脚本，其功能是ssh登录虚拟机，并在远程虚拟机用户目录下记录远程登录的日志文件，然后修改其<code>iptables</code>规则，禁止转发tcp 22号端口的报文。</p><ul><li><p>ssh登录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spawn ssh $user@$ip</span><br><span class="line">expect &#123;</span><br><span class="line">    &quot;(yes/no)&quot; &#123;send &quot;yes\r&quot;; exp_continue&#125;</span><br><span class="line">    &quot;password:&quot; &#123;send &quot;$password\r&quot;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>expect中可能会接收到两种字符串，”(yes/no)”表示你的主机还未登录过远程虚拟机，即你的用户目录下的文件<code>~/.ssh/know_hosts</code>中还未记录该远程虚拟机，问你是否需要将其添加到<code>know_hosts</code>中，回复”yes”，下次再登录就不会出现这个提醒了；然后就会收到<code>&quot;password:&quot;</code>，这时就需要将密码发送过去，这样就已经登录到远程虚拟机。</p></li><li><p>记录日志文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect &quot;*$&quot; &#123;send &quot;echo &apos;login +1&apos; &gt;&gt; ~/remote_login.log\r&quot;&#125;</span><br></pre></td></tr></table></figure><p>登录之后会收到”$”或”#”的命令行提示符，然后就可以发送需要执行的命令了。</p></li><li><p>修改<code>iptables</code>规则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect &quot;*$&quot; &#123;send &quot;sudo iptables -A FORWARD -p tcp --dport 22 -j REJECT\r&quot;&#125;</span><br><span class="line">expect &quot;password&quot; &#123;send &quot;$password\r&quot;&#125;</span><br></pre></td></tr></table></figure></li><li><p>退出子程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect &quot;*$&quot; &#123;send exit\r&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>完整的脚本：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/expect</span><br><span class="line">set ip 192.168.1.75</span><br><span class="line">set user openstack</span><br><span class="line">set passwd 123456</span><br><span class="line">set timeout 5</span><br><span class="line"></span><br><span class="line">spawn ssh $user@$ip</span><br><span class="line">expect &#123;</span><br><span class="line">    &quot;(yes/no)&quot; &#123;send &quot;yes\r&quot;; exp_continue&#125;</span><br><span class="line">    &quot;password:&quot; &#123;send &quot;$password\r&quot;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">expect &quot;*$&quot; &#123;send &quot;echo &apos;login +1&apos; &gt;&gt; ~/remote_login.log\r&quot;&#125;;</span><br><span class="line"></span><br><span class="line">expect &quot;*$&quot; &#123;send &quot;sudo iptables -A FORWARD -p tcp --dport 22 -j REJECT\r&quot;&#125;;</span><br><span class="line">expect &quot;password&quot; &#123;send &quot;$passwd\r&quot;&#125;;</span><br><span class="line"></span><br><span class="line">expect &quot;*$&quot; &#123;send exit\r&#125;;</span><br><span class="line">expect eof;</span><br></pre></td></tr></table></figure><h1 id="python程序"><a href="#python程序" class="headerlink" title="python程序"></a>python程序</h1><h2 id="Pexpect介绍"><a href="#Pexpect介绍" class="headerlink" title="Pexpect介绍"></a>Pexpect介绍</h2><p>Pexpect 是Expect 的一个 Python 实现，是一个用来启动子程序，并使用正则表达式对程序输出做出特定响应，以此实现与其自动交互的 Python 模块。 Pexpect 的使用范围很广，可以用来实现与 <code>ssh、ftp 、telnet</code>  等程序的自动交互；可以用来自动复制软件安装包并在不同机器自动安装；还可以用来实现软件测试中与命令行交互的自动化。</p><p>其依赖 <code>pty module</code> ，所以 <code>Pexpect</code> 还不能在 Windows 的标准 python 环境中执行，如果想在 Windows 平台使用，可以使用在 Windows 中运行 Cygwin 做为替代方案。</p><p><code>pexpect</code>主要包含两个接口，一个是<code>run()</code>函数，另一个是<code>spawn</code>类。<code>spawn</code>类的功能很强大，<code>run()</code>函数要更简单，更适用于快速调用程序。</p><ol><li><p><code>spawn class</code></p><p>使用这个类来开始和控制子程序。</p><ul><li><p><code>spawn</code>的构造函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class spawn:</span><br><span class="line">    def __init__(self,command,args=[],timeout=30,maxread=2000,\</span><br><span class="line">    searchwindowsize=None, logfile=None, cwd=None, env=None)</span><br></pre></td></tr></table></figure><p><code>spawn</code>是<code>Pexpect</code>模块主要的类，用以实现启动子程序，它有丰富的方法与子程序交互从而实现用户对子程序的控制。它主要使用 <code>pty.fork()</code> 生成子进程，并调用 <code>exec()</code> 系列函数执行 <code>command</code> 参数的内容。  使用示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">child = pexpect.spawn(&apos;/usr/bin/ftp&apos;)</span><br><span class="line">child = pexpect.spawn(&apos;/usr/bin/ssh user@example.com&apos;)</span><br></pre></td></tr></table></figure><p>由于需要实现不断匹配子程序输出， <code>searchwindowsize</code> 指定了从输入缓冲区中进行模式匹配的位置，默认从开始匹配。 </p></li><li><p>使用<code>pexpect</code>控制子程序</p><ul><li><p><code>expect()</code>定义</p><p><code>expect(self, pattern, timeout=-1, searchwindowsize=None)</code> </p><p>在参数中： <code>pattern</code> 可以是正则表达式， <code>pexpect.EOF</code> ， <code>pexpect.TIMEOUT</code>  ，或者由这些元素组成的列表。需要注意的是，当 <code>pattern</code>  的类型是一个列表时，且子程序输出结果中不止一个被匹配成功，则匹配返回的结果是缓冲区中最先出现的那个元素，或者是列表中最左边的元素。使用  <code>timeout</code> 可以指定等待结果的超时时间 ，该时间以秒为单位。当超过预订时间时， <code>expect</code> 匹配到<code>pexpect.TIMEOUT</code>。</p><p><code>expect</code> 不断从读入缓冲区中匹配目标正则表达式，当匹配结束时 <code>pexpect</code> 的 <code>before</code> 成员中保存了缓冲区中匹配成功处之前的内容， <code>pexpect</code> 的 <code>after</code> 成员保存的是缓冲区中与目标正则表达式相匹配的内容。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print child.before</span><br><span class="line">print child.after</span><br></pre></td></tr></table></figure></li><li><p><code>send</code>系列函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">send(self, s) </span><br><span class="line">sendline(self, s=&apos;&apos;) </span><br><span class="line">sendcontrol(self, char)</span><br></pre></td></tr></table></figure><p>这些方法用来向子程序发送命令，模拟输入命令的行为。 与 <code>send()</code> 不同的是 <code>sendline()</code> 会额外输入一个回车符 ，更加适合用来模拟对子程序进行输入命令的操作。 当需要模拟发送 <code>“Ctrl+c”</code> 的行为时，还可以使用 <code>sendcontrol()</code> 发送控制字符。 </p><p><code>child.sendcontrol(&#39;c&#39;)</code> </p><p>由于 <code>send()</code> 系列函数向子程序发送的命令会在终端显示，所以也会在子程序的输入缓冲区中出现，因此不建议使用 <code>expect</code> 匹配最近一次 <code>sendline()</code> 中包含的字符。否则可能会在造成不希望的匹配结果。 </p></li><li><p>interact()定义</p><p><code>interact(self, escape_character = chr(29), input_filter = None, output_filter = None)</code> </p><p>Pexpect还可以调用<code>interact()</code> 让出控制权，用户可以继续当前的会话控制子程序。用户可以敲入特定的退出字符跳出，其默认值为<code>“^]”</code> 。 </p></li></ul></li></ul></li><li><p><code>run() function</code></p><ul><li><p><code>run()</code>的定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">run(command,timeout=-1,withexitstatus=False,events=None,\</span><br><span class="line">    extra_args=None,logfile=None, cwd=None, env=None)</span><br></pre></td></tr></table></figure><p>函数 <code>run</code> 可以用来运行命令，其作用与 <code>Python os</code> 模块中 <code>system()</code> 函数相似。<code>run()</code> 是通过 <code>Pexpect spawn</code>类实现的。 </p></li><li><p>使用run()执行命令svn命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from pexpect import *</span><br><span class="line">run (&quot;svn ci -m &apos;automatic commit&apos; my_file.py&quot;)</span><br></pre></td></tr></table></figure><p>与 <code>os.system()</code> 不同的是，使用 <code>run()</code> 可以方便地同时获得命令的输出结果与命令的退出状态 。 </p></li><li><p>run()的返回值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from pexpect import *</span><br><span class="line">(command_output, exitstatus) = run (&apos;ls -l /bin&apos;, withexitstatus=1)</span><br></pre></td></tr></table></figure><p><code>command_out</code> 中保存的就是 /bin 目录下的内容。</p></li></ul></li></ol><p>更多关于pexpect的内容请看<a href="http://pexpect.readthedocs.io/en/stable/api/pexpect.html#run-function" target="_blank" rel="noopener">pexpect</a>.</p><ul><li><p>安装python pexpect模块</p><p><code>sudo pip install pexpect</code></p></li></ul><h2 id="程序编写"><a href="#程序编写" class="headerlink" title="程序编写"></a>程序编写</h2><p>还是一样的实现一个程序，其功能是ssh登录虚拟机，并在远程虚拟机用户目录下记录远程登录的日志文件，然后修改其<code>iptables</code>规则，禁止转发tcp 22号端口的报文。</p><p>完整程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import pexpect</span><br><span class="line"></span><br><span class="line">ip = &quot;192.168.1.75&quot;</span><br><span class="line">user = &quot;chl&quot;</span><br><span class="line">passwd = &quot;123456&quot;</span><br><span class="line">                                                                                                                                        </span><br><span class="line">ssh_newkey = &quot;Y|yes/no&quot;</span><br><span class="line">child = pexpect.spawn(&apos;ssh %s@%s&apos; % (user, ip))</span><br><span class="line">index = child.expect([pexpect.EOF, pexpect.TIMEOUT, ssh_newkey, &quot;password:&quot;])</span><br><span class="line">if index == 1:</span><br><span class="line">    print &quot;TimeoutError!&quot;</span><br><span class="line">if index == 2:</span><br><span class="line">    child.sendline(&quot;yes&quot;)</span><br><span class="line">    child.expect(&quot;password&quot;)</span><br><span class="line">    child.sendline(passwd)</span><br><span class="line">if index == 3:</span><br><span class="line">    child.sendline(passwd)</span><br><span class="line"></span><br><span class="line">child.expect(&quot;chl@&quot;)</span><br><span class="line">child.sendline(&quot;echo &apos;login +1&apos; &gt;&gt; ~/remote_login.log&quot;)</span><br><span class="line"></span><br><span class="line">child.expect(&quot;chl@&quot;)</span><br><span class="line">child.sendline(&quot;sudo iptables -A FORWARD -p tcp --dport 22 -j REJECT&quot;)</span><br><span class="line">child.expect(&quot;password&quot;)</span><br><span class="line">child.sendline(passwd)</span><br><span class="line"></span><br><span class="line">child.expect(&quot;chl@&quot;)</span><br><span class="line">child.sendline(&quot;exit&quot;)</span><br></pre></td></tr></table></figure><p><strong>注：</strong>需要注意的是python中正则表达式与Linux中的通配符是有区别的，不能直接用通配符来编写python正则表达式。</p><hr>]]></content>
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
            <tag> python </tag>
            
            <tag> Expect </tag>
            
            <tag> pexpect </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>远程免密码登录Openstack实例</title>
      <link href="/2018/07/07/%E8%BF%9C%E7%A8%8B%E5%85%8D%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95Openstack%E5%AE%9E%E4%BE%8B/"/>
      <url>/2018/07/07/%E8%BF%9C%E7%A8%8B%E5%85%8D%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95Openstack%E5%AE%9E%E4%BE%8B/</url>
      <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>一般情况下，可以通过<code>Openstack Dashboard</code>的控制台来访问用户创建的实例<code>Instance</code>，对于管理员来说，通过这种方法来访问会觉得很不方便，因为每次都需要打开浏览器来输入网址，每次点击都需要等待响应，登录到实例后控制台的响应也不是很及时且有卡顿。因此，本文介绍如何通过命名空间来实现免密码登录Openstack实例。</p><a id="more"></a><h1 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h1><p>在Linux中，网络命名空间可以被认为是隔离的拥有单独网络栈（网卡、路由转发表、iptables）的环境。网络命名空间经常用来隔离网络设备和服务，只有拥有同样网络命名空间的设备，才能看到彼此。openstack中就采用命名空间来实现不同网络的隔离。</p><ul><li><p>使用<code>ip netns</code>来查看已经存在的命名空间：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ip netns</span><br><span class="line">qrouter-e94975e8-4688-4858-8f64-86a18eea81ed</span><br><span class="line">qdhcp-34ba192f-ceea-4c86-addc-a5d14c6a34a8</span><br></pre></td></tr></table></figure><p><code>qdhcp</code>开头的名字空间是dhcp服务器使用的，<code>qrouter</code>开头的则是router服务使用的。 </p></li><li><p>查看openstack的网络：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ openstack network list</span><br><span class="line">+--------------------------------------+---------+--------------------------------------+</span><br><span class="line">| ID                                   | Name    | Subnets                              |</span><br><span class="line">+--------------------------------------+---------+--------------------------------------+</span><br><span class="line">| 34ba192f-ceea-4c86-addc-a5d14c6a34a8 | private | 74dbc6f4-ae59-4af5-b941-1f4d04918607 |</span><br><span class="line">| fc9b502a-d472-46f5-8570-b0d3915759cf | public  | de903618-fb31-412a-b46d-6ab593985b03 |</span><br><span class="line">+--------------------------------------+---------+--------------------------------------+</span><br></pre></td></tr></table></figure><p>可以看到<code>private</code>网络的dhcp服务器对应的命名空间<code>qdhcp-34ba192f-ceea-4c86-addc-a5d14c6a34a8</code>的名字中包含了<code>private</code>网络的ID。而本次测试的远程实例就是创建在private网络下的。</p></li><li><p>通过 <code>ip netns exec namespace_id command</code> 来在指定的网络名字空间中执行网络命令，记得加上<code>sudo</code>权限，例如 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ip netns exec qdhcp-34ba192f-ceea-4c86-addc-a5d14c6a34a8 ifconfig</span><br><span class="line">lo        Link encap:Local Loopback  </span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          inet6 addr: ::1/128 Scope:Host</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class="line">          RX packets:190 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:190 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1 </span><br><span class="line">          RX bytes:65824 (65.8 KB)  TX bytes:65824 (65.8 KB)</span><br><span class="line"></span><br><span class="line">tap4e2f68bb-84 Link encap:Ethernet  HWaddr fa:16:3e:32:19:6b  </span><br><span class="line">          inet addr:10.0.0.2  Bcast:10.0.0.63  Mask:255.255.255.192</span><br><span class="line">          inet6 addr: fe80::f816:3eff:fe32:196b/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1450  Metric:1</span><br><span class="line">          RX packets:110210 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:107493 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1 </span><br><span class="line">          RX bytes:21335986 (21.3 MB)  TX bytes:8426397 (8.4 MB)</span><br></pre></td></tr></table></figure></li><li><p>ssh远程登录实例：</p><p><code>sudo ip netns exec namespace_id ssh $username@ip</code></p><p>通过该命令来实现从控制节点通过ssh服务远程访问Openstack实例。</p></li></ul><h1 id="发送公共秘钥"><a href="#发送公共秘钥" class="headerlink" title="发送公共秘钥"></a>发送公共秘钥</h1><p>要实现免密码远程登录实例，首先需要将控制节点<code>root用户</code>的ssh的公共秘钥发送到远程实例，也就是<code>/root/.ssh/id_rsa.pub</code>文件中的内容，远程实例收到后会将公共密钥保存到登录用户的<code>.ssh/authorized_keys</code>文件中，这样下次登录远程实例时就不再需要密码。</p><ul><li><p>发送公共密钥：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ip netns exec qdhcp-34ba192f-ceea-4c86-addc-a5d14c6a34a8 ssh-copy-id -i /root/.ssh/id_rsa.pub openstack@10.0.0.9</span><br><span class="line"></span><br><span class="line">/usr/bin/ssh-copy-id: INFO: Source of key(s) to be installed: &quot;/root/.ssh/id_rsa.pub&quot;</span><br><span class="line">/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed</span><br><span class="line">/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys</span><br><span class="line">openstack@10.0.0.9&apos;s password: </span><br><span class="line"></span><br><span class="line">Number of key(s) added: 1</span><br><span class="line"></span><br><span class="line">Now try logging into the machine, with:   &quot;ssh &apos;openstack@10.0.0.9&apos;&quot;</span><br><span class="line">and check to make sure that only the key(s) you wanted were added.</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>发送的公共秘钥必须是控制节点<code>root</code>用户的，因为在进入命名空间执行命令时需要加上<code>sudo</code>权限，而<code>sudo</code>是用来以其他身份来执行命令的，预设的身份为<code>root</code>，这样在<code>ssh</code>登录远程实例时是以控制节点的<code>root</code>用户来登录远程实例的<code>openstack</code>用户，因此需要将控制节点<code>root</code>用户的公共密钥发送给远程实例，root用户的公共密钥的路径是<code>/root/.ssh/id_rsa.pub</code>。</p></li><li><p>查看远程实例的<code>authorized_keys</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ vi ~/.ssh/authorized_keys</span><br><span class="line">ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCjXQQUtIcLLcvBXVudZDBbQFK8BT/hB67oOrs792sfCuMhxvxvFRbma5UmnxwxOhXUIRjdz4u7tWhR3VVhqqnlHGDKOQVje/t2QtTlXXcBI3kGnc0Epem2NRMgRKp/h/Y1EOwtPNHRDVfr8C2znilXpWW1ueigHuJF4TWT7vEjgbApmWhopZcOXKbLkSu5dxLGUO3TzGqkASgpLG2XyuUJVqoREr5wbAZytq7R2p5KCxUZ6T7sDUQG+xmFPsfPg3MUHQmatTvtSf+mImotTkNSqOp2Itct9afX7SPkRncrXVWJ0qutbrRrkjRJm1l/sCjFBOD0x6txcFBX30nPvkDx root@controller</span><br></pre></td></tr></table></figure></li><li><p>查看控制节点<code>root</code>用户公共密钥：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># vi /root/.ssh/id_rsa.pub</span><br><span class="line">ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCjXQQUtIcLLcvBXVudZDBbQFK8BT/hB67oOrs792sfCuMhxvxvFRbma5UmnxwxOhXUIRjdz4u7tWhR3VVhqqnlHGDKOQVje/t2QtTlXXcBI3kGnc0Epem2NRMgRKp/h/Y1EOwtPNHRDVfr8C2znilXpWW1ueigHuJF4TWT7vEjgbApmWhopZcOXKbLkSu5dxLGUO3TzGqkASgpLG2XyuUJVqoREr5wbAZytq7R2p5KCxUZ6T7sDUQG+xmFPsfPg3MUHQmatTvtSf+mImotTkNSqOp2Itct9afX7SPkRncrXVWJ0qutbrRrkjRJm1l/sCjFBOD0x6txcFBX30nPvkDx root@controller</span><br></pre></td></tr></table></figure><p>可以看到，两者是一样的，说明控制节点的<code>root</code>用户已经被授权通过公共密钥来访问远程实例。</p></li></ul><h1 id="免密码登录"><a href="#免密码登录" class="headerlink" title="免密码登录"></a>免密码登录</h1><ul><li><p>免密码登录远程实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ip netns exec qdhcp-34ba192f-ceea-4c86-addc-a5d14c6a34a8 ssh openstack@10.0.0.9</span><br></pre></td></tr></table></figure><p>这样就通过<code>ssh</code>服务免密码远程登录<code>Openstack</code>实例，而不需要通过<code>Dashboard</code>的控制台来登录实例。</p></li></ul><hr>]]></content>
      
      <categories>
          
          <category> Openstack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Openstack </tag>
            
            <tag> Namespace </tag>
            
            <tag> SSH </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>NAT网关设计</title>
      <link href="/2018/05/21/NAT%E7%BD%91%E5%85%B3%E8%AE%BE%E8%AE%A1/"/>
      <url>/2018/05/21/NAT%E7%BD%91%E5%85%B3%E8%AE%BE%E8%AE%A1/</url>
      <content type="html"><![CDATA[<h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><p>本文的目的是将<code>Linux</code>配置成<code>NAT</code>网关，具备<code>NAT、DHCP、DNS</code>功能，实现内网访问外网的通信、实现外网对特定主机的访问、实现内网主机的IP地址动态分配以及域名解析的功能。</p><a id="more"></a><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><h2 id="实验环境介绍："><a href="#实验环境介绍：" class="headerlink" title="实验环境介绍："></a>实验环境介绍：</h2><ul><li><p>一台搭建了<code>KVM</code>环境的物理服务器，命名为<code>Server</code>，并在该服务器上创建两台虚拟机<code>VM</code>；</p></li><li><p>第一台虚拟机用作<strong>NAT网关</strong>，命名为<code>Gateway</code>，分配两张网卡，<code>eth0</code>连接内网，<code>eth1</code>连接外网；</p></li><li><p>第二台虚拟机作为<strong>内网主机</strong>，命名为<code>Host</code>，分配一张网卡<code>eth0</code>连接内网。</p></li><li><p>内网网段为：<code>10.0.0.0/24</code></p></li><li><p>外网网段为：<code>192.168.1.0/24</code></p><p><strong>注：</strong>本实验其实也可以在<code>VMware workstation</code>或者<code>virtualBox</code>环境下进行，但是由于博主的电脑配置不高，不想在个人电脑上搭建该环境，且身边的服务器刚好有空闲的资源，所以就在服务器上搭建了该环境，至于如何在服务器上搭建<code>KVM</code>环境可以参照我的另一篇博客的部分内容 <a href="https://cao0507.github.io/2017/12/03/KVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%83%A8%E7%BD%B2openstack%E7%9A%84%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/">快速链接</a>。</p></li></ul><h2 id="搭建实验环境："><a href="#搭建实验环境：" class="headerlink" title="搭建实验环境："></a>搭建实验环境：</h2><ul><li><p>创建内部网桥：服务器<code>Server</code>上创建一个虚拟网桥br-int，作为连接内网的交换机。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sudo brctl addbr br-int</span><br><span class="line"></span><br><span class="line">$ brctl show</span><br><span class="line">bridge namebridge idSTP enabledinterfaces</span><br><span class="line">br-int8000.000000000000no</span><br><span class="line"></span><br><span class="line">$ sudo ifconfig br-int up</span><br></pre></td></tr></table></figure><p><strong>注：</strong>在<code>VMware workstation</code>中搭建环境时需要在<strong>虚拟网络编辑器</strong>中将<strong>使用本地DHCP服务将IP分配给虚拟机</strong>选项取消勾选，因为我们需要实现NAT网关来给虚拟机分配IP。另外在创建虚拟网桥后一定要开启该网桥。</p></li><li><p>创建<strong>NAT网关</strong>虚拟机</p><p>其网络配置信息如下：</p><ul><li><p>eth0</p><p><img src="https://raw.githubusercontent.com/cao0507/My-Pictures-Repository/master/blog/Gateway_VM_nic0.png" alt="Gateway_NIC0"></p></li><li><p>eth1</p><p><img src="https://raw.githubusercontent.com/cao0507/My-Pictures-Repository/master/blog/Gateway_VM_nic1.png" alt="Gateway_NIC1">通过<code>ifconfig</code>查看网络信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ ifconfig</span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 52:54:00:1c:83:53  </span><br><span class="line">          inet6 addr: fe80::5054:ff:fe1c:8353/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          ...</span><br><span class="line"></span><br><span class="line">eth1      Link encap:Ethernet  HWaddr 52:54:00:de:e8:51  </span><br><span class="line">          inet addr:192.168.1.123  Bcast:192.168.1.255  Mask:255.255.255.0</span><br><span class="line">          inet6 addr: fe80::5054:ff:fede:e851/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          ...</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback  </span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          inet6 addr: ::1/128 Scope:Host</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class="line">          ...</span><br></pre></td></tr></table></figure><p>可见NAT网关的<code>eth0</code>网卡因为没有DHCP服务器所以没有分配到IP，但外网网卡<code>eth1</code>已经有一个外网IP。</p></li></ul></li><li><p>创建<strong>内部主机</strong>虚拟机</p><p>其网络配置信息如下：</p><ul><li><p>eth0</p><p><img src="https://raw.githubusercontent.com/cao0507/My-Pictures-Repository/master/blog/Host_VM_nic.png" alt="Host_NIC0">通过<code>ifconfig</code>查看网络信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ ifconfig</span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 52:54:00:1a:a1:78  </span><br><span class="line">          inet6 addr: fe80::5054:ff:fe1a:a178/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          ...</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback  </span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          inet6 addr: ::1/128 Scope:Host</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class="line">          ...</span><br></pre></td></tr></table></figure><p>可见其内网网卡<code>eth0</code>没有分配IP。</p><p>其实，在启动这两个虚拟机时，因为内部网络没有DHCP服务器，他们的内网网卡会一直等待DHCP服务器给它们分配IP，等待的时间大概是5分钟，最终还是没有获得IP。</p></li></ul></li><li><p>修改两个虚拟机的网络配置文件</p><ul><li><p><strong>NAT网关</strong>：<code>$ sudo vi /etc/network/interfaces</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">source /etc/network/interfaces.d/*</span><br><span class="line"></span><br><span class="line"># The loopback network interface</span><br><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line"></span><br><span class="line"># The primary network interface</span><br><span class="line">auto eth0</span><br><span class="line">iface eth0 inet static</span><br><span class="line">address 10.0.0.1</span><br><span class="line">netmask 255.255.255.0</span><br><span class="line">gateway 10.0.0.1</span><br><span class="line"></span><br><span class="line">auto eth1</span><br><span class="line">iface eth1 inet dhcp</span><br></pre></td></tr></table></figure><p>因为NAT网关的<code>eth0</code>将做内网的网关，故将其IP设置为静态IP：<code>10.0.0.1</code>，这样更容易识别，且不会因为重启而改变。</p></li><li><p><strong>内部主机</strong>：<code>$ sudo vi /etc/network/interfaces</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">source /etc/network/interfaces.d/*</span><br><span class="line"></span><br><span class="line"># The loopback network interface</span><br><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line"></span><br><span class="line"># The primary network interface</span><br><span class="line">auto eth0</span><br><span class="line">iface eth0 inet dhcp</span><br></pre></td></tr></table></figure></li></ul></li><li><p>在服务器Server上查看虚拟网桥的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ brctl show br-int</span><br><span class="line">bridge namebridge idSTP enabledinterfaces</span><br><span class="line">br-int8000.fe54001aa178novnet1</span><br><span class="line">           vnet3</span><br></pre></td></tr></table></figure><p>可以看到虚拟网桥<code>br-int</code>上面已经有两个网络接口，对应两个虚拟机的内部网卡。</p></li></ul><h1 id="NAT-功能实现"><a href="#NAT-功能实现" class="headerlink" title="NAT 功能实现"></a>NAT 功能实现</h1><p>NAT网关的功能是通过Linux中自带的iptables来实现，NAT功能包括SNAT和DNAT。SNAT是源地址转换，在内网主机访问外网时发挥作用，可以将内网主机的ip地址转换为网关的ip地址。DNAT是目的地址转换，在外网的主机通过NAT网关的ip和端口对内网主机发起访问时发挥作用，可以将NAT网关的ip地址与端口转换为对应内网主机的ip，从而实现从外网对内网中某一特定主机的访问。当然要将Linux虚拟机配置成NAT网关，首先得要开启Linux虚拟机的网络转发功能。下面将介绍NAT功能的实现过程：</p><ol><li><p>开启网络转发功能</p><ul><li><p>临时开启网络转发功能，需要切换到<code>root</code>用户，命令如下：</p><p><code># echo 1 &gt; /proc/sys/net/ipv4/ip_forward</code></p><p>这样在下次虚拟机重启后该功能会自动关闭，因此可以修改配置文件的方式来开启该功能并永久生效。</p></li><li><p>永久开启网络转发功能：</p><p><code># vi /etc/sysctl.conf</code></p><p>在文件里面添加一行<code>net.ipv4.ip_foward=1</code>，在下次重启之后就不会还原了。</p></li></ul></li><li><p>SNAT的实现</p><p>在<code>iptables</code>的<code>nat表</code>的<code>POSTROUTING规则链</code>中添加规则，使得从<code>10.0.0.0/24</code>网络发到NAT网关的数据包，从<code>eth1</code>转发出去，并将数据包的源ip地址修改为NAT网关的外网地址，命令如下 ：</p><p><code>sudo iptables -t nat -A POSTROUTING -s 10.0.0.0/24 -o eth1 -j SNAT --to-source 192.168.1.123</code></p><p><code>192.168.1.123</code>是NAT网关的外网网卡<code>eth1</code>的IP。</p></li><li><p>DNAT的实现</p><p>在<code>iptables</code>的<code>nat表</code>的<code>PREROUTING规则链</code>中添加规则，使得从外网发往NAT网关固定端口（如：8080）的<code>TCP</code>（这里也可以添加其他网络协议）数据包转发到内网的某固定主机上，命令如下：</p><p><code>sudo iptables -t nat -A PREROUTING -i eth1 -d 192.168.1.67 -p tcp --dport 8080 -j DNAT --to-destination 10.0.0.107:22</code></p><p><code>10.0.0.107</code>是内网某主机的IP，<strong>这里说明一下</strong>：实际实现的过程中，最好先实现DHCP与DNS的功能。</p></li><li><p>保存<code>iptables</code>规则</p><p><code>sudo iptables-save | sudo tee /etc/iptables.sav</code></p></li><li><p>编辑<code>/etc/rc.local</code>文件，将下面的一行添加到<code>&quot;exit 0&quot;</code>之前：</p><p><code>iptables-restore &lt; /etc/iptables.sav</code></p><p>这样每次重启机器时都会自动加载NAT相关的<code>iptables</code>规则。</p></li></ol><h1 id="DHCP与DNS功能实现"><a href="#DHCP与DNS功能实现" class="headerlink" title="DHCP与DNS功能实现"></a>DHCP与DNS功能实现</h1><p>实现DHCP服务器可以使用<code>isc-dhcp-server</code>工具包，实现DNS服务器可以使用<code>bind9</code>工具包，但是本实验考虑使用<code>DNSmasq</code>工具来同时实现DHCP服务器与DNS服务器的功能。<code>DNSmasq</code>是一个小巧且方便地用于配置DHCP和DNS的工具，适用于小型网络。作为域名解析服务器（DNS），<code>DNSmasq</code>可以通过缓存DNS请求来提高对访问过的网址的连接速度。作为DHCP服务器，<code>DNSmasq</code>可以用于为局域网电脑分配内网ip地址和提供路由。</p><ul><li><p>安装DNSmasq工具：</p><p><code>$ sudo apt-get install dnsmasq</code></p></li><li><p>编辑<code>DNSmasq</code>的配置文件<code>/etc/dnsmasq.conf</code>，添加下面两行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">interface=eth0</span><br><span class="line">dhcp-range=10.0.0.100,10.0.0.200,72h</span><br></pre></td></tr></table></figure><p>其中<code>interface</code>是用作内网网关的网卡，也就是NAT网关的<code>eth0</code>网卡；<code>dhcp-range</code>是动态分配的IP地址池；<code>72h</code>表示分配的IP的有效时间是72个小时，到时间后需要重新分配IP。</p></li><li><p>重启<code>DNSmasq</code>服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo /etc/init.d/dnsmasq restart</span><br><span class="line">[ ok ] Restarting dnsmasq (via systemctl): dnsmasq.service.</span><br></pre></td></tr></table></figure><p>到这里就配置内容就完成了。然后需要重启这两个虚拟机。</p></li></ul><h1 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h1><ul><li><p>DHCP服务</p><p>在完成DHCP服务器配置重启虚拟机后，会发现在启动过程中不再需要等待5分钟来获取IP了，进入<strong>内部主机</strong>查看网络信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ ifconfig</span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 52:54:00:1a:a1:78 </span><br><span class="line">          inet addr:10.0.0.176  Bcast:10.0.0.255  Mask:255.255.255.0</span><br><span class="line">          inet6 addr: fe80::5054:ff:fe1a:a178/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:17 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:21 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:36 txqueuelen:1000 </span><br><span class="line">          RX bytes:1642 (1.6 KB)  TX bytes:2182 (2.1 KB)</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback  </span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          inet6 addr: ::1/128 Scope:Host</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class="line">          RX packets:164 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:164 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1 </span><br><span class="line">          RX bytes:12200 (12.2 KB)  TX bytes:12200 (12.2 KB)</span><br></pre></td></tr></table></figure><p>可以看到eth0分配到了一个在DHCP地址池内的一个IP：<code>10.0.0.176</code>。</p></li><li><p>DNS与NAT服务</p><p>这里将同时对DNS服务与NAT服务进行测试</p><ul><li><p>内网到外网</p><p>由于我所在的网络所有的<code>ping</code>外网的报文都会被拦截，所以没有办法通过<code>ping</code>来测试网络的连通性，这里采用<code>wget</code>命令在内部主机测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ wget http://www.baidu.com</span><br><span class="line">--2018-07-08 16:30:37--  http://www.baidu.com/</span><br><span class="line">Resolving www.baidu.com (www.baidu.com)... 180.97.33.108, 180.97.33.107</span><br><span class="line">Connecting to www.baidu.com (www.baidu.com)|180.97.33.108|:80... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: 2381 (2.3K) [text/html]</span><br><span class="line">Saving to: ‘index.html’</span><br><span class="line"></span><br><span class="line">index.html               100%[================================&gt;]   2.33K  --.-KB/s    in 0s      </span><br><span class="line"></span><br><span class="line">2018-07-08 16:30:37 (61.1 MB/s) - ‘index.html’ saved [2381/2381]</span><br></pre></td></tr></table></figure><p>上面的测试说明内网主机到外网的连通性，并且也实现了域名解析的功能。</p></li><li><p>外网到内网</p><p>在博主的个人Windows电脑上去访问内网主机，以此来测试外网到内网的连通性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[c:\~]$ ssh openstack-image@192.168.1.152 8080</span><br><span class="line"></span><br><span class="line">Connecting to 192.168.1.152:8080...</span><br><span class="line">Connection established.</span><br><span class="line">To escape to local shell, press &apos;Ctrl+Alt+]&apos;.</span><br><span class="line"></span><br><span class="line">Welcome to Ubuntu 16.04.3 LTS (GNU/Linux 4.4.0-87-generic x86_64)</span><br><span class="line"></span><br><span class="line"> * Documentation:  https://help.ubuntu.com</span><br><span class="line"> * Management:     https://landscape.canonical.com</span><br><span class="line"> * Support:        https://ubuntu.com/advantage</span><br><span class="line"></span><br><span class="line">134 packages can be updated.</span><br><span class="line">55 updates are security updates.</span><br><span class="line"></span><br><span class="line">Last login: Sun Jul  8 16:13:54 2018</span><br><span class="line">openstack-image@ubuntu:~$ ifconfig</span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 52:54:00:d0:51:38  </span><br><span class="line">          inet addr:10.0.0.176  Bcast:10.0.0.255  Mask:255.255.255.0</span><br><span class="line">          inet6 addr: fe80::5054:ff:fed0:5138/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:96 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:125 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:516 txqueuelen:1000 </span><br><span class="line">          RX bytes:17842 (17.8 KB)  TX bytes:15515 (15.5 KB)</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback  </span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          inet6 addr: ::1/128 Scope:Host</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class="line">          RX packets:176 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:176 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1 </span><br><span class="line">          RX bytes:13392 (13.3 KB)  TX bytes:13392 (13.3 KB)</span><br></pre></td></tr></table></figure><p>可以访问，外网到内网也是连通的。到此，需要实现的功能都已经实现了。</p></li></ul></li></ul><hr>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> NAT </tag>
            
            <tag> DHCP </tag>
            
            <tag> DNS </tag>
            
            <tag> iptables </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>虚拟化技术与云计算平台报告</title>
      <link href="/2018/03/22/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E4%B8%8E%E4%BA%91%E8%AE%A1%E7%AE%97%E5%B9%B3%E5%8F%B0%E6%8A%A5%E5%91%8A/"/>
      <url>/2018/03/22/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E4%B8%8E%E4%BA%91%E8%AE%A1%E7%AE%97%E5%B9%B3%E5%8F%B0%E6%8A%A5%E5%91%8A/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从2006年谷歌首次提出“云计算”的概念到现在，云计算已经经历的十多年的发展，有众多厂商、组织和学者投入其中。一些云服务厂商有自己的云计算平台，但只是为客户提供云服务，外部开发者无法对这些厂商的云平台进行开发。另外也有一些组织机构或厂商开发的云计算平台是开源的，吸引大量开发者在这些开源平台上开展自己的工作。</p><a id="more"></a><p>目前，主流的开源云计算平台有很多种，本问将对这些平台进行调研以选择最适合于自己需求的平台。另外，虚拟化技术又是云计算的核心支撑技术，是将各种计算及存储资源充分整合和高效利用的关键技术，当前虚拟化技术也是多种多样，并且开源云计算平台往往又支持多种底层的虚拟化技术，因此也有必要对虚拟化技术进行调研，以选择最适合云平台和上层应用的虚拟化技术。综上，本报告的主要目标就是对多种虚拟化技术和多种开源云计算平台进行对比，以选出最满足需求的技术与平台。</p><p>本文将首先简单对比虚拟化与云计算。其后，由于虚拟化技术是云计算的基础，本报告将先对虚拟化技术展开论述，然后再对云计算平台进行论述。</p><h1 id="虚拟化与云计算"><a href="#虚拟化与云计算" class="headerlink" title="虚拟化与云计算"></a>虚拟化与云计算</h1><p>借助虚拟化技术，用户可以单个物理硬件系统为基础创建多个模拟环境或专用资源。并使用一款名为“Hypervisor”(虚拟机监控程序)的软件直接连接到硬件，从而将一个系统划分为不同的、单独安全环境，即虚拟机 (VM)。Hypervisor 能够将计算机资源与硬件分离并适当分配资源，而虚拟机则依赖这些功能运行。</p><p>云计算则由多种规则和方法组合而成，可以跨任何网络向用户按需提供计算、网络和存储基础架构资源、服务、平台和应用。这些基础架构资源、服务和应用来源于云。 简单来讲，云就是一系列管理及自动化软件编排而成的虚拟资源池，旨在帮助用户通过支持自动扩展和动态资源分配的自助服务门户，按需对这些资源进行访问。</p><p>下面对虚拟化与云计算做一个简单的对比：</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">虚拟化</th><th style="text-align:center">云</th></tr></thead><tbody><tr><td style="text-align:center">定义</td><td style="text-align:center">技术</td><td style="text-align:center">方法论</td></tr><tr><td style="text-align:center">目的</td><td style="text-align:center">从一个物理硬件系统创建多个虚拟环境</td><td style="text-align:center">汇聚并自动化分配虚拟资源以供按需使用</td></tr><tr><td style="text-align:center">用途</td><td style="text-align:center">针对具体用途为特定用户提供打包资源</td><td style="text-align:center">针对多种用途为用户群组提供不同资源</td></tr><tr><td style="text-align:center">使用寿命</td><td style="text-align:center">数年（长期）</td><td style="text-align:center">数小时至数月</td></tr><tr><td style="text-align:center">成本</td><td style="text-align:center">资本支出（CAPEX）高<br>运营支出（OPEX）低</td><td style="text-align:center">共有云：CAPEX高、OPEX低<br>私有云：CAPEX低、OPEX高</td></tr><tr><td style="text-align:center">可扩展性</td><td style="text-align:center">纵向扩展</td><td style="text-align:center">横向扩展</td></tr><tr><td style="text-align:center">工作负载</td><td style="text-align:center">有状态</td><td style="text-align:center">无状态</td></tr><tr><td style="text-align:center">租赁</td><td style="text-align:center">单一租户</td><td style="text-align:center">多个租户</td></tr></tbody></table><h1 id="虚拟化技术"><a href="#虚拟化技术" class="headerlink" title="虚拟化技术"></a>虚拟化技术</h1><p>按照虚拟化的对象分类，虚拟化可分为服务器虚拟化、操作系统虚拟化、存储虚拟化、网络虚拟化等。其中服务器虚拟化对CPU、内存、设备与I/O这三种硬件资源的虚拟化技术已经相当成熟，但对GPU的虚拟化却还有很大的提升空间。下面将分别介绍服务器虚拟化中CPU虚拟化及GPU虚拟化相关的技术，然后对现在主流的虚拟化平台做一些比较。</p><h2 id="一、CPU虚拟化"><a href="#一、CPU虚拟化" class="headerlink" title="一、CPU虚拟化"></a>一、CPU虚拟化</h2><p>目前，为了解决x86体系结构下的CPU虚拟化问题，业界提出了全虚拟化和半虚拟化两种不同的软件方案。除了通过软件的方式实现CPU虚拟化外，业界还提出了在硬件层添加支持功能的硬件辅助虚拟化方案来处理那些敏感的高级别指令。</p><p>全虚拟化在宿主机底层物理硬件与VM之间增加一个软件层，即虚拟机监控器（VMM或hypervisor），此时，VMM充当主机操作系统，用来管理不同的虚拟机，如图1所示。它隐藏了特定计算平台的实际物理特性，为用户提供抽象的、统一的、模拟的计算环境（称为虚拟机）。在VMM平台上，可以模拟出多套虚拟机，实现了在单机上运行多个不同类型操作系统的虚拟机。全虚拟化的优点是不需要修改客户机操作系统，因此支持多种操作系统，缺点是VMM层工作负荷较大，并占用一定的宿主机资源，性能不如裸机。主要代表有VMware vSphere，Microsoft公司的Virtual PC、Redhat公司的RED HAT ENTERPRISE VIRTUALIZATION等。 </p><p><img src="https://raw.githubusercontent.com/cao0507/Pictures/master/blog/%E5%85%A8%E8%99%9A%E6%8B%9F%E5%8C%96%E6%9E%B6%E6%9E%84.png" alt="全虚拟化架构"></p><p>半虚拟化与全虚拟化类似，不同之处是需要修改客户机操作系统的核心代码，即增加一个专门的虚拟化应用程序接口，优化客户操作系统发出的指令，与VMM能够协同工作，以减轻VMM和宿主机的负担，进一步提升了虚拟机的性能，如图2所示。缺点是需要修改客户操作系统，影响了技术的普及。主要代表有使用开源虚拟化技术的Citrix的Xenserver、Microsoft的Hyper-V 。</p><p><img src="https://raw.githubusercontent.com/cao0507/Pictures/master/blog/%E5%8D%8A%E8%99%9A%E6%8B%9F%E5%8C%96%E6%9E%B6%E6%9E%84.png" alt="半虚拟化架构"></p><p>为了更好地实现全、半虚拟化技术，Intel与AMD对传统X86架构进行改进，分别设计了Intel-VT和AMD-V CPU硬件辅助虚拟化技术。将原来的特权等级Ring 0、1、2、3 定义为Non-Root mode，新增了一个Root mode 特权等级（或称为Ring -1），这种情况下，OS 即可运行在原来Ring0 的等级，而VMM 则调整到更底层的Root Mode 等级，其架构如图3。硬件辅助虚拟化有效地解决了虚拟机效率低的问题，它使虚拟机可以运行ring 0 的指令，不用再进行操作系统的ring 切换，提高了虚拟机的整体效率。 现在主流的半、全虚拟化产品都支持硬件辅助虚拟化，代表有Oracle公司的VirtualBox、RHEV、VMware vSphere和Xneserver。</p><p><img src="https://raw.githubusercontent.com/cao0507/Pictures/master/blog/%E7%A1%AC%E4%BB%B6%E8%BE%85%E5%8A%A9%E8%99%9A%E6%8B%9F%E5%8C%96%E6%9E%B6%E6%9E%84.png" alt="硬件辅助虚拟化"></p><h2 id="二、GPU虚拟化"><a href="#二、GPU虚拟化" class="headerlink" title="二、GPU虚拟化"></a>二、GPU虚拟化</h2><p>GPU虚拟化相关技术还垄断在少数厂商手中，并没有像CPU、内存、存储一样在开源社区推广普及。下面将介绍三大显卡厂商GPU虚拟化的发展。</p><p>NVIDIA，早在2013年，NVIDIA就推出了行业内第一款GPU虚拟化显卡GRID K1/K2，同期联合Citrix推出了商用的vGPU虚拟桌面解决方案，这比AMD提前了近3年。GPU虚拟化技术的出现，给一直被诟病性能不足的桌面虚拟化带来了转机。在2016年，NVIDIA推出第二款GPU虚拟化显卡，Maxwell架构的Tesla M6/M10/M60，新版的GRID将使用授权分为 3 个不同版本，依据版本不同收取额外软件授权使用费。 在2017年8月份NVIDIA推出了最新版GRID 5.0，虚拟化显卡新增Pascal架构的Tesla P4/P6/P40/P100，其中Quadro Virtual Datacenter Workstation版的授权支持vGPU在图形渲染模式和高性能计算模式之间切换，这是硬件厂商首次在vGPU层面将图形渲染和高性能计算进行了统一，又一次引领了行业趋势和市场需求。NVIDIA的虚拟化显卡只是硬件，还需要相应的服务器虚拟化系统的支持，这和Intel的CPU需要操作系统Windows和Linux来配合一样。现在只有Xen和ESXi能够支持GRID virtual GPU solution，被大量第三方厂商采用的KVM虚拟化平台还没有出现在GRID的支持列表中，因此可以说GPU另外一只脚还没能踏进云计算时代。2017年7月份NVIDIA和Nutanix宣布将合作在年底推出AHV版本的GRID，这算是KVM虚拟化走出了第 一步。在解决GPU虚拟化后，如何将虚拟机的画面传送到客户端，这是KVM虚拟化可以商用的第二步。KVM上默认配置的Spice协议对3D的支持并不好，Nutanix以及其他KVM方案解决商还需自行开发出可用的桌面传输协议，这才算是彻底完成了GRID在KVM上的应用。</p><p>AMD，AMD在NVIDIA推出GRID K1/K2 的两年半后才推出了自己的GPU虚拟化产品MxGPU，算是姗姗来迟。共有三款FirePro S系列的GPU支持MxGPU，一块GPU最多可以支持 32 个用户。当MxGPU上的虚拟机比较少时，能够达到图形工作站的性能。随着虚拟机数量增多，每个虚拟机获得的GPU性能逐步降低。有别于NVIDIA GRID通过软件实现的显卡虚拟化方式，AMD MxGPU是“全球首款基于硬件的虚拟化GPU解决方案”。MxGPU每个虚拟机能分得一定数量的独享流处理器和显存空间，这样可以避免不同虚拟机对GPU资源的抢夺，造成用户噪音。这种噪音问题直到今年8月底推出NVIDIA GRID 5. 0 才得到解决。MxGPU在定价上采用的是更符合买方逻辑的营销方法，只向用户收取需付硬件的购买费用。不过遗憾的是，目前只有VMware的ESXi支持MxGPU，Xen暂时只有技术验证版。没能同时支持两种主流化的虚拟化系统，一定程度上阻碍了MxGPU在市场的普及速度。Citrix的用户还是可以用过vSphere+XenDesktop的方案用上MxGPU，相比使用免费的XenServer，要多支付vSphere的费用。</p><p>Intel，Intel官方将不同的Intel GPU虚拟化技术分别命名为Intel GVT-s，Intel GVT-d和Intel GVT-g，分布对应API转发，直通，完全虚拟化。Intel GVT-g和NVIDIA vGPU类似，支持Xen/KVM平台，每个GPU最多能分享给7个用户同时使用。其中XenGT在 2016 年最早实现了业界的vGPU在线迁移，NVIDIA GRID直到这个季度才和Citrix合作完成了vGPU在线迁移。 2016 年的 2017 年2月份，Linux 4.10中加入Intel GVT-g for KVM。这是三大GPU厂商中，第一个支持KVM平台的完全虚拟化方案，意味着第三方采用KVM的云计算厂商终于有了一个可用的vGPU方案。不过Intel GPU虚拟化，由于核显性能的原因，只能满足图像密集型的用户体验，不能像GRID vGPU和MxGPU一样满足图形渲染的重度使用场景。Intel GPU虽然支持了大多数虚拟化桌面厂商使用的Xen/KVM两大类服务器虚拟化系统，可是硬件却和VDI高密度的使用场景不太搭。首先Intel的完全虚拟化只支持Broadwell架构以后的核芯显卡，作为VDI服务器中常用的Xeon E5/E7 v4 系列，以及第 一个的Xeon Scalable处理器，都没有核芯显卡。这在很大程度上限定了Intel GPU虚拟化在VDI的使用规模，有种落入有枪无弹的尴尬境地。</p><h2 id="三、虚拟化平台比较"><a href="#三、虚拟化平台比较" class="headerlink" title="三、虚拟化平台比较"></a>三、虚拟化平台比较</h2><p>服务器虚拟化技术日益成熟，并具有广泛的应用前景，目前有很多厂商进行虚拟化技术产品的开发和生产，包括：VMware、Microsoft、Citrix、IBM和RedHat等，其各自产品都有不同的特点，产品功能日益强大。下面将比较一下四种主流服务器虚拟化平台，如下表 ：</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">VMware</th><th style="text-align:center">Xen</th><th style="text-align:center">KVM</th><th style="text-align:center">Hyper-V</th></tr></thead><tbody><tr><td style="text-align:center">厂商</td><td style="text-align:center">VMware</td><td style="text-align:center">Citrix</td><td style="text-align:center">Red Hat</td><td style="text-align:center">Microsoft</td></tr><tr><td style="text-align:center">是否免费</td><td style="text-align:center">付费</td><td style="text-align:center">开源免费</td><td style="text-align:center">开源免费</td><td style="text-align:center">付费</td></tr><tr><td style="text-align:center">宿主机系统</td><td style="text-align:center">Windows<br>Linux</td><td style="text-align:center">NetBSD<br>Linux<br>Solaris</td><td style="text-align:center">Linux</td><td style="text-align:center">Windows server 2008及以上系统</td></tr><tr><td style="text-align:center">客户机系统</td><td style="text-align:center">Windows 2003、Windows 2008、RedHat、Debian、Ubuntu、Centos</td><td style="text-align:center">Xen-PV：纯Linux；Xen-HVM：支持Windows、Linux</td><td style="text-align:center">Linux、Windows</td><td style="text-align:center">Windows系列、Linux</td></tr><tr><td style="text-align:center">支持技术</td><td style="text-align:center">硬件辅助虚拟化（全虚拟化）</td><td style="text-align:center">硬件辅助虚拟化（HVM全虚拟化、PV半虚拟化）</td><td style="text-align:center">硬件辅助虚拟化（全虚拟化）</td><td style="text-align:center">硬件辅助虚拟化（半虚拟化）</td></tr><tr><td style="text-align:center">支持的vGPU产品</td><td style="text-align:center">NVIDIA GRID<br>AMD MxGPU</td><td style="text-align:center">NVIDIA GRID<br>AMD MxGPU（技术验证版）</td><td style="text-align:center">Intel GVT-g for KVM</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">优点</td><td style="text-align:center">相对成熟的商业软件，市场占有率较大</td><td style="text-align:center">性能较好，支持半虚拟化</td><td style="text-align:center">是内核本身的一部分，因此可以利用内核的优化和改进；高性能，稳定，无需修改客户机系统</td><td style="text-align:center">对Windows的支持较好</td></tr><tr><td style="text-align:center">缺点</td><td style="text-align:center">不开源，费用较高</td><td style="text-align:center">操作复杂，维护成本较高，目前已被RedHat抛弃</td><td style="text-align:center">虚拟机性能比Xen略低</td><td style="text-align:center">对Linux的支持较差，性能损失大</td></tr></tbody></table><p>开源云计算平台Openstack对这四种虚拟化平台都有支持，默认使用的是KVM，Openstack与KVM结合的方案也已经相当成熟。另外，考虑到KVM是开源免费的虚拟化技术；宿主机系统支持绝大多数Linux系统，对于使用Linux系统的服务器都有很好的支持；而客户机操作系统不仅支持Linux，还支持Windows，可以满足绝大多数用户的需求，因此选择KVM作为Openstack底层的虚拟化技术的理由是很充分的。不过，KVM对于虚拟GPU的支持不是很好，只有Intel GVT-g for KVM可以支持KVM平台的全虚拟化方案，但是Intel GPU虚拟化由于核显性能的原因，只能满足图像密集型的用户体验，不能满足图形渲染等重度使用的场景。</p><h1 id="云计算平台"><a href="#云计算平台" class="headerlink" title="云计算平台"></a>云计算平台</h1><p>目前已经有多个云计算平台的开源实现，主要的开源云计算项目有Openstack、Eucalyptus、CloudStack和OpenNebula等，现比较如下：</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">Openstack</th><th style="text-align:center">Eucalyptus</th><th style="text-align:center">CloudStack</th><th style="text-align:center">OpenNebula</th></tr></thead><tbody><tr><td style="text-align:center">发布时间</td><td style="text-align:center">2010年7月</td><td style="text-align:center">2008年5月</td><td style="text-align:center">2010年5月</td><td style="text-align:center">2008年7月</td></tr><tr><td style="text-align:center">最新版本</td><td style="text-align:center">Queens</td><td style="text-align:center">4.4</td><td style="text-align:center">4.11</td><td style="text-align:center">5.4</td></tr><tr><td style="text-align:center">授权协议</td><td style="text-align:center">Apache v2.0</td><td style="text-align:center">GPL v3.0</td><td style="text-align:center">Apache v2.0</td><td style="text-align:center">Apache v2.0</td></tr><tr><td style="text-align:center">基本架构</td><td style="text-align:center">Nova、Glance、Neutron、Keystone、Horizon、swift、Tacker等</td><td style="text-align:center">Cloud Controller、Cluster Controller、Node Controller、Walrus、 Storage Controller</td><td style="text-align:center">主要包括管理服务、云基础设施和网络三大部分</td><td style="text-align:center">主要包括接口与API、用户与组、主机、网络、存储、集群6个部分</td></tr><tr><td style="text-align:center">虚拟化技术支持</td><td style="text-align:center">KVM、LXC、QEMU、UML、Vmware ESX/ESXi、Xen、Hyper-V</td><td style="text-align:center">Xen、KVM、ESXi</td><td style="text-align:center">KVM、Xen、ESXi、OVM、Baremetal</td><td style="text-align:center">Xen、KVM、Vmware</td></tr><tr><td style="text-align:center">用户界面</td><td style="text-align:center">Dashboard，较简单</td><td style="text-align:center">web界面</td><td style="text-align:center">Web Console，功能较完善</td><td style="text-align:center">web界面</td></tr><tr><td style="text-align:center">社区活跃程度</td><td style="text-align:center">人数多，活跃用户数最多</td><td style="text-align:center">人数多，但活跃用户数较少</td><td style="text-align:center">人数少，但活跃用户数较多</td><td style="text-align:center">人数较少，活跃用户数也少</td></tr><tr><td style="text-align:center">兼容云平台</td><td style="text-align:center">Amazon EC2，S3</td><td style="text-align:center">Amazon EC2，S3</td><td style="text-align:center">Amazon EC2，S3</td><td style="text-align:center">Amazon EC2，S3</td></tr><tr><td style="text-align:center">开发主导</td><td style="text-align:center">开源社区</td><td style="text-align:center">Eucalyptus System Inc</td><td style="text-align:center">Citrix公司</td><td style="text-align:center">开源社区</td></tr><tr><td style="text-align:center">主要支持厂商</td><td style="text-align:center">160家左右，包括NASA、Rackspace、HP、Dell、UnitedStack等</td><td style="text-align:center">亚马逊、戴尔、惠普、Intel、Redhat、Vmware等</td><td style="text-align:center">不到60家，包括诺基亚、日本电话电报公司、阿尔卡特、迪士尼等</td><td style="text-align:center">IBM、Akamai、Blackberry、Fuze、Telefonica、Indigital</td></tr><tr><td style="text-align:center">官方文档</td><td style="text-align:center">非常详细</td><td style="text-align:center">不够详细</td><td style="text-align:center">详细</td><td style="text-align:center">详细</td></tr><tr><td style="text-align:center">检测和审计</td><td style="text-align:center">Telemetry Service</td><td style="text-align:center">Accounting system</td><td style="text-align:center">Event/Audit logs</td><td style="text-align:center">Accounting system、periodically-Monitoring</td></tr><tr><td style="text-align:center">数据库</td><td style="text-align:center">PostareSQL、MySQL、SQLite</td><td style="text-align:center">HyperSQL Database</td><td style="text-align:center">MySQL</td><td style="text-align:center">SQLite、MySQL</td></tr><tr><td style="text-align:center">部署</td><td style="text-align:center">私有云、共有云、混合云</td><td style="text-align:center">私有云、混合云</td><td style="text-align:center">私有云、共有云、混合云</td><td style="text-align:center">私有云、共有云、混合云</td></tr><tr><td style="text-align:center">操作系统</td><td style="text-align:center">Debian 7.0、openSUSE、SUSE、Red Hat、CentOS、Fedora、Ubuntu</td><td style="text-align:center">CentOS、RHEL</td><td style="text-align:center">CentOS、RHEL6.3+、Ubuntu</td><td style="text-align:center">Red Hat、Ubuntu、SUSE、CentOS、Debian</td></tr><tr><td style="text-align:center">开发语言</td><td style="text-align:center">Python</td><td style="text-align:center">Java、C/C++</td><td style="text-align:center">Java</td><td style="text-align:center">C、Ruby、shell</td></tr><tr><td style="text-align:center">开源市场部署比例</td><td style="text-align:center">69%</td><td style="text-align:center">3%</td><td style="text-align:center">14%</td><td style="text-align:center">无统计数据</td></tr></tbody></table><p>这四种主流的开源云计算平台都经过了近十年的发展，更新迭代了很多版本，能够从众多云计算平台的竞争中存活下来，都有相应的支持厂商和用户，说明它们各有各的特点，如在开发语言上就各有特色，Openstack使用的是Python语言，Eucalyptus使用Java、C/C++，CloudStack仅使用Java，而OpenNebula却显得比较奇怪，使用的是C语言、Ruby和shell，多种语言混杂而成。但不同平台之间还是有较大差距，从结果来看，在开源市场的部署比例，Openstack 69%的比例占据了绝对统治地位，Openstack能占据这样的地位有多方面的原因，如Openstack支持绝大多数的虚拟化技术，支持的操作系统也很多，使得Openstack具有广阔的应用范围；Openstack的官方文档非常详细，也降低了其学习成本；Openstack具有一个充满活力的开源社区，开发者不断为Openstack的发展作出贡献；OpenStack的支持厂商有160家左右，有如此多的厂商支持，给OpenStack的发展提供了根本保障。综合以上多方面的原因，本项目采用Openstack作为底层的云计算平台为上层提供基础设施资源也是理所当然的。另外，在2018年2月28日发布的Openstack Queens最新版本中，新引入的Marquee功能正是为了提供对vGPU的内置支持能力，这意味着用户能够将GPU添加至虚拟机中，为本项目的上层应用，如深度学习等需要强大GPU运算能力的应用提供了支持。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过以上的分析，能够清楚的了解各种虚拟化技术及各种云计算平台的差异，对于要选择满足自己需求的技术与平台会有一些帮助。</p><hr>]]></content>
      
      <categories>
          
          <category> 云计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KVM </tag>
            
            <tag> Openstack </tag>
            
            <tag> 云计算 </tag>
            
            <tag> 虚拟化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Openstack环境下手动安装Mistral</title>
      <link href="/2017/12/23/Openstack%E7%8E%AF%E5%A2%83%E4%B8%8B%E6%89%8B%E5%8A%A8%E5%AE%89%E8%A3%85Mistral/"/>
      <url>/2017/12/23/Openstack%E7%8E%AF%E5%A2%83%E4%B8%8B%E6%89%8B%E5%8A%A8%E5%AE%89%E8%A3%85Mistral/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在openstack平台中能够成功安装Tacker，但是安装的Tacker并不能用，因为在tacker中创建VIM时需要调用Mistral工作流组件。因此本文就来介绍在openstack环境中手动安装Mistral的过程。</p><a id="more"></a><p><strong>注：</strong> 安装的openstack是在Ubuntu 16.04系统下的Ocata版本；本文中涉及的密码都统一设置成 <em>“openstack”</em>。</p><p>参考<a href="https://docs.openstack.org/mistral/latest/install/installation_guide.html" target="_blank" rel="noopener"><em>官方文档</em></a></p><h1 id="一、安装必要组件"><a href="#一、安装必要组件" class="headerlink" title="一、安装必要组件"></a>一、安装必要组件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ apt-get install python-dev python-setuptools python-pip libffi-dev \</span><br><span class="line">  libxslt1-dev libxml2-dev libyaml-dev libssl-dev</span><br></pre></td></tr></table></figure><h1 id="二、安装Mistral-server"><a href="#二、安装Mistral-server" class="headerlink" title="二、安装Mistral server"></a>二、安装Mistral server</h1><h2 id="1、下载Mistral源码，并进入下载目录"><a href="#1、下载Mistral源码，并进入下载目录" class="headerlink" title="1、下载Mistral源码，并进入下载目录"></a>1、下载Mistral源码，并进入下载目录</h2><pre><code>$ git clone https://github.com/openstack/mistral.git$ cd mistral</code></pre><h2 id="2、安装Mistral环境依赖包"><a href="#2、安装Mistral环境依赖包" class="headerlink" title="2、安装Mistral环境依赖包"></a>2、安装Mistral环境依赖包</h2><pre><code>$ pip install -r requirements.txt</code></pre><h2 id="3、安装Mistral"><a href="#3、安装Mistral" class="headerlink" title="3、安装Mistral"></a>3、安装Mistral</h2><pre><code>$ python setup.py install</code></pre><h2 id="4、生成配置文件"><a href="#4、生成配置文件" class="headerlink" title="4、生成配置文件"></a>4、生成配置文件</h2><pre><code>$ oslo-config-generator --config-file tools/config/config-generator.mistral.conf --output-file etc/mistral.conf</code></pre><h2 id="5、创建Mistral日志文件和配置文件夹"><a href="#5、创建Mistral日志文件和配置文件夹" class="headerlink" title="5、创建Mistral日志文件和配置文件夹"></a>5、创建Mistral日志文件和配置文件夹</h2><pre><code># mkdir -p /etc/mistral /var/log/mistral</code></pre><h2 id="6、复制配置文件到配置文件夹"><a href="#6、复制配置文件到配置文件夹" class="headerlink" title="6、复制配置文件到配置文件夹"></a>6、复制配置文件到配置文件夹</h2><pre><code># cp etc/* /etc/mistral/</code></pre><h2 id="7、修改配置文件"><a href="#7、修改配置文件" class="headerlink" title="7、修改配置文件"></a>7、修改配置文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># vi /etc/mistral/mistral.conf </span><br><span class="line"></span><br><span class="line">[keystone_authtoken]</span><br><span class="line">auth_uri = http://controller:5000</span><br><span class="line">auth_version = 3</span><br><span class="line">identity_uri = http://controller:35357/</span><br><span class="line">admin_user = admin</span><br><span class="line">admin_password = openstack</span><br><span class="line">admin_tenant_name = admin</span><br><span class="line"></span><br><span class="line">[database]</span><br><span class="line">connection = mysql+pymysql://mistral:openstack@controller/mistral </span><br><span class="line"></span><br><span class="line">[DEFAULT]</span><br><span class="line">transport_url = rabbit://openstack:openstack@controller</span><br></pre></td></tr></table></figure><h2 id="8、创建数据库"><a href="#8、创建数据库" class="headerlink" title="8、创建数据库"></a>8、创建数据库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># mysql</span><br><span class="line">MariaDB [(none)]&gt; CREATE DATABASE mistral;</span><br><span class="line">MariaDB [mistral]&gt; GRANT ALL PRIVILEGES ON mistral.* TO &apos;mistral&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;openstack&apos;;</span><br><span class="line">MariaDB [mistral]&gt; GRANT ALL PRIVILEGES ON mistral.* TO &apos;mistral&apos;@&apos;%&apos; IDENTIFIED BY &apos;openstack&apos;;</span><br><span class="line">MariaDB [mistral]&gt; flush privileges;</span><br><span class="line">MariaDB [mistral]&gt; exit;</span><br></pre></td></tr></table></figure><h2 id="9、创建服务和endpoint"><a href="#9、创建服务和endpoint" class="headerlink" title="9、创建服务和endpoint"></a>9、创建服务和endpoint</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ openstack service create --name mistral --description &quot;Openstack Workflow service&quot; workflow</span><br><span class="line">$ openstack endpoint create --region RegionOne workflow public http://controller:8989/v2</span><br><span class="line">$ openstack endpoint create --region RegionOne workflow internal http://controller:8989/v2</span><br><span class="line">$ openstack endpoint create --region RegionOne workflow admin http://controller:8989/v2</span><br></pre></td></tr></table></figure><h2 id="10、初始化数据库信息"><a href="#10、初始化数据库信息" class="headerlink" title="10、初始化数据库信息"></a>10、初始化数据库信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">root@controller:/home/openstack# mistral-db-manage --config-file /etc/mistral/mistral.conf upgrade head</span><br><span class="line"></span><br><span class="line">INFO  [alembic.runtime.migration] Context impl MySQLImpl.</span><br><span class="line">INFO  [alembic.runtime.migration] Will assume non-transactional DDL.</span><br><span class="line">INFO  [alembic.runtime.migration] Running upgrade  -&gt; 001, Kilo release</span><br><span class="line">INFO  [alembic.runtime.migration] Running upgrade 001 -&gt; 002, Kilo</span><br><span class="line">INFO  [alembic.runtime.migration] Running upgrade 002 -&gt; 003, cron_trigger_constraints</span><br><span class="line">INFO  [alembic.runtime.migration] Running upgrade 003 -&gt; 004, add description for execution</span><br><span class="line">INFO  [alembic.runtime.migration] Running upgrade 004 -&gt; 005, Increase executions_v2 column size from JsonDictType to JsonLongDictType</span><br><span class="line">INFO  [alembic.runtime.migration] Running upgrade 005 -&gt; 006, add a Boolean column &apos;processed&apos; to the table  delayed_calls_v2</span><br><span class="line">INFO  [alembic.runtime.migration] Running upgrade 006 -&gt; 007, Move system flag to base definition</span><br><span class="line">INFO  [alembic.runtime.migration] Running upgrade 007 -&gt; 008, Increase size of state_info column from String to Text</span><br><span class="line">INFO  [alembic.runtime.migration] Running upgrade 008 -&gt; 009, Add database indices</span><br><span class="line">INFO  [alembic.runtime.migration] Running upgrade 009 -&gt; 010, add_resource_members_v2_table</span><br><span class="line">INFO  [alembic.runtime.migration] Running upgrade 010 -&gt; 011, add workflow id for execution</span><br><span class="line">INFO  [alembic.runtime.migration] Running upgrade 011 -&gt; 012, add event triggers table</span><br><span class="line">INFO  [alembic.runtime.migration] Running upgrade 012 -&gt; 013, split_execution_table_increase_names</span><br><span class="line">INFO  [alembic.runtime.migration] Running upgrade 013 -&gt; 014, fix_past_scripts_discrepancies</span><br><span class="line">INFO  [alembic.runtime.migration] Running upgrade 014 -&gt; 015, add_unique_keys_for_non_locking_model</span><br><span class="line">INFO  [alembic.runtime.migration] Running upgrade 015 -&gt; 016, Increase size of task_executions_v2.unique_key</span><br><span class="line">INFO  [alembic.runtime.migration] Running upgrade 016 -&gt; 017, Add named lock table</span><br><span class="line">INFO  [alembic.runtime.migration] Running upgrade 017 -&gt; 018, increate_task_execution_unique_key_size</span><br><span class="line">INFO  [alembic.runtime.migration] Running upgrade 018 -&gt; 019, Change scheduler schema.</span><br><span class="line">INFO  [alembic.runtime.migration] Running upgrade 019 -&gt; 020, add type to task execution</span><br><span class="line">INFO  [alembic.runtime.migration] Running upgrade 020 -&gt; 021, Increase environments_v2 column size from JsonDictType to JsonLongDictType</span><br></pre></td></tr></table></figure><h2 id="11、添加自带的action"><a href="#11、添加自带的action" class="headerlink" title="11、添加自带的action"></a>11、添加自带的action</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">root@controller:/home/openstack# mistral-db-manage --config-file /etc/mistral/mistral.conf populate</span><br><span class="line">*输出结果可能为：*</span><br><span class="line">No handlers could be found for logger &quot;mistral.actions.openstack.action_generator.base&quot;</span><br><span class="line">*也可能会出错：*</span><br><span class="line">……</span><br><span class="line">2017-12-22 22:21:24.486 16802 INFO mistral.actions.openstack.action_generator.base [-] Processing OpenStack action mapping from file: /usr/local/lib/python2.7/dist-packages/mistral/actions/openstack/mapping.json</span><br><span class="line">2017-12-22 22:21:24.551 16802 INFO mistral.actions.openstack.action_generator.base [-] Processing OpenStack action mapping from file: /usr/local/lib/python2.7/dist-packages/mistral/actions/openstack/mapping.json</span><br><span class="line">2017-12-22 22:21:24.761 16802 INFO mistral.actions.openstack.action_generator.base [-] Processing OpenStack action mapping from file: /usr/local/lib/python2.7/dist-packages/mistral/actions/openstack/mapping.json</span><br><span class="line">2017-12-22 22:21:24.878 16802 INFO mistral.actions.openstack.action_generator.base [-] Processing OpenStack action mapping from file: /usr/local/lib/python2.7/dist-packages/mistral/actions/openstack/mapping.json</span><br><span class="line">2017-12-22 22:21:24.883 16802 WARNING oslo_config.cfg [-] Option &quot;auth_uri&quot; from group &quot;keystone_authtoken&quot; is deprecated for removal (The auth_uri option is deprecated in favor of www_authenticate_uri and will be removed in the S  release.).  Its value may be silently ignored in the future.</span><br><span class="line">^C2017-12-22 22:21:25.382 16802 CRITICAL Mistral [-] Unhandled error: KeyboardInterrupt</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral Traceback (most recent call last):</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;/usr/local/bin/mistral-db-manage&quot;, line 10, in &lt;module&gt;</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     sys.exit(main())</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;/usr/local/lib/python2.7/dist-packages/mistral/db/sqlalchemy/migration/cli.py&quot;, line 137, in main</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     CONF.command.func(config, CONF.command.name)</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;/usr/local/lib/python2.7/dist-packages/mistral/db/sqlalchemy/migration/cli.py&quot;, line 75, in do_populate</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     action_manager.sync_db()</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;/usr/local/lib/python2.7/dist-packages/mistral/services/action_manager.py&quot;, line 80, in sync_db</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     register_action_classes()</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;/usr/local/lib/python2.7/dist-packages/mistral/services/action_manager.py&quot;, line 126, in register_action_classes</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     _register_dynamic_action_classes()</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;/usr/local/lib/python2.7/dist-packages/mistral/services/action_manager.py&quot;, line 86, in _register_dynamic_action_classes</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     actions = generator.create_actions()</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;/usr/local/lib/python2.7/dist-packages/mistral/actions/openstack/action_generator/base.py&quot;, line 143, in create_actions</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     client_method = class_.get_fake_client_method()</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;/usr/local/lib/python2.7/dist-packages/mistral/actions/openstack/base.py&quot;, line 75, in get_fake_client_method</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     return cls._get_client_method(cls._get_fake_client())</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;/usr/local/lib/python2.7/dist-packages/mistral/actions/openstack/actions.py&quot;, line 380, in _get_fake_client</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     return cls._get_client_class()(session=sess)</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;/usr/local/lib/python2.7/dist-packages/ironic_inspector_client/v1.py&quot;, line 88, in __init__</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     super(ClientV1, self).__init__(**kwargs)</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;/usr/local/lib/python2.7/dist-packages/ironic_inspector_client/common/http.py&quot;, line 134, in __init__</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     region_name=region_name)</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;/usr/lib/python2.7/dist-packages/keystoneauth1/session.py&quot;, line 856, in get_endpoint</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     return auth.get_endpoint(self, **kwargs)</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;/usr/lib/python2.7/dist-packages/keystoneauth1/identity/base.py&quot;, line 212, in get_endpoint</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     service_catalog = self.get_access(session).service_catalog</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;/usr/lib/python2.7/dist-packages/keystoneauth1/identity/base.py&quot;, line 136, in get_access</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     self.auth_ref = self.get_auth_ref(session)</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;/usr/lib/python2.7/dist-packages/keystoneauth1/identity/generic/base.py&quot;, line 198, in get_auth_ref</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     return self._plugin.get_auth_ref(session, **kwargs)</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;/usr/lib/python2.7/dist-packages/keystoneauth1/identity/v3/base.py&quot;, line 167, in get_auth_ref</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     authenticated=False, log=False, **rkwargs)</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;/usr/lib/python2.7/dist-packages/keystoneauth1/session.py&quot;, line 766, in post</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     return self.request(url, &apos;POST&apos;, **kwargs)</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;/usr/lib/python2.7/dist-packages/positional/__init__.py&quot;, line 101, in inner</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     return wrapped(*args, **kwargs)</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;/usr/lib/python2.7/dist-packages/keystoneauth1/session.py&quot;, line 616, in request</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     resp = send(**kwargs)</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;/usr/lib/python2.7/dist-packages/keystoneauth1/session.py&quot;, line 674, in _send_request</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     resp = self.session.request(method, url, **kwargs)</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;/usr/local/lib/python2.7/dist-packages/requests/sessions.py&quot;, line 508, in request</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     resp = self.send(prep, **send_kwargs)</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;/usr/local/lib/python2.7/dist-packages/requests/sessions.py&quot;, line 618, in send</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     r = adapter.send(request, **kwargs)</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;/usr/local/lib/python2.7/dist-packages/requests/adapters.py&quot;, line 440, in send</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     timeout=timeout</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;/usr/local/lib/python2.7/dist-packages/urllib3/connectionpool.py&quot;, line 601, in urlopen</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     chunked=chunked)</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;/usr/local/lib/python2.7/dist-packages/urllib3/connectionpool.py&quot;, line 380, in _make_request</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     httplib_response = conn.getresponse(buffering=True)</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;/usr/lib/python2.7/httplib.py&quot;, line 1136, in getresponse</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     response.begin()</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;/usr/lib/python2.7/httplib.py&quot;, line 453, in begin</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     version, status, reason = self._read_status()</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;/usr/lib/python2.7/httplib.py&quot;, line 409, in _read_status</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     line = self.fp.readline(_MAXLINE + 1)</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;/usr/lib/python2.7/socket.py&quot;, line 480, in readline</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     data = self._sock.recv(self._rbufsize)</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral KeyboardInterrupt</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral</span><br></pre></td></tr></table></figure><p>纠结了很久后发现这些都不用太在意，直接跳过，哈哈！</p><h1 id="三、安装Mistral-client"><a href="#三、安装Mistral-client" class="headerlink" title="三、安装Mistral client"></a>三、安装Mistral client</h1><h2 id="1、下载Mistral-client源码"><a href="#1、下载Mistral-client源码" class="headerlink" title="1、下载Mistral-client源码"></a>1、下载Mistral-client源码</h2><pre><code>$ git clone git://git.openstack.org/openstack/python-mistralclient.git -b stable/ocata$ cd python-mistralclient</code></pre><h2 id="2、安装Mistral-client模块"><a href="#2、安装Mistral-client模块" class="headerlink" title="2、安装Mistral-client模块"></a>2、安装Mistral-client模块</h2><pre><code>$ pip install -r requirements.txt$ python setup.py install</code></pre><h1 id="四、安装Mistral-horizon"><a href="#四、安装Mistral-horizon" class="headerlink" title="四、安装Mistral horizon"></a>四、安装Mistral horizon</h1><h2 id="1、下载Mistral-horizon源码"><a href="#1、下载Mistral-horizon源码" class="headerlink" title="1、下载Mistral-horizon源码"></a>1、下载Mistral-horizon源码</h2><pre><code>$ git clone https://git.openstack.org/openstack/mistral-dashboard.git -b stable/ocata$ cd mistral-dashboard/</code></pre><h2 id="2、安装Mistral-horizon模块"><a href="#2、安装Mistral-horizon模块" class="headerlink" title="2、安装Mistral-horizon模块"></a>2、安装Mistral-horizon模块</h2><pre><code>$ pip install -r requirements.txt$ python setup.py install</code></pre><h2 id="3、复制一个文件"><a href="#3、复制一个文件" class="headerlink" title="3、复制一个文件"></a>3、复制一个文件</h2><pre><code># cp -b mistraldashboard/enabled/_50_mistral.py /usr/share/openstack-dashboard/openstack_dashboard/enabled/_50_mistral.py</code></pre><h2 id="4、重启apache2服务"><a href="#4、重启apache2服务" class="headerlink" title="4、重启apache2服务"></a>4、重启apache2服务</h2><pre><code># service apache2 restart</code></pre><p>安装好Mistral-horizon后，admin用户登录dashboard界面就可以看到Mistral相关的workflow，如图：<br><img src="https://raw.githubusercontent.com/cao0507/Pictures/master/blog/mistral%20horizon.png" alt="Mistral-horizon界面"></p><h1 id="五、运行Mistral-server"><a href="#五、运行Mistral-server" class="headerlink" title="五、运行Mistral server"></a>五、运行Mistral server</h1><p>运行下面的第一条命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">root@controller:/home/openstack/mistral# python mistral/cmd/launch.py --server all --config-file /etc/mistral/mistral.conf</span><br><span class="line"></span><br><span class="line">|\\    //|           ||                       ||</span><br><span class="line">||\\  //||      __   ||      __      __       ||</span><br><span class="line">|| \\// || ||  //  ||||||  ||  \\  //  \\     ||</span><br><span class="line">||  \/  ||     \\    ||    ||     ||    \\    ||</span><br><span class="line">||      || ||   \\   ||    ||     ||    /\\   ||</span><br><span class="line">||      || || __//   ||_// ||      \\__// \\_ ||</span><br><span class="line">Mistral Workflow Service, version 6.0.0</span><br><span class="line"></span><br><span class="line">Launching server components [engine,event-engine,api,executor]...</span><br><span class="line">2017-12-22 22:42:58.373 16966 INFO mistral.event_engine.default_event_engine [-] Starting event notification task...</span><br><span class="line">2017-12-22 22:42:58.571 16966 INFO mistral.event_engine.default_event_engine [-] Found 0 event triggers.</span><br><span class="line">/usr/local/lib/python2.7/dist-packages/oslo_messaging/server.py:341: FutureWarning: blocking executor is deprecated. Executor default will be removed. Use explicitly threading or eventlet instead in version &apos;pike&apos; and will be removed in version &apos;rocky&apos;</span><br><span class="line">  category=FutureWarning)</span><br><span class="line">2017-12-22 22:42:58.913 16966 WARNING oslo_config.cfg [req-46885c1b-de53-4bba-958d-97484cd17783 - - - - -] Option &quot;auth_uri&quot; from group &quot;keystone_authtoken&quot; is deprecated for removal (The auth_uri option is deprecated in favor of www_authenticate_uri and will be removed in the S  release.).  Its value may be silently ignored in the future.</span><br><span class="line">2017-12-22 22:42:58.915 16966 WARNING oslo_config.cfg [req-46885c1b-de53-4bba-958d-97484cd17783 - - - - -] Option &quot;auth_uri&quot; from group &quot;keystone_authtoken&quot; is deprecated. Use option &quot;www_authenticate_uri&quot; from group &quot;keystone_authtoken&quot;.</span><br><span class="line">2017-12-22 22:42:58.925 16966 WARNING keystonemiddleware.auth_token [req-46885c1b-de53-4bba-958d-97484cd17783 - - - - -] AuthToken middleware is set with keystone_authtoken.service_token_roles_required set to False. This is backwards compatible but deprecated behaviour. Please set this to True.</span><br><span class="line">2017-12-22 22:42:58.926 16966 WARNING keystonemiddleware.auth_token [req-46885c1b-de53-4bba-958d-97484cd17783 - - - - -] Use of the auth_admin_prefix, auth_host, auth_port, auth_protocol, identity_uri, admin_token, admin_user, admin_password, and admin_tenant_name configuration options was deprecated in the Mitaka release in favor of an auth_plugin and its related options. This class may be removed in a future release.</span><br><span class="line">2017-12-22 22:42:58.931 16966 INFO oslo.service.wsgi [req-46885c1b-de53-4bba-958d-97484cd17783 - - - - -] mistral_api listening on 0.0.0.0:8989</span><br><span class="line">2017-12-22 22:42:58.932 16966 INFO oslo_service.service [req-46885c1b-de53-4bba-958d-97484cd17783 - - - - -] Starting 4 workers</span><br><span class="line">API server started.</span><br><span class="line">API server started.</span><br><span class="line">API server started.</span><br><span class="line">API server started.</span><br><span class="line">Event engine server started.</span><br><span class="line">Executor server started.</span><br><span class="line">Engine server started.</span><br></pre></td></tr></table></figure></p><h1 id="六、测试一下Mistral是否可用"><a href="#六、测试一下Mistral是否可用" class="headerlink" title="六、测试一下Mistral是否可用"></a>六、测试一下Mistral是否可用</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">openstack@controller:~/mistral/etc$ mistral workbook-list</span><br><span class="line">+--------+--------+------------+------------+</span><br><span class="line">| Name   | Tags   | Created at | Updated at |</span><br><span class="line">+--------+--------+------------+------------+</span><br><span class="line">| &lt;none&gt; | &lt;none&gt; | &lt;none&gt;     | &lt;none&gt;     |</span><br><span class="line">+--------+--------+------------+------------+</span><br><span class="line"></span><br><span class="line">openstack@controller:~/mistral/etc$ mistral action-list</span><br><span class="line">+--------+--------+-----------+--------+-------------+--------+------------+------------+</span><br><span class="line">| ID     | Name   | Is system | Input  | Description | Tags   | Created at | Updated at |</span><br><span class="line">+--------+--------+-----------+--------+-------------+--------+------------+------------+</span><br><span class="line">| &lt;none&gt; | &lt;none&gt; | &lt;none&gt;    | &lt;none&gt; | &lt;none&gt;      | &lt;none&gt; | &lt;none&gt;     | &lt;none&gt;     |</span><br><span class="line">+--------+--------+-----------+--------+-------------+--------+------------+------------+</span><br></pre></td></tr></table></figure><p>OK，成功了，开心！！！</p><hr>]]></content>
      
      <categories>
          
          <category> Openstack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Openstack </tag>
            
            <tag> Tacker </tag>
            
            <tag> Mistral </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Openstack环境下手动安装Tacker</title>
      <link href="/2017/12/23/Openstack%E7%8E%AF%E5%A2%83%E4%B8%8B%E6%89%8B%E5%8A%A8%E5%AE%89%E8%A3%85Tacker/"/>
      <url>/2017/12/23/Openstack%E7%8E%AF%E5%A2%83%E4%B8%8B%E6%89%8B%E5%8A%A8%E5%AE%89%E8%A3%85Tacker/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本文参考官方文档，在现有的openstack平台上，手动安装Tacker。基础的openstack平台包含了最核心的keystone、glance、nova、neutron、horizon这5个组件，但是Tacker还需要预先安装好Mistral和Barbican这两个组件，在安装好这两个组件后就可以开始按照以下步骤安装Tacker了。<br><a id="more"></a><br>参考：<a href="https://docs.openstack.org/tacker/latest/install/manual_installation.html" target="_blank" rel="noopener"><em>官方文档链接</em></a></p><p><strong>注：</strong> 本文涉及到的密码都统一设置成<em>openstack</em>。</p><h1 id="一、安装Tacker-server"><a href="#一、安装Tacker-server" class="headerlink" title="一、安装Tacker server"></a>一、安装Tacker server</h1><h2 id="1、创建数据库"><a href="#1、创建数据库" class="headerlink" title="1、创建数据库"></a>1、创建数据库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># mysql</span><br><span class="line">MariaDB [(none)]&gt; CREATE DATABASE tacker;</span><br><span class="line">MariaDB [tacker]&gt; GRANT ALL PRIVILEGES ON tacker.* TO &apos;tacker&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;openstack&apos;;</span><br><span class="line">MariaDB [tacker]&gt; GRANT ALL PRIVILEGES ON tacker.* TO &apos;tacker&apos;@&apos;%&apos; IDENTIFIED BY &apos;openstack&apos;;</span><br><span class="line">MariaDB [tacker]&gt; exit;</span><br></pre></td></tr></table></figure><h2 id="2、创建user、role、endpoints"><a href="#2、创建user、role、endpoints" class="headerlink" title="2、创建user、role、endpoints"></a>2、创建user、role、endpoints</h2><h3 id="1-获得admin凭证"><a href="#1-获得admin凭证" class="headerlink" title="1)获得admin凭证"></a>1)获得admin凭证</h3><pre><code># . admin-openrc</code></pre><h3 id="2-创建tacker用户，密码为openstack"><a href="#2-创建tacker用户，密码为openstack" class="headerlink" title="2)创建tacker用户，密码为openstack"></a>2)创建tacker用户，密码为openstack</h3><pre><code># openstack user create --domain default --password openstack tacker</code></pre><h3 id="3-给tacker用户赋予admin权限"><a href="#3-给tacker用户赋予admin权限" class="headerlink" title="3)给tacker用户赋予admin权限"></a>3)给tacker用户赋予admin权限</h3><pre><code># openstack role add --project service --user tacker admin</code></pre><h3 id="4-创建tacker服务"><a href="#4-创建tacker服务" class="headerlink" title="4)创建tacker服务"></a>4)创建tacker服务</h3><pre><code># openstack service create --name tacker \    --description &quot;Tacker Project&quot; nfv-orchestration</code></pre><h3 id="5-创建endpoints"><a href="#5-创建endpoints" class="headerlink" title="5)创建endpoints"></a>5)创建endpoints</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># openstack endpoint create --region RegionOne nfv-orchestration \</span><br><span class="line">           public http://controller:9890/</span><br><span class="line"># openstack endpoint create --region RegionOne nfv-orchestration \</span><br><span class="line">           internal http://controller:9890/</span><br><span class="line"># openstack endpoint create --region RegionOne nfv-orchestration \</span><br><span class="line">           admin http://controller:9890/</span><br></pre></td></tr></table></figure><h2 id="3、下载Tacker源码"><a href="#3、下载Tacker源码" class="headerlink" title="3、下载Tacker源码"></a>3、下载Tacker源码</h2><pre><code># git clone https://github.com/openstack/tacker -b stable/ocata</code></pre><h2 id="4、安装Tacker环境依赖包"><a href="#4、安装Tacker环境依赖包" class="headerlink" title="4、安装Tacker环境依赖包"></a>4、安装Tacker环境依赖包</h2><pre><code># cd tacker# pip install -r requirements.txt</code></pre><h2 id="5、安装Tacker"><a href="#5、安装Tacker" class="headerlink" title="5、安装Tacker"></a>5、安装Tacker</h2><pre><code># python setup.py install</code></pre><h2 id="6、创建Tacker日志文件夹"><a href="#6、创建Tacker日志文件夹" class="headerlink" title="6、创建Tacker日志文件夹"></a>6、创建Tacker日志文件夹</h2><pre><code># mkdir -p /var/log/tacker</code></pre><h2 id="7、生成配置文件"><a href="#7、生成配置文件" class="headerlink" title="7、生成配置文件"></a>7、生成配置文件</h2><pre><code># ./tools/generate_config_file_sample.sh这时生成的配置文件在etc/tacker/tacker.conf.sample，需要将其重命名为tacker.conf# mv etc/tacker/tacker.conf.sample  etc/tacker/tacker.conf</code></pre><h2 id="8、修改配置文件"><a href="#8、修改配置文件" class="headerlink" title="8、修改配置文件"></a>8、修改配置文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"># vi etc/tacker/tacker.conf</span><br><span class="line"></span><br><span class="line">[DEFAULT]</span><br><span class="line">auth_strategy = keystone</span><br><span class="line">policy_file = /usr/local/etc/tacker/policy.json</span><br><span class="line">debug = True</span><br><span class="line">use_syslog = False</span><br><span class="line">bind_host = 10.0.0.11</span><br><span class="line">bind_port = 9890</span><br><span class="line">service_plugins = nfvo,vnfm</span><br><span class="line"></span><br><span class="line">state_path = /var/lib/tacker</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">[nfvo]</span><br><span class="line">vim_drivers = openstack</span><br><span class="line"></span><br><span class="line">[keystone_authtoken]</span><br><span class="line">memcached_servers = 11211</span><br><span class="line">region_name = RegionOne</span><br><span class="line">auth_type = password</span><br><span class="line">project_domain_name = Default</span><br><span class="line">user_domain_name = Default</span><br><span class="line">username = tacker</span><br><span class="line">project_name = service</span><br><span class="line">password = openstack</span><br><span class="line">auth_url = http://controller:35357</span><br><span class="line">auth_uri = http://controller:5000</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">[agent]</span><br><span class="line">root_helper = sudo /usr/local/bin/tacker-rootwrap /usr/local/etc/tacker/rootwrap.conf</span><br><span class="line"></span><br><span class="line">[database]</span><br><span class="line">connection = mysql://tacker:openstack@controller:3306/tacker?charset=utf8</span><br><span class="line"></span><br><span class="line">[tacker]</span><br><span class="line">monitor_driver = ping,http_ping</span><br></pre></td></tr></table></figure><h2 id="9、复制配置文件到配置文件夹"><a href="#9、复制配置文件到配置文件夹" class="headerlink" title="9、复制配置文件到配置文件夹"></a>9、复制配置文件到配置文件夹</h2><pre><code># cp etc/tacker/tacker.conf  /usr/local/etc/tacker/</code></pre><h2 id="10、初始化数据库信息"><a href="#10、初始化数据库信息" class="headerlink" title="10、初始化数据库信息"></a>10、初始化数据库信息</h2><pre><code># /usr/local/bin/tacker-db-manage --config-file /usr/local/etc/tacker/tacker.conf upgrade head</code></pre><h1 id="二、安装Tacker-client"><a href="#二、安装Tacker-client" class="headerlink" title="二、安装Tacker client"></a>二、安装Tacker client</h1><h2 id="1、下载Tacker-client源码"><a href="#1、下载Tacker-client源码" class="headerlink" title="1、下载Tacker-client源码"></a>1、下载Tacker-client源码</h2><pre><code># git clone https://github.com/openstack/python-tackerclient -b stable/ocata</code></pre><h2 id="2、安装Tacker-client模块"><a href="#2、安装Tacker-client模块" class="headerlink" title="2、安装Tacker-client模块"></a>2、安装Tacker-client模块</h2><pre><code># cd python-tackerclient# python setup.py install</code></pre><h1 id="三、安装Tacker-horizon"><a href="#三、安装Tacker-horizon" class="headerlink" title="三、安装Tacker horizon"></a>三、安装Tacker horizon</h1><h2 id="1、下载Tacker-horizon源码"><a href="#1、下载Tacker-horizon源码" class="headerlink" title="1、下载Tacker-horizon源码"></a>1、下载Tacker-horizon源码</h2><pre><code># git clone https://github.com/openstack/tacker-horizon -b stable/ocata</code></pre><h2 id="2、安装Tacker-horizon模块"><a href="#2、安装Tacker-horizon模块" class="headerlink" title="2、安装Tacker-horizon模块"></a>2、安装Tacker-horizon模块</h2><pre><code># cd tacker-horizon# python setup.py install</code></pre><p>安装好tacker-horizon后，admin用户登录dashboard界面就可以看到Tacker相关的VNFM和NFVO，如图：<br><img src="https://raw.githubusercontent.com/cao0507/Pictures/master/blog/tacker%20horizon.png" alt="tacker-horizon"></p><h1 id="四、开启Tacker-server"><a href="#四、开启Tacker-server" class="headerlink" title="四、开启Tacker server"></a>四、开启Tacker server</h1><p>打开一个新的终端，开启Tacker-server，因为Tacker-server的程序会独占这个终端。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo python /usr/local/bin/tacker-server \</span><br><span class="line">    --config-file /usr/local/etc/tacker/tacker.conf \</span><br><span class="line">    --log-file /var/log/tacker/tacker.log</span><br></pre></td></tr></table></figure></p><hr><p><strong>需注意的一个问题：</strong></p><p>在安装完Tacker而没有装Mistral时创建VIM的结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@controller:/home/openstack# tacker vim-register --is-default --config-file config.yaml test_vim</span><br><span class="line">The resource could not be found.</span><br><span class="line"></span><br><span class="line">或者是这种错误：Expecting to find domain in project. The server could not comply with the request since it is either malformed or otherwise incorrect. The client is assumed to be in error.</span><br></pre></td></tr></table></figure></p><p>经过查阅资料，知道这个问题是因为Tacker在创建VIM时要调用Mistral而造成的。所以在使用tacker之前需要先安装好Mistral（可以在安装tacker前安装Mistral，也可以在tacker安装之后安装Mistral，后续还需继续了解）。</p><hr>]]></content>
      
      <categories>
          
          <category> Openstack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Openstack </tag>
            
            <tag> Tacker </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>KVM虚拟机部署openstack的网络配置</title>
      <link href="/2017/12/03/KVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%83%A8%E7%BD%B2openstack%E7%9A%84%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"/>
      <url>/2017/12/03/KVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%83%A8%E7%BD%B2openstack%E7%9A%84%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>这篇文章记录的是按照官方文档在<strong>KVM环境</strong>下部署<strong>双节点openstack</strong>过程中，前期准备KVM环境和网络配置相关的内容，在完成这篇博客涉及到的工作之后就可以按照官方文档手动安装openstack了。本文涉及的主要工作，首先是在服务器的<strong>ubuntu 16.04 desktop版</strong>系统上搭建kvm环境，然后在服务器上安装VNC远程桌面，最后在KVM环境中开启两台虚拟机，分别两张网卡，第一张网卡使用<strong>桥接模式</strong>，第二张网卡使用<strong>NAT模式</strong>。下面开始介绍一下这个过程。</p><a id="more"></a><h1 id="服务器搭建KVM环境"><a href="#服务器搭建KVM环境" class="headerlink" title="服务器搭建KVM环境"></a>服务器搭建KVM环境</h1><h2 id="查看CPU是否支持KVM"><a href="#查看CPU是否支持KVM" class="headerlink" title="查看CPU是否支持KVM"></a>查看CPU是否支持KVM</h2><p><code>$ egrep -c &quot;(svm|vmx)&quot; /proc/cpuinfo</code></p><p>输出结果大于0证明CPU支持KVM虚拟化 </p><p><img src="https://raw.githubusercontent.com/cao0507/Pictures/master/blog/infocpu.png" alt="虚拟CPU个数"></p><h2 id="安装KVM及相关依赖包"><a href="#安装KVM及相关依赖包" class="headerlink" title="安装KVM及相关依赖包"></a>安装KVM及相关依赖包</h2><p><code>$ sudo apt-get install qemu-kvm qemu virt-manager virt-viewer libvirt-bin bridge-utils</code></p><h2 id="启用桥接网络"><a href="#启用桥接网络" class="headerlink" title="启用桥接网络"></a>启用桥接网络</h2><p>在服务器上启用桥接网络需要配置一个桥接设备br0，配置br0有两种方式，通过手动配置和通过修改文件配置。 </p><h3 id="通过手动配置"><a href="#通过手动配置" class="headerlink" title="通过手动配置"></a>通过手动配置</h3><ul><li><p>创建br0网桥</p><p> <code># brctl addbr br0</code></p></li><li><p>将eth0网卡添加到br0上，此时可能会断网</p><p><code># brctl addif br0 eth0</code></p></li><li><p>删除eth0上的IP地址</p><p><code># ip addr del dev eth0 192.168.1.25/24</code></p></li><li><p>配置br0的IP地址并启动br0网桥设备</p><p><code># ifconfig br0 192.168.1.25/24 up</code></p></li><li><p>重新加入默认网关</p><p><code># route add default gw 192.168.1.1</code></p></li><li><p>查看配置是否生效 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># route     //查看默认网关，输出结果如下</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination             Gateway             Genmask         Flags     Metric      Ref    Use     Iface</span><br><span class="line">default              192.168.1.1             0.0.0.0          UG        0          0      0        br0</span><br><span class="line">192.168.1.0             *                 255.255.255.0       U         0          0      0        br0</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># ifconfig     //查看eth0和br0的IP信息，输出结果如下，可以发现现在br0有IP而eth0没有IP了</span><br><span class="line">br0       Link encap:Ethernet  HWaddr 00:e0:81:e2:3c:3d  </span><br><span class="line">          inet addr:192.168.1.25  Bcast:192.168.1.255  Mask:255.255.255.0</span><br><span class="line">          inet6 addr: fe80::2e0:81ff:fee2:3c3d/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:1316822 errors:0 dropped:5787 overruns:0 frame:0</span><br><span class="line">          TX packets:365475 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000</span><br><span class="line">          RX bytes:581279124 (581.2 MB)  TX bytes:562586852 (562.5 MB)</span><br><span class="line"> </span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 00:e0:81:e2:3c:3d  </span><br><span class="line">          inet6 addr: fe80::2e0:81ff:fee2:3c3d/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:6671034 errors:0 dropped:9627 overruns:0 frame:0</span><br><span class="line">          TX packets:840972 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000</span><br><span class="line">          RX bytes:1346523816 (1.3 GB)  TX bytes:614510541 (614.5 MB)</span><br><span class="line">          Memory:dfb80000-dfbfffff</span><br><span class="line"> </span><br><span class="line">lo        Link encap:Local Loopback  </span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          inet6 addr: ::1/128 Scope:Host</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class="line">          RX packets:1450290 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:1450290 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000</span><br><span class="line">          RX bytes:24027042487 (24.0 GB)  TX bytes:24027042487 (24.0 GB)</span><br></pre></td></tr></table></figure></li></ul><p>这就是通过手动来配置桥接设备br0的方法，这种方法在配置好之后马上就生效了，但是在系统重启之后这些配置信息都会被清除，要想使配置永久生效则需要修改网络配置文件，也就是下面的方法。 </p><h3 id="通过修改文件配置"><a href="#通过修改文件配置" class="headerlink" title="通过修改文件配置"></a>通过修改文件配置</h3><ul><li><p>修改前先将网络配置文件进行备份</p><p><code># cp  /etc/network/interfaces  /etc/network/interfaces.bak</code></p></li><li><p>修改网络配置文件<code>/etc/network/interfaces</code></p><p><code># vi  /etc/network/interfaces    //修改结果如下</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line"> </span><br><span class="line"># Enabing Bridge networking br0 interface</span><br><span class="line">auto br0</span><br><span class="line">iface br0 inet static</span><br><span class="line">address 192.168.1.25</span><br><span class="line">network 192.168.1.0</span><br><span class="line">netmask 255.255.255.0</span><br><span class="line">broadcast 192.168.1.255</span><br><span class="line">gateway 192.168.1.1</span><br><span class="line">dns-nameservers 223.5.5.5</span><br><span class="line">bridge_ports eth0</span><br><span class="line">bridge_stp off</span><br></pre></td></tr></table></figure></li></ul><p>保存后退出，关机重启中配置文件就生效了。这种方法只需要修改配置文件然后重启就可以，比较简单，而且是永久生效，比较符合我们的需求，因为我们的虚拟机通过桥接模式连接外网的话都是连接到br0上的。 </p><h2 id="修改virbr0的网段"><a href="#修改virbr0的网段" class="headerlink" title="修改virbr0的网段"></a>修改virbr0的网段</h2><p>在服务器上安装好虚拟化软件后，KVM会自动生成一个<code>virbr0</code>的桥接设备，它的作用是为连接其上的虚拟网卡提供NAT访问外网的功能，并提供DHCP服务。<code>virbr0</code>默认分配的IP是<code>192.168.122.1</code>，使用 <code>ifconfig</code> 命令查看得<code>virbr0</code>的信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$  ifconfig</span><br><span class="line">……</span><br><span class="line"> </span><br><span class="line">virbr0    Link encap:Ethernet  HWaddr 52:54:00:f8:70:e3  </span><br><span class="line">          inet addr:192.168.122.1  Bcast:192.168.122.255  Mask:255.255.255.0</span><br><span class="line">          UP BROADCAST MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:0 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000</span><br><span class="line">          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)</span><br></pre></td></tr></table></figure><p> 在这种情况下，连接到virbr0上的虚拟机的虚拟网卡也是在192.168.122.0网段上的，如果让连接到virbr0上的虚拟网卡在自定义的网段上就需要修改virbr0的网段，修改方法如下： </p><p><code># virsh  net-edit  default</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;network&gt;</span><br><span class="line">  &lt;name&gt;default&lt;/name&gt;</span><br><span class="line">  &lt;uuid&gt;91cc230a-bf53-487c-b296-10323705d7e8&lt;/uuid&gt;</span><br><span class="line">  &lt;forward mode=&apos;nat&apos;/&gt;</span><br><span class="line">  &lt;bridge name=&apos;virbr0&apos; stp=&apos;on&apos; delay=&apos;0&apos;/&gt;</span><br><span class="line">  &lt;mac address=&apos;52:54:00:f8:70:e3&apos;/&gt;</span><br><span class="line">  &lt;ip address=&apos;10.0.0.1&apos; netmask=&apos;255.255.255.0&apos;&gt;</span><br><span class="line">    &lt;dhcp&gt;</span><br><span class="line">      &lt;range start=&apos;10.0.0.2&apos; end=&apos;10.0.0.254&apos;/&gt;</span><br><span class="line">    &lt;/dhcp&gt;</span><br><span class="line">  &lt;/ip&gt;</span><br><span class="line">&lt;/network&gt;</span><br></pre></td></tr></table></figure><p>这样就将<code>virbr0</code>的网段改成<code>10.0.0.0/24</code>，连接到<code>virbr0</code>的虚拟网卡的IP将会在<code>10.0.0.2/24 - 10.0.0.254/24</code>范围内自动分配一个。如果有需要可以自己手动给虚拟网卡配置IP并写到配置文件中去。 </p><h1 id="服务器安装VNC远程桌面"><a href="#服务器安装VNC远程桌面" class="headerlink" title="服务器安装VNC远程桌面"></a>服务器安装VNC远程桌面</h1><p>因为服务器上安装的<code>Ubuntu 16.04 LTS  desktop</code>版的系统，在后续的工作中需要远程登录到服务器，虽然可以通过SSH远程管理服务器，但是可视化的界面往往会给新手用户提供很大的便利，所以可以在服务器上安装VNC。开始在服务器上安装VNC试过很多方法，VNC服务器端也有多种选择，如<code>VNC4server</code>、<code>tigervncserver</code>，感觉很麻烦，而且还不一定能安装成功，我安装的VNC服务器端是<code>x11VNC</code>，按照步骤可以很顺利地完成安装，步骤如下： </p><h2 id="安装x11VNC软件包"><a href="#安装x11VNC软件包" class="headerlink" title="安装x11VNC软件包"></a>安装x11VNC软件包</h2><p><code>$ sudo  apt-get  install  x11vnc</code></p><h2 id="配置访问密码"><a href="#配置访问密码" class="headerlink" title="配置访问密码"></a>配置访问密码</h2><p><code>$ sudo  x11vnc  -storepasswd  /etc/x11vnc.pass</code></p><h2 id="创建服务"><a href="#创建服务" class="headerlink" title="创建服务"></a>创建服务</h2><p><code># vi  /lib/systemd/system/x11vnc.service      //粘贴一下代码，最后:wq 保存，请使用root用户，否则没有权限</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Start x11vnc at startup.</span><br><span class="line">After=multi-user.target</span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">ExecStart=/usr/bin/x11vnc -auth guess -forever -loop -noxdamage -repeat -rfbauth /etc/x11vnc.pass -rfbport 5900 -shared</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><h2 id="配置防火墙，配置和启动服务"><a href="#配置防火墙，配置和启动服务" class="headerlink" title="配置防火墙，配置和启动服务"></a>配置防火墙，配置和启动服务</h2><p><code># ufw allow 5900</code></p><p><code># systemctl enable x11vnc.service</code></p><p><code># systemctl daemon-reload</code></p><p>完成这四个步骤然后重启就可以了。（这个VNC的安装过程可以参考<a href="http://blog.csdn.net/longhr/article/details/51657610）" target="_blank" rel="noopener">http://blog.csdn.net/longhr/article/details/51657610）</a> </p><p>最后在你自己的电脑需要有一个vnc viewer的软件，可以在这里下载（链接：<a href="https://pan.baidu.com/s/1o8kPqXG" target="_blank" rel="noopener">https://pan.baidu.com/s/1o8kPqXG</a> 密码：v5r2） </p><h1 id="创建VM并配置相关信息"><a href="#创建VM并配置相关信息" class="headerlink" title="创建VM并配置相关信息"></a>创建VM并配置相关信息</h1><p>在安装好VNC后就可以登录服务器的远程桌面，打开一个terminal，在terminal中输入下面的命令可以打开Virtual Machine  Manager（注意，使用SSH远程登录服务器是无法打开virt-manager的界面的，一定要在登录了远程桌面后才能打开界面）</p><p><img src="https://img-blog.csdn.net/20171201233200479" alt="VMM"></p><p>使用Virtual Machine Manager的界面可以很方便的创建虚拟机，当然也可以在命令行中使用命令创建虚拟机，这个我就不在这里说了。 </p><h2 id="按照Openstack官网安装文档的主机网络配置两台虚拟机Controller和Compute"><a href="#按照Openstack官网安装文档的主机网络配置两台虚拟机Controller和Compute" class="headerlink" title="按照Openstack官网安装文档的主机网络配置两台虚拟机Controller和Compute"></a>按照Openstack官网安装文档的主机网络配置两台虚拟机Controller和Compute</h2><p><img src="https://raw.githubusercontent.com/cao0507/Pictures/master/blog/openstack%20network.png" alt="openstack network"></p><p>控制节点和计算节点这两个虚拟机分别两张网卡，一张配置为桥接模式，另一张配置为NAT模式。创建虚拟机时默认是添加一张网卡的，后面可以在虚拟机的硬件信息中添加。两张虚拟网卡的配置信息如图： </p><p><img src="https://raw.githubusercontent.com/cao0507/Pictures/master/blog/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E7%BD%91%E5%8D%A1.png" alt="compute1"></p><p>上图显示的是桥接模式网卡的配置信息，Network source选择为<code>Bridge br0：Host device eth0</code> </p><p><img src="https://raw.githubusercontent.com/cao0507/Pictures/master/blog/NAT%E7%BD%91%E5%8D%A1.png" alt="NAT"></p><p>上图显示的是NAT模式网卡的配置信息，Network source选择为<code>Virtual network ‘default’：NAT</code> </p><p>这样按照官方文档部署双节点Openstack的前期准备工作就已经做完，后面就可以按照官方文档开始安装openstack了，祝你成功。附上官方文档链接<a href="https://docs.openstack.org/ocata/zh_CN/install-guide-ubuntu/index.html" target="_blank" rel="noopener">https://docs.openstack.org/ocata/zh_CN/install-guide-ubuntu/index.html</a> （注：这个是在ubuntu系统下安装Ocata版本Openstack中文文档） </p><hr>]]></content>
      
      <categories>
          
          <category> KVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KVM </tag>
            
            <tag> Openstack </tag>
            
            <tag> vnc </tag>
            
            <tag> ubuntu </tag>
            
            <tag> Virtual Machine </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
